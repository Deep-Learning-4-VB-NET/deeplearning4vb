Imports System
Imports System.Runtime.InteropServices
Imports org.bytedeco.javacpp
Imports org.bytedeco.javacpp.annotation
Imports org.bytedeco.javacpp.presets.javacpp
Imports org.bytedeco.openblas.global.openblas_nolapack
Imports org.bytedeco.openblas.global.openblas

' Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

Namespace org.nd4j.nativeblas

	Public Class Nd4jCpu
		Inherits org.nd4j.nativeblas.Nd4jCpuHelper

		Shared Sub New()
			Loader.load()
			Loader.load()
			Loader.load()
			Loader.load()
			Loader.load()
			Loader.load()
			Loader.load()
				Loader.load()
			Loader.load()
			Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
					Loader.load()
					Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
				Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
				Loader.load()
					Loader.load()
					Loader.load()
				Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
				Loader.load()
				Loader.load()
			Loader.load()
				Loader.load()
					Loader.load()
						Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
				Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
																							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
																							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
							Loader.load()
						Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
						Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
							Loader.load()
							Loader.load()
							Loader.load()
							Loader.load()
							Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
					Loader.load()
							Loader.load()
				Loader.load()
			Loader.load()
			Loader.load()
				Loader.load()
				Loader.load()
					Loader.load()
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Name("std::vector<std::vector<int> >") public static class IntVectorVector extends Pointer
	Public Class IntVectorVector
		Inherits Pointer

		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		Public Sub New(ByVal p As Pointer)
			MyBase.New(p)
		End Sub
		Public Sub New(ParamArray ByVal array()() As Integer)
			Me.New(array.Length)
			put(array)
		End Sub
		Public Sub New()
			allocate()
		End Sub
		Public Sub New(ByVal n As Long)
			allocate(n)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Friend Sub allocate()
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Friend Sub allocate(ByVal n As Long)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator =") @ByRef IntVectorVector put(@ByRef IntVectorVector x);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public @ByRef Function put(ByVal x As IntVectorVector) As IntVectorVector
		End Function

		Public Overridable Function empty() As Boolean
			Return size() = 0
		End Function
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function size() As Long
		End Function
		Public Overridable Sub clear()
			resize(0)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void resize(@Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Sub resize(ByVal n As Long)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public boolean empty(@Cast("size_t") long i)
		Public Overridable Function empty(ByVal i As Long) As Boolean
			Return size(i) = 0
		End Function
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Index(function = "at") long size(@Cast("size_t") long i);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function size(ByVal i As Long) As Long
		End Function
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public void clear(@Cast("size_t") long i)
		Public Overridable Sub clear(ByVal i As Long)
			resize(i, 0)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Index(function = "at") void resize(@Cast("size_t") long i, @Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Sub resize(ByVal i As Long, ByVal n As Long)
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Index(function = "at") public native int get(@Cast("size_t") long i, @Cast("size_t") long j);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function get(ByVal i As Long, ByVal j As Long) As Integer
		End Function
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native IntVectorVector put(@Cast("size_t") long i, @Cast("size_t") long j, int value);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function put(ByVal i As Long, ByVal j As Long, ByVal value As Integer) As IntVectorVector
		End Function

		Public Overridable Function get() As Integer()()
			Dim array(If(size() < Integer.MaxValue, CInt(Math.Truncate(size())), Integer.MaxValue) - 1)() As Integer
			For i As Integer = 0 To array.Length - 1
				array(i) = New Integer(If(size(i) < Integer.MaxValue, CInt(Math.Truncate(size(i))), Integer.MaxValue) - 1){}
				Dim j As Integer = 0
				Do While j < array(i).Length
					array(i)(j) = get(i, j)
					j += 1
				Loop
			Next i
			Return array
		End Function
		Public Overrides Function ToString() As String
			Return java.util.Arrays.deepToString(get())
		End Function

		Public Overridable Function put(ParamArray ByVal array()() As Integer) As IntVectorVector
			If size() <> array.Length Then
				resize(array.Length)
			End If
			For i As Integer = 0 To array.Length - 1
				If size(i) <> array(i).Length Then
					resize(i, array(i).Length)
				End If
				Dim j As Integer = 0
				Do While j < array(i).Length
					put(i, j, array(i)(j))
					j += 1
				Loop
			Next i
			Return Me
		End Function
	End Class

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Name("std::vector<std::vector<Nd4jLong> >") public static class LongVectorVector extends Pointer
	Public Class LongVectorVector
		Inherits Pointer

		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		Public Sub New(ByVal p As Pointer)
			MyBase.New(p)
		End Sub
		Public Sub New(ParamArray ByVal array()() As Long)
			Me.New(array.Length)
			put(array)
		End Sub
		Public Sub New()
			allocate()
		End Sub
		Public Sub New(ByVal n As Long)
			allocate(n)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Friend Sub allocate()
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Friend Sub allocate(ByVal n As Long)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator =") @ByRef LongVectorVector put(@ByRef LongVectorVector x);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public @ByRef Function put(ByVal x As LongVectorVector) As LongVectorVector
		End Function

		Public Overridable Function empty() As Boolean
			Return size() = 0
		End Function
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function size() As Long
		End Function
		Public Overridable Sub clear()
			resize(0)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void resize(@Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Sub resize(ByVal n As Long)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public boolean empty(@Cast("size_t") long i)
		Public Overridable Function empty(ByVal i As Long) As Boolean
			Return size(i) = 0
		End Function
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Index(function = "at") long size(@Cast("size_t") long i);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Function size(ByVal i As Long) As Long
		End Function
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public void clear(@Cast("size_t") long i)
		Public Overridable Sub clear(ByVal i As Long)
			resize(i, 0)
		End Sub
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Index(function = "at") void resize(@Cast("size_t") long i, @Cast("size_t") long n);
'JAVA TO VB CONVERTER TODO TASK: Replace 'unknown' with the appropriate dll name:
		<DllImport("unknown")>
		Public Sub resize(ByVal i As Long, ByVal n As Long)
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Index(function = "at") public native @Cast("Nd4jLong") long get(@Cast("size_t") long i, @Cast("size_t") long j);
		Long get( Long i, Long j)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native LongVectorVector put(@Cast("size_t") long i, @Cast("size_t") long j, long value);
		public native LongVectorVector put( Long i, Long j, Long value)

		public Long()() get()
		If True Then
			Dim array(If(size() < Integer.MaxValue, CInt(Math.Truncate(size())), Integer.MaxValue) - 1)() As Long
			For i As Integer = 0 To array.Length - 1
				array(i) = New Long(If(size(i) < Integer.MaxValue, CInt(Math.Truncate(size(i))), Integer.MaxValue) - 1){}
				Dim j As Integer = 0
				Do While j < array(i).Length
					array(i)(j) = get(i, j)
					j += 1
				Loop
			Next i
			Return array
		End If
		public String ToString()
		If True Then
			Return java.util.Arrays.deepToString(get())
		End If

		public LongVectorVector put(Long()... array)
		If True Then
			If size() <> array.length Then
				resize(array.length)
			End If
			For i As Integer = 0 To array.length - 1
				If size(i) <> array(i).length Then
					resize(i, array(i).length)
				End If
				Dim j As Integer = 0
				Do While j < array(i).length
					put(i, j, array(i)(j))
					j += 1
				Loop
			Next i
			Return Me
		End If
	End Class

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Name("std::vector<const sd::NDArray*>") public static class ConstNDArrayVector extends Pointer
	public static class ConstNDArrayVector extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public ConstNDArrayVector(Pointer p)
		If True Then
			MyBase(p)
		End If
		public ConstNDArrayVector(NDArray value)
		If True Then
			Me(1)
			put(0, value)
		End If
		public ConstNDArrayVector(NDArray... array)
		If True Then
			Me(array.length)
			put(array)
		End If
		public ConstNDArrayVector()
		If True Then
			allocate()
		End If
		public ConstNDArrayVector(Long n)
		If True Then
			allocate(n)
		End If
		private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("size_t") long n);
		private native void allocate( Long n)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator =") @ByRef ConstNDArrayVector put(@ByRef ConstNDArrayVector x);
		public native @ByRef ConstNDArrayVector put( ConstNDArrayVector x)

		public Boolean empty()
		If True Then
			Return size() = 0
		End If
		public native Long size()
		public void clear()
		If True Then
			resize(0)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void resize(@Cast("size_t") long n);
		public native void resize( Long n)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Index(function = "at") public native @Const NDArray get(@Cast("size_t") long i);
		NDArray get( Long i)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ConstNDArrayVector put(@Cast("size_t") long i, NDArray value);
		public native ConstNDArrayVector put( Long i, NDArray value)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator insert(@ByVal Iterator pos, @Const NDArray value);
		public native System.Collections.IEnumerator insert( System.Collections.IEnumerator pos, NDArray value)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator erase(@ByVal Iterator pos);
		public native System.Collections.IEnumerator [erase]( System.Collections.IEnumerator pos)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator begin();
		public native System.Collections.IEnumerator begin()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator end();
		public native System.Collections.IEnumerator [end]()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @NoOffset @Name("iterator") public static class Iterator extends Pointer
		public static class System.Collections.IEnumerator extends Pointer
		If True Then
			public Iterator(Pointer p)
			If True Then
				MyBase(p)
			End If
			public Iterator()
			If True Then
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator ++") @ByRef Iterator increment();
			public native @ByRef Iterator increment()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator ==") boolean equals(@ByRef Iterator it);
			public native Boolean Equals( System.Collections.IEnumerator it)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator *") @Const NDArray get();
			public native @Const NDArray get()
		End If

		public NDArray() get()
		If True Then
			Dim array(If(size() < Integer.MaxValue, CInt(Math.Truncate(size())), Integer.MaxValue) - 1) As NDArray
			For i As Integer = 0 To array.Length - 1
				array(i) = get(i)
			Next i
			Return array
		End If
		public String ToString()
		If True Then
			Return java.util.Arrays.toString(get())
		End If

		public NDArray pop_back()
		If True Then
			Dim size As Long = size()
			Dim value As NDArray = get(size - 1)
			resize(size - 1)
			Return value
		End If
		public ConstNDArrayVector push_back(NDArray value)
		If True Then
			Dim size As Long = size()
			resize(size + 1)
			Return put(size, value)
		End If
		public ConstNDArrayVector put(NDArray value)
		If True Then
			If size() <> 1 Then
				resize(1)
			End If
			Return put(0, value)
		End If
		public ConstNDArrayVector put(NDArray... array)
		If True Then
			If size() <> array.length Then
				resize(array.length)
			End If
			For i As Integer = 0 To array.length - 1
				put(i, array(i))
			Next i
			Return Me
		End If
	End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Name("std::vector<sd::NDArray*>") public static class NDArrayVector extends Pointer
	public static class NDArrayVector extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public NDArrayVector(Pointer p)
		If True Then
			MyBase(p)
		End If
		public NDArrayVector(NDArray value)
		If True Then
			Me(1)
			put(0, value)
		End If
		public NDArrayVector(NDArray... array)
		If True Then
			Me(array.length)
			put(array)
		End If
		public NDArrayVector()
		If True Then
			allocate()
		End If
		public NDArrayVector(Long n)
		If True Then
			allocate(n)
		End If
		private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("size_t") long n);
		private native void allocate( Long n)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator =") @ByRef NDArrayVector put(@ByRef NDArrayVector x);
		public native @ByRef NDArrayVector put( NDArrayVector x)

		public Boolean empty()
		If True Then
			Return size() = 0
		End If
		public native Long size()
		public void clear()
		If True Then
			resize(0)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void resize(@Cast("size_t") long n);
		public native void resize( Long n)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Index(function = "at") public native NDArray get(@Cast("size_t") long i);
		public native NDArray get( Long i)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArrayVector put(@Cast("size_t") long i, NDArray value);
		public native NDArrayVector put( Long i, NDArray value)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator insert(@ByVal Iterator pos, NDArray value);
		public native System.Collections.IEnumerator insert( System.Collections.IEnumerator pos, NDArray value)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator erase(@ByVal Iterator pos);
		public native System.Collections.IEnumerator [erase]( System.Collections.IEnumerator pos)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator begin();
		public native System.Collections.IEnumerator begin()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal Iterator end();
		public native System.Collections.IEnumerator [end]()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @NoOffset @Name("iterator") public static class Iterator extends Pointer
		public static class System.Collections.IEnumerator extends Pointer
		If True Then
			public Iterator(Pointer p)
			If True Then
				MyBase(p)
			End If
			public Iterator()
			If True Then
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator ++") @ByRef Iterator increment();
			public native @ByRef Iterator increment()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator ==") boolean equals(@ByRef Iterator it);
			public native Boolean Equals( System.Collections.IEnumerator it)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator *") @Const NDArray get();
			public native @Const NDArray get()
		End If

		public NDArray() get()
		If True Then
			Dim array(If(size() < Integer.MaxValue, CInt(Math.Truncate(size())), Integer.MaxValue) - 1) As NDArray
			For i As Integer = 0 To array.Length - 1
				array(i) = get(i)
			Next i
			Return array
		End If
		public String ToString()
		If True Then
			Return java.util.Arrays.toString(get())
		End If

		public NDArray pop_back()
		If True Then
			Dim size As Long = size()
			Dim value As NDArray = get(size - 1)
			resize(size - 1)
			Return value
		End If
		public NDArrayVector push_back(NDArray value)
		If True Then
			Dim size As Long = size()
			resize(size + 1)
			Return put(size, value)
		End If
		public NDArrayVector put(NDArray value)
		If True Then
			If size() <> 1 Then
				resize(1)
			End If
			Return put(0, value)
		End If
		public NDArrayVector put(NDArray... array)
		If True Then
			If size() <> array.length Then
				resize(array.length)
			End If
			For i As Integer = 0 To array.length - 1
				put(i, array(i))
			Next i
			Return Me
		End If
	End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @NoOffset @Name("std::pair<int,int>") public static class IntIntPair extends Pointer
	public static class IntIntPair extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public IntIntPair(Pointer p)
		If True Then
			MyBase(p)
		End If
		public IntIntPair(Integer firstValue, Integer secondValue)
		If True Then
			Me()
			put(firstValue, secondValue)
		End If
		public IntIntPair()
		If True Then
			allocate()
		End If
		private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator =") @ByRef IntIntPair put(@ByRef IntIntPair x);
		public native @ByRef IntIntPair put( IntIntPair x)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @MemberGetter public native int first();
		public native Integer first()
		public native IntIntPair first(Integer first)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @MemberGetter public native int second();
		public native Integer second()
		public native IntIntPair second(Integer second)

		public IntIntPair put(Integer firstValue, Integer secondValue)
		If True Then
			first(firstValue)
			second(secondValue)
			Return Me
		End If
	End If

	' Parsed from memory/MemoryType.h

	'
	' Created by raver119 on 07.05.19.
	'

	' #ifndef DEV_TESTS_MEMORYTYPE_H
	' #define DEV_TESTS_MEMORYTYPE_H
			''' <summary>
			''' enum sd::memory::MemoryType </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int HOST = 0, DEVICE = 10;
			0, DEVICE = 10
				public static final Integer HOST = 0, DEVICE



	' #endif //DEV_TESTS_MEMORYTYPE_H


	' Parsed from array/DataType.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef ND4J_DATATYPE_H
	' #define ND4J_DATATYPE_H
		''' <summary>
		''' enum sd::DataType </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8 = 50, UTF16 = 51, UTF32 = 52, ANY = 100, AUTO = 200;
		100, AUTO = 200
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8 = 50, UTF16 = 51, UTF32 = 52, ANY = 100, AUTO
			52, ANY = 100, AUTO
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8 = 50, UTF16 = 51, UTF32 = 52, ANY
				51, UTF32 = 52, ANY
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8 = 50, UTF16 = 51, UTF32
					50, UTF16 = 51, UTF32
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8 = 50, UTF16
						17, UTF8 = 50, UTF16
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16 = 17, UTF8
							16, BFLOAT16 = 17, UTF8
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16 = 16, BFLOAT16
								15, QINT16 = 16, BFLOAT16
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8 = 15, QINT16
									14, QINT8 = 15, QINT16
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64 = 14, QINT8
										13, UINT64 = 14, QINT8
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32 = 13, UINT64
											12, UINT32 = 13, UINT64
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16 = 12, UINT32
												11, UINT16 = 12, UINT32
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8 = 11, UINT16
													10, UINT8 = 11, UINT16
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64 = 10, UINT8
														9, INT64 = 10, UINT8
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32 = 9, INT64
															8, INT32 = 9, INT64
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16 = 8, INT32
																7, INT16 = 8, INT32
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8 = 7, INT16
																	6, INT8 = 7, INT16
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE = 6, INT8
																		5, [DOUBLE] = 6, INT8
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32 = 5, @DOUBLE
																			4, FLOAT32 = 5, [DOUBLE]
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2 = 4, FLOAT32
																				3, HALF2 = 4, FLOAT32
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF = 3, HALF2
																					2, HALF = 3, HALF2
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8 = 2, HALF
																						1, FLOAT8 = 2, HALF
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int INHERIT = 0, BOOL = 1, FLOAT8
																							0, BOOL = 1, FLOAT8
																								public static final Integer INHERIT = 0, BOOL


	' #endif

	' Parsed from array/DataBuffer.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	' @author Yurii Shyrma (iuriish@yahoo.com)
	'

	' #ifndef DEV_TESTS_DATABUFFER_H
	' #define DEV_TESTS_DATABUFFER_H

	' #include <cstring>
	' #include <system/op_boilerplate.h>
	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <array/DataType.h>
	' #include <memory/Workspace.h>
	' #include <execution/LaunchContext.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class DataBuffer extends Pointer
	public static class DataBuffer extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public DataBuffer(Pointer p)
		If True Then
			MyBase(p)
		End If
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public DataBuffer(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public DataBuffer position(Long position)
		If True Then
			Return CType(MyBase.position(position), DataBuffer)
		End If
		public DataBuffer getPointer(Long i)
		If True Then
			Return (New DataBuffer(CType(Me, Pointer))).position(position + i)
		End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(Pointer primary, Pointer special, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, @Cast("const bool") boolean isOwnerPrimary, @Cast("const bool") boolean isOwnerSpecial, Workspace workspace)
			public DataBuffer(Pointer primary, Pointer special, Long lenInBytes, Integer dataType, Boolean isOwnerPrimary, Boolean isOwnerSpecial, Workspace workspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(primary, special, lenInBytes, dataType, isOwnerPrimary, isOwnerSpecial, workspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer primary, Pointer special, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, @Cast("const bool") boolean isOwnerPrimary, @Cast("const bool") boolean isOwnerSpecial, Workspace workspace);
			private native void allocate(Pointer primary, Pointer special, Long lenInBytes, Integer dataType, Boolean isOwnerPrimary, Boolean isOwnerSpecial, Workspace workspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(Pointer primary, Pointer special, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType)
			public DataBuffer(Pointer primary, Pointer special, Long lenInBytes, Integer dataType)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(primary, special, lenInBytes, dataType)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer primary, Pointer special, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType);
			private native void allocate(Pointer primary, Pointer special, Long lenInBytes, Integer dataType)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(Pointer primary, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, @Cast("const bool") boolean isOwnerPrimary, Workspace workspace)
			public DataBuffer(Pointer primary, Long lenInBytes, Integer dataType, Boolean isOwnerPrimary, Workspace workspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(primary, lenInBytes, dataType, isOwnerPrimary, workspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer primary, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, @Cast("const bool") boolean isOwnerPrimary, Workspace workspace);
			private native void allocate(Pointer primary, Long lenInBytes, Integer dataType, Boolean isOwnerPrimary, Workspace workspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(Pointer primary, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType)
			public DataBuffer(Pointer primary, Long lenInBytes, Integer dataType)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(primary, lenInBytes, dataType)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer primary, @Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType);
			private native void allocate(Pointer primary, Long lenInBytes, Integer dataType)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(@Const Pointer hostBuffer, @Cast("const sd::DataType") int dataType, @Cast("const size_t") long lenInBytes, Workspace workspace)
			public DataBuffer( Pointer hostBuffer, Integer dataType, Long lenInBytes, Workspace workspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(hostBuffer, dataType, lenInBytes, workspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const Pointer hostBuffer, @Cast("const sd::DataType") int dataType, @Cast("const size_t") long lenInBytes, Workspace workspace);
			private native void allocate( Pointer hostBuffer, Integer dataType, Long lenInBytes, Workspace workspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(@Const Pointer hostBuffer, @Cast("const sd::DataType") int dataType, @Cast("const size_t") long lenInBytes)
			public DataBuffer( Pointer hostBuffer, Integer dataType, Long lenInBytes)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(hostBuffer, dataType, lenInBytes)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const Pointer hostBuffer, @Cast("const sd::DataType") int dataType, @Cast("const size_t") long lenInBytes);
			private native void allocate( Pointer hostBuffer, Integer dataType, Long lenInBytes)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(@Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, Workspace workspace, @Cast("const bool") boolean allocBoth)
			public DataBuffer( Long lenInBytes, Integer dataType, Workspace workspace, Boolean allocBoth)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(lenInBytes, dataType, workspace, allocBoth)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType, Workspace workspace, @Cast("const bool") boolean allocBoth);
			private native void allocate( Long lenInBytes, Integer dataType, Workspace workspace, Boolean allocBoth)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(@Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType)
			public DataBuffer( Long lenInBytes, Integer dataType)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(lenInBytes, dataType)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const size_t") long lenInBytes, @Cast("const sd::DataType") int dataType);
			private native void allocate( Long lenInBytes, Integer dataType)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public DataBuffer(@Const @ByRef DataBuffer other)
			public DataBuffer( DataBuffer other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef DataBuffer other);
			private native void allocate( DataBuffer other)
			public DataBuffer()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") DataBuffer put(@Const @ByRef DataBuffer other);
			public native @Name("operator =") DataBuffer put( DataBuffer other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int getDataType();
			public native Integer getDataType()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDataType(@Cast("sd::DataType") int dataType);
			public native void setDataType( Integer dataType)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long getLenInBytes();
			public native Long getLenInBytes()

			public native Pointer primary()
			public native Pointer special()

			public native void allocatePrimary()
			public native void allocateSpecial()

			public native void writePrimary()
			public native void writeSpecial()
			public native void readPrimary()
			public native void readSpecial()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isPrimaryActual();
			public native Boolean isPrimaryActual()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSpecialActual();
			public native Boolean isSpecialActual()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void expand(@Cast("const uint64_t") long size);
			public native void expand( Long size)

			public native Integer deviceId()
			public native void setDeviceId(Integer deviceId)
			public native void migrate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void syncToPrimary(@Const LaunchContext context, @Cast("const bool") boolean forceSync);
			public native void syncToPrimary( LaunchContext context, Boolean forceSync)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void syncToPrimary(@Const LaunchContext context);
			public native void syncToPrimary( LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void syncToSpecial(@Cast("const bool") boolean forceSync);
			public native void syncToSpecial( Boolean forceSync)
			public native void syncToSpecial()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setToZeroBuffers(@Cast("const bool") boolean both);
			public native void setToZeroBuffers( Boolean both)
			public native void setToZeroBuffers()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void copyBufferFrom(@Const @ByRef DataBuffer other, @Cast("size_t") long sizeToCopyinBytes, @Cast("const Nd4jLong") long offsetThis, @Cast("const Nd4jLong") long offsetOther);
			public native void copyBufferFrom( DataBuffer other, Long sizeToCopyinBytes, Long offsetThis, Long offsetOther)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void copyBufferFrom(@Const @ByRef DataBuffer other);
			public native void copyBufferFrom( DataBuffer other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public static native void memcpy(@Const @ByRef DataBuffer dst, @Const @ByRef DataBuffer src);
			public static native void memcpy( DataBuffer dst, @ByRef DataBuffer src)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setPrimaryBuffer(Pointer buffer, @Cast("size_t") long length);
			public native void setPrimaryBuffer(Pointer buffer, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setSpecialBuffer(Pointer buffer, @Cast("size_t") long length);
			public native void setSpecialBuffer(Pointer buffer, Long length)

			''' <summary>
			''' This method deletes buffers, if we're owners
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("close") void _close();
			public native void _close()
	End If
	'/// IMLEMENTATION OF INLINE METHODS /////

	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////





	' #endif //DEV_TESTS_DATABUFFER_H


	' Parsed from array/PointerDeallocator.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	'  @author raver119@gmail.com
	'

	' #ifndef SD_POINTERDEALLOCATOR_H_
	' #define SD_POINTERDEALLOCATOR_H_

	' #include <system/dll.h>
	' #include <system/pointercast.h>



	' #endif //SD_POINTERDEALLOCATOR_H_


	' Parsed from array/PointerWrapper.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	'  @author raver119@gmail.com
	'

	' #ifndef SD_ARRAY_POINTER_H_
	' #define SD_ARRAY_POINTER_H_

	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <array/PointerDeallocator.h>
	' #include <memory>
	 ' namespace sd

	' #endif //SD_ARRAY_POINTER_H_


	' Parsed from array/ConstantDataBuffer.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com

	' #ifndef LIBND4J_CONSTANTDATABUFFER_H
	' #define LIBND4J_CONSTANTDATABUFFER_H

	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <memory>
	' #include <array/PointerWrapper.h>
	' #include <array/DataType.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ConstantDataBuffer extends Pointer
		public static class ConstantDataBuffer extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ConstantDataBuffer(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ConstantDataBuffer(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ConstantDataBuffer position(Long position)
			If True Then
				Return CType(MyBase.position(position), ConstantDataBuffer)
			End If
			public ConstantDataBuffer getPointer(Long i)
			If True Then
				Return (New ConstantDataBuffer(CType(Me, Pointer))).position(position + i)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDataBuffer(@Const @ByRef ConstantDataBuffer other)
			public ConstantDataBuffer( ConstantDataBuffer other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ConstantDataBuffer other);
			private native void allocate( ConstantDataBuffer other)
			public ConstantDataBuffer()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint8_t") byte sizeOf();
			public native SByte sizeOf()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long length();
			public native Long length()

			public native Pointer primary()
			public native Pointer special()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") ConstantDataBuffer put(@Const @ByRef ConstantDataBuffer other);
			public native @Name("operator =") ConstantDataBuffer put( ConstantDataBuffer other)
		End If


	' #endif //DEV_TESTS_CONSTANTDATABUFFER_H


	' Parsed from array/ConstantShapeBuffer.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	' @author raver119@gmail.com
	'

	' #ifndef SD_ARRAY_CONSTANTSHAPEBUFFER_H_
	' #define SD_ARRAY_CONSTANTSHAPEBUFFER_H_

	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <array/PointerWrapper.h>
	' #include <memory>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class ConstantShapeBuffer extends Pointer
	public static class ConstantShapeBuffer extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public ConstantShapeBuffer(Pointer p)
		If True Then
			MyBase(p)
		End If
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public ConstantShapeBuffer(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public ConstantShapeBuffer position(Long position)
		If True Then
			Return CType(MyBase.position(position), ConstantShapeBuffer)
		End If
		public ConstantShapeBuffer getPointer(Long i)
		If True Then
			Return (New ConstantShapeBuffer(CType(Me, Pointer))).position(position + i)
		End If

	  public ConstantShapeBuffer()
	  If True Then
		  MyBase(DirectCast(Nothing, Pointer))
		  allocate()
	  End If
	  private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer primary();
	  public native LongPointer primary()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer special();
	  public native LongPointer special()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer platform();
	  public native LongPointer platform()
	End If

	 ' namespace sd

	' #endif //SD_ARRAY_CONSTANTSHAPEBUFFER_H_


	' Parsed from array/ConstantOffsetsBuffer.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	' @author raver119@gmail.com
	'

	' #ifndef SD_ARRAY_CONSTANTOFFSETSBUFFER_H_
	' #define SD_ARRAY_CONSTANTOFFSETSBUFFER_H_

	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <memory>
	' #include <array/PointerWrapper.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class ConstantOffsetsBuffer extends Pointer
	public static class ConstantOffsetsBuffer extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public ConstantOffsetsBuffer(Pointer p)
		If True Then
			MyBase(p)
		End If
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public ConstantOffsetsBuffer(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public ConstantOffsetsBuffer position(Long position)
		If True Then
			Return CType(MyBase.position(position), ConstantOffsetsBuffer)
		End If
		public ConstantOffsetsBuffer getPointer(Long i)
		If True Then
			Return (New ConstantOffsetsBuffer(CType(Me, Pointer))).position(position + i)
		End If

	  public ConstantOffsetsBuffer()
	  If True Then
		  MyBase(DirectCast(Nothing, Pointer))
		  allocate()
	  End If
	  private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer primary();
	  public native LongPointer primary()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer special();
	  public native LongPointer special()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer platform();
	  public native LongPointer platform()
	End If

	 ' namespace sd

	' #endif //SD_ARRAY_CONSTANTOFFSETSBUFFER_H_


	' Parsed from array/ConstantDescriptor.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef DEV_TESTS_CONSTANTDESCRIPTOR_H
	' #define DEV_TESTS_CONSTANTDESCRIPTOR_H

	' #include <array/DataType.h>
	' #include <unordered_map>
	' #include <vector>
	' #include <system/pointercast.h>
	' #include <system/dll.h>
	' #include <array/ConstantDataBuffer.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ConstantDescriptor extends Pointer
		public static class ConstantDescriptor extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ConstantDescriptor(Pointer p)
			If True Then
				MyBase(p)
			End If

			public ConstantDescriptor(DoublePointer values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
			private native void allocate(DoublePointer values, Integer length)
			public ConstantDescriptor(DoubleBuffer values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
			private native void allocate(DoubleBuffer values, Integer length)
			public ConstantDescriptor(Double() values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
			private native void allocate(Double() values, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("const Nd4jLong*") LongPointer values, int length)
			public ConstantDescriptor( LongPointer values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer values, int length);
			private native void allocate( LongPointer values, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("const Nd4jLong*") LongBuffer values, int length)
			public ConstantDescriptor( LongBuffer values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer values, int length);
			private native void allocate( LongBuffer values, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("const Nd4jLong*") long[] values, int length)
			public ConstantDescriptor( Long() values, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] values, int length);
			private native void allocate( Long() values, Integer length)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("Nd4jLong*") @StdVector LongPointer values)
			public ConstantDescriptor( LongPointer values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") @StdVector LongPointer values);
			private native void allocate( LongPointer values)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("Nd4jLong*") @StdVector LongBuffer values)
			public ConstantDescriptor( LongBuffer values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") @StdVector LongBuffer values);
			private native void allocate( LongBuffer values)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@Cast("Nd4jLong*") @StdVector long[] values)
			public ConstantDescriptor( Long() values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") @StdVector long[] values);
			private native void allocate( Long() values)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@StdVector DoublePointer values)
			public ConstantDescriptor( DoublePointer values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@StdVector DoublePointer values);
			private native void allocate( DoublePointer values)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@StdVector DoubleBuffer values)
			public ConstantDescriptor( DoubleBuffer values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@StdVector DoubleBuffer values);
			private native void allocate( DoubleBuffer values)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ConstantDescriptor(@StdVector double[] values)
			public ConstantDescriptor( Double() values)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(values)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@StdVector double[] values);
			private native void allocate( Double() values)

			' equal to operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef ConstantDescriptor other);
			public native @Name("operator ==") Boolean Equals( ConstantDescriptor other)

			' less than operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef ConstantDescriptor other);
			public native @Name("operator <") Boolean lessThan( ConstantDescriptor other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInteger();
			public native Boolean isInteger()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isFloat();
			public native Boolean isFloat()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long length();
			public native Long length()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer integerValues();
			public native @StdVector LongPointer integerValues()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector DoublePointer floatValues();
			public native DoublePointer floatValues()
		End If


	' #ifndef __JAVACPP_HACK__

	' #endif


	' #endif //DEV_TESTS_CONSTANTDESCRIPTOR_H


	' Parsed from array/TadPack.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef DEV_TESTS_TADPACK_H
	' #define DEV_TESTS_TADPACK_H

	' #include <array/ConstantOffsetsBuffer.h>
	' #include <array/ConstantShapeBuffer.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class TadPack extends Pointer
		public static class TadPack extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public TadPack(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public TadPack(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public TadPack position(Long position)
			If True Then
				Return CType(MyBase.position(position), TadPack)
			End If
			public TadPack getPointer(Long i)
			If True Then
				Return (New TadPack(CType(Me, Pointer))).position(position + i)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadPack(@Const @ByRef ConstantShapeBuffer shapes, @Const @ByRef ConstantOffsetsBuffer offets, @Cast("Nd4jLong") long numTads)
			public TadPack( ConstantShapeBuffer shapes, @ByRef ConstantOffsetsBuffer offets, Long numTads)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes, offets, numTads)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ConstantShapeBuffer shapes, @Const @ByRef ConstantOffsetsBuffer offets, @Cast("Nd4jLong") long numTads);
			private native void allocate( ConstantShapeBuffer shapes, @ByRef ConstantOffsetsBuffer offets, Long numTads)
			public TadPack()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer primaryShapeInfo();
			public native LongPointer primaryShapeInfo()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer primaryOffsets();
			public native LongPointer primaryOffsets()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer specialShapeInfo();
			public native LongPointer specialShapeInfo()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer specialOffsets();
			public native LongPointer specialOffsets()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long numberOfTads();
			public native Long numberOfTads()
			public native Integer shapeInfoLength()

			''' <summary>
			''' These methods return either primary or special pointers depending on platform binaries were compiled for
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer platformShapeInfo();
			public native LongPointer platformShapeInfo()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer platformOffsets();
			public native LongPointer platformOffsets()
		End If



	' #endif //DEV_TESTS_TADPACK_H


	' Parsed from execution/ErrorReference.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef DEV_TESTS_ERRORREFERENCE_H
	' #define DEV_TESTS_ERRORREFERENCE_H

	' #include <string>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ErrorReference extends Pointer
		public static class ErrorReference extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ErrorReference(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ErrorReference(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ErrorReference position(Long position)
			If True Then
				Return CType(MyBase.position(position), ErrorReference)
			End If
			public ErrorReference getPointer(Long i)
			If True Then
				Return (New ErrorReference(CType(Me, Pointer))).position(position + i)
			End If

			public ErrorReference()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			public native Integer errorCode()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String errorMessage();
			public native String errorMessage()

			public native void setErrorCode(Integer errorCode)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setErrorMessage(@StdString BytePointer message);
			public native void setErrorMessage( BytePointer message)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setErrorMessage(@StdString String message);
			public native void setErrorMessage( String message)
		End If



	' #endif //DEV_TESTS_ERRORREFERENCE_H


	' Parsed from execution/Engine.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef SD_ENGINE_H
	' #define SD_ENGINE_H
		''' <summary>
		''' enum samediff::Engine </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int ENGINE_CPU = 0, ENGINE_CUDA = 1;
		0, ENGINE_CUDA = 1
			public static final Integer ENGINE_CPU = 0, ENGINE_CUDA


	' #endif //SD_ENGINE_H


	' Parsed from execution/ExecutionMode.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************


	'
	' @author raver119@gmail.com
	'

	' #ifndef SD_EXECUTIONMODE_H
	' #define SD_EXECUTIONMODE_H
		''' <summary>
		''' enum samediff::ExecutionMode </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int MODE_UNDEFINED = 0, MODE_TRAINING = 1, MODE_INFERENCE = 2;
		1, MODE_INFERENCE = 2
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int MODE_UNDEFINED = 0, MODE_TRAINING = 1, MODE_INFERENCE
			0, MODE_TRAINING = 1, MODE_INFERENCE
				public static final Integer MODE_UNDEFINED = 0, MODE_TRAINING


	' #endif //SD_EXECUTIONMODE_H


	' Parsed from system/Environment.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 06.10.2017.
	'

	' #ifndef LIBND4J_ENVIRONMENT_H
	' #define LIBND4J_ENVIRONMENT_H

	' #include <atomic>
	' #include <vector>
	' #include <system/dll.h>
	' #include <stdexcept>
	' #include <array/DataType.h>
	' #include <types/pair.h>
	' #include <system/pointercast.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class Environment extends Pointer
		public static class Environment extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public Environment(Pointer p)
			If True Then
				MyBase(p)
			End If

			''' <summary>
			''' These 3 fields are mostly for CUDA/cuBLAS version tracking
			''' </summary>
			public native Integer _blasMajorVersion()
			public native Environment _blasMajorVersion(Integer setter)
			public native Integer _blasMinorVersion()
			public native Environment _blasMinorVersion(Integer setter)
			public native Integer _blasPatchVersion()
			public native Environment _blasPatchVersion(Integer setter)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public static native @ByRef Environment getInstance();
			public static native Environment getInstance()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isVerbose();
			public native Boolean isVerbose()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setVerbose(@Cast("bool") boolean reallyVerbose);
			public native void setVerbose( Boolean reallyVerbose)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isDebug();
			public native Boolean isDebug()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isProfiling();
			public native Boolean isProfiling()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isDetectingLeaks();
			public native Boolean isDetectingLeaks()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isDebugAndVerbose();
			public native Boolean isDebugAndVerbose()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDebug(@Cast("bool") boolean reallyDebug);
			public native void setDebug( Boolean reallyDebug)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setProfiling(@Cast("bool") boolean reallyProfile);
			public native void setProfiling( Boolean reallyProfile)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setLeaksDetector(@Cast("bool") boolean reallyDetect);
			public native void setLeaksDetector( Boolean reallyDetect)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean helpersAllowed();
			public native Boolean helpersAllowed()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void allowHelpers(@Cast("bool") boolean reallyAllow);
			public native void allowHelpers( Boolean reallyAllow)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean blasFallback();
			public native Boolean blasFallback()

			public native Integer tadThreshold()
			public native void setTadThreshold(Integer threshold)

			public native Integer elementwiseThreshold()
			public native void setElementwiseThreshold(Integer threshold)

			public native Integer maxThreads()
			public native void setMaxThreads(Integer max)

			public native Integer maxMasterThreads()
			public native void setMaxMasterThreads(Integer max)

	'        
	'         * Legacy memory limits API, still used in new API as simplified version
	'         
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setMaxPrimaryMemory(@Cast("uint64_t") long maxBytes);
			public native void setMaxPrimaryMemory( Long maxBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setMaxSpecialyMemory(@Cast("uint64_t") long maxBytes);
			public native void setMaxSpecialyMemory( Long maxBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setMaxDeviceMemory(@Cast("uint64_t") long maxBytes);
			public native void setMaxDeviceMemory( Long maxBytes)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long maxPrimaryMemory();
			public native Long maxPrimaryMemory()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long maxSpecialMemory();
			public native Long maxSpecialMemory()
			'//////////////////////

	'        
	'         * Methods for memory limits/counters
	'         
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGroupLimit(int group, @Cast("Nd4jLong") long numBytes);
			public native void setGroupLimit(Integer group, Long numBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDeviceLimit(int deviceId, @Cast("Nd4jLong") long numBytes);
			public native void setDeviceLimit(Integer deviceId, Long numBytes)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getGroupLimit(int group);
			public native Long getGroupLimit(Integer group)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getDeviceLimit(int deviceId);
			public native Long getDeviceLimit(Integer deviceId)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getGroupCounter(int group);
			public native Long getGroupCounter(Integer group)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getDeviceCounter(int deviceId);
			public native Long getDeviceCounter(Integer deviceId)
			'//////////////////////

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isUseMKLDNN();
			public native Boolean isUseMKLDNN()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setUseMKLDNN(@Cast("bool") boolean useMKLDNN);
			public native void setUseMKLDNN( Boolean useMKLDNN)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int defaultFloatDataType();
			public native Integer defaultFloatDataType()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDefaultFloatDataType(@Cast("sd::DataType") int dtype);
			public native void setDefaultFloatDataType( Integer dtype)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean precisionBoostAllowed();
			public native Boolean precisionBoostAllowed()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void allowPrecisionBoost(@Cast("bool") boolean reallyAllow);
			public native void allowPrecisionBoost( Boolean reallyAllow)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isExperimentalBuild();
			public native Boolean isExperimentalBuild()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isCPU();
			public native Boolean isCPU()

			public native Integer blasMajorVersion()
			public native Integer blasMinorVersion()
			public native Integer blasPatchVersion()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector Pair capabilities();
			public native Pair capabilities()
		End If



	' #endif //LIBND4J_ENVIRONMENT_H


	' Parsed from types/utf8string.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef DEV_TESTS_UTF8STRING_H
	' #define DEV_TESTS_UTF8STRING_H

	' #include <string>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class utf8string extends Pointer
		public static class utf8string extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public utf8string(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public utf8string(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public utf8string position(Long position)
			If True Then
				Return CType(MyBase.position(position), utf8string)
			End If
			public utf8string getPointer(Long i)
			If True Then
				Return (New utf8string(CType(Me, Pointer))).position(position + i)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") BytePointer _buffer();
			public native BytePointer _buffer()
			public native utf8string _buffer(BytePointer setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("unsigned int") int _length();
			public native Integer _length()
			public native utf8string _length(Integer setter)

			public utf8string()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public utf8string(@Cast("char*") String string, int length)
			public utf8string( String [string], Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate([string], length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") String string, int length);
			private native void allocate( String [string], Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public utf8string(@Cast("char*") BytePointer string, int length)
			public utf8string( BytePointer [string], Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate([string], length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") BytePointer string, int length);
			private native void allocate( BytePointer [string], Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public utf8string(@StdString BytePointer string)
			public utf8string( BytePointer [string])
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate([string])
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@StdString BytePointer string);
			private native void allocate( BytePointer [string])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public utf8string(@StdString String string)
			public utf8string( String [string])
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate([string])
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@StdString String string);
			private native void allocate( String [string])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public utf8string(@Const @ByRef utf8string other)
			public utf8string( utf8string other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef utf8string other);
			private native void allocate( utf8string other)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") utf8string put(@Const @ByRef utf8string other);
			public native @Name("operator =") utf8string put( utf8string other)
		End If



	' #endif //DEV_TESTS_UTF8STRING_H


	' Parsed from legacy/NativeOps.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by agibsonccc on 2/21/16.
	'

	' #ifndef NATIVEOPERATIONS_NATIVEOPS_H
	' #define NATIVEOPERATIONS_NATIVEOPS_H

	'
	'#ifndef thread_local
	'# if __STDC_VERSION__ >= 201112 && !defined __STDC_NO_THREADS__
	'#  define thread_local _Thread_local
	'# elif defined _WIN32 && ( \
	'       defined _MSC_VER || \
	'       defined __ICL || \
	'       defined __DMC__ || \
	'       defined __BORLANDC__ )
	'#  define thread_local __declspec(thread)
	'// note that ICC (linux) and Clang are covered by __GNUC__ 
	'# elif defined __GNUC__ || \
	'       defined __SUNPRO_C || \
	'       defined __xlC__
	'#  define thread_local __thread
	'# else
	'#  error "Cannot define thread_local"
	'# endif
	'#endif
	'

	' #include <system/pointercast.h>
	' #include <types/float16.h>
	' #include <cnpy/cnpy.h>

	'DO NOT REMOVE: THIS IS AN EDITOR SEMANTICS THING FOR CLION
	'IT DEFINES THE EXPORT MACRO FOR THE EDITOR AND THEN
	'RE ADDS THE DEFINITION VIA dll.h
	' #ifdef  _WIN32
	' #define ND4J_EXPORT __declspec(dllexport)
	' #else
	' #define ND4J_EXPORT
	' #endif
	' #include <system/dll.h>

	'
	'int tad_threshold = 1;
	'int element_threshold = 32;
	'
	'bool debug = false;
	'bool verbose = false;
	'

	' #include <array/ShapeList.h>
	' #include <array/ConstantDescriptor.h>
	' #include <helpers/ConstantShapeHelper.h>
	' #include <array/ConstantDataBuffer.h>
	' #include <array/InteropDataBuffer.h>
	' #include <helpers/ConstantHelper.h>
	' #include <array/TadPack.h>
	' #include <graph/VariablesSet.h>
	' #include <graph/GraphState.h>
	' #include <graph/execution/LogicExecutor.h>
	' #include <graph/ResultWrapper.h>
	' #include <helpers/DebugInfo.h>
	' #include <memory/MemoryCounter.h>

	''' <summary>
	''' This function returns last error code stored, </summary>
	''' <returns> non-zero if something bad happened </returns>
	public native Integer lastErrorCode()

	''' <summary>
	''' This function returns last error message, if last error code > 0
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String lastErrorMessage();
	public native String lastErrorMessage()

	''' 
	''' <param name="p"> </param>
	''' <param name="len"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tryPointer(@Cast("Nd4jPointer") Pointer extra, @Cast("Nd4jPointer") Pointer p, int len);
	public native void tryPointer( Pointer extra, Pointer p, Integer len)

	''' 
	''' <param name="num"> </param>
	public native void setElementThreshold(Integer num)

	''' 
	''' <param name="num"> </param>
	public native void setTADThreshold(Integer num)

	'''   
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduceScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execIndexReduceScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduceScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execIndexReduceScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduceScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execIndexReduceScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfoBuffer"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduce(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execIndexReduce( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduce(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execIndexReduce( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execIndexReduce(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execIndexReduce( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcast(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execBroadcast( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcast(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execBroadcast( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcast(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execBroadcast( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcastBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execBroadcastBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcastBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execBroadcastBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execBroadcastBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execBroadcastBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="dx"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="n"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransform(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransform( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransform(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransform( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransform(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransform( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execPairwiseTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execPairwiseTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduceFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduceFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduceFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduceSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduceSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduceSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduceBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduceBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduceBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduceLong( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduceLong( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduceLong( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execReduceFloat2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execReduceFloat2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceFloat2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execReduceFloat2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execReduceSame2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execReduceSame2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceSame2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execReduceSame2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execReduceBool2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execReduceBool2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceBool2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execReduceBool2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape);
	public native void execReduceLong2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape);
	public native void execReduceLong2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduceLong2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape);
	public native void execReduceLong2( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParamsVals"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduce3( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduce3( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduce3( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParamsVals"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeInfo"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Scalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo);
	public native void execReduce3Scalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Scalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo);
	public native void execReduce3Scalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Scalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo);
	public native void execReduce3Scalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo)
	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParamsVals"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfoBuffer"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Tad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape, @Cast("const Nd4jLong*") LongPointer tadOnlyShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets, @Cast("const Nd4jLong*") LongPointer yTadOnlyShapeInfo, @Cast("const Nd4jLong*") LongPointer yTadOffsets);
	public native void execReduce3Tad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape, LongPointer tadOnlyShapeInfo, LongPointer tadOffsets, LongPointer yTadOnlyShapeInfo, LongPointer yTadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Tad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape, @Cast("const Nd4jLong*") LongBuffer tadOnlyShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets, @Cast("const Nd4jLong*") LongBuffer yTadOnlyShapeInfo, @Cast("const Nd4jLong*") LongBuffer yTadOffsets);
	public native void execReduce3Tad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape, LongBuffer tadOnlyShapeInfo, LongBuffer tadOffsets, LongBuffer yTadOnlyShapeInfo, LongBuffer yTadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3Tad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape, @Cast("const Nd4jLong*") long[] tadOnlyShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets, @Cast("const Nd4jLong*") long[] yTadOnlyShapeInfo, @Cast("const Nd4jLong*") long[] yTadOffsets);
	public native void execReduce3Tad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape, Long() tadOnlyShapeInfo, Long() tadOffsets, Long() yTadOnlyShapeInfo, Long() yTadOffsets)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3All(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape, @Cast("const Nd4jLong*") LongPointer xTadShapeInfo, @Cast("const Nd4jLong*") LongPointer xOffsets, @Cast("const Nd4jLong*") LongPointer yTadShapeInfo, @Cast("const Nd4jLong*") LongPointer yOffsets);
	public native void execReduce3All( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongPointer hYShapeInfo, LongPointer dYShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape, LongPointer xTadShapeInfo, LongPointer xOffsets, LongPointer yTadShapeInfo, LongPointer yOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3All(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape, @Cast("const Nd4jLong*") LongBuffer xTadShapeInfo, @Cast("const Nd4jLong*") LongBuffer xOffsets, @Cast("const Nd4jLong*") LongBuffer yTadShapeInfo, @Cast("const Nd4jLong*") LongBuffer yOffsets);
	public native void execReduce3All( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, LongBuffer hYShapeInfo, LongBuffer dYShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape, LongBuffer xTadShapeInfo, LongBuffer xOffsets, LongBuffer yTadShapeInfo, LongBuffer yOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execReduce3All(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] dYShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape, @Cast("const Nd4jLong*") long[] xTadShapeInfo, @Cast("const Nd4jLong*") long[] xOffsets, @Cast("const Nd4jLong*") long[] yTadShapeInfo, @Cast("const Nd4jLong*") long[] yOffsets);
	public native void execReduce3All( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParamsVals, OpaqueDataBuffer dbY, Long() hYShapeInfo, Long() dYShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape, Long() xTadShapeInfo, Long() xOffsets, Long() yTadShapeInfo, Long() yOffsets)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
	''' <param name="scalar"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="n"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") LongPointer hSscalarShapeInfo, @Cast("const Nd4jLong*") LongPointer dSscalarShapeInfo, Pointer extraParams);
	public native void execScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbScalar, LongPointer hSscalarShapeInfo, LongPointer dSscalarShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") LongBuffer hSscalarShapeInfo, @Cast("const Nd4jLong*") LongBuffer dSscalarShapeInfo, Pointer extraParams);
	public native void execScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalar, LongBuffer hSscalarShapeInfo, LongBuffer dSscalarShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") long[] hSscalarShapeInfo, @Cast("const Nd4jLong*") long[] dSscalarShapeInfo, Pointer extraParams);
	public native void execScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbScalar, Long() hSscalarShapeInfo, Long() dSscalarShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") LongPointer hSscalarShapeInfo, @Cast("const Nd4jLong*") LongPointer dSscalarShapeInfo, Pointer extraParams);
	public native void execScalarBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbScalar, LongPointer hSscalarShapeInfo, LongPointer dSscalarShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") LongBuffer hSscalarShapeInfo, @Cast("const Nd4jLong*") LongBuffer dSscalarShapeInfo, Pointer extraParams);
	public native void execScalarBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalar, LongBuffer hSscalarShapeInfo, LongBuffer dSscalarShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbScalar, @Cast("const Nd4jLong*") long[] hSscalarShapeInfo, @Cast("const Nd4jLong*") long[] dSscalarShapeInfo, Pointer extraParams);
	public native void execScalarBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbScalar, Long() hSscalarShapeInfo, Long() dSscalarShapeInfo, Pointer extraParams)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStatsScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Boolean biasCorrected)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStatsScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Boolean biasCorrected)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsScalar(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStatsScalar( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Boolean biasCorrected)
	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStats(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStats( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Boolean biasCorrected)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStats(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStats( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Boolean biasCorrected)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStats(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, @Cast("bool") boolean biasCorrected);
	public native void execSummaryStats( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Boolean biasCorrected)
	''' 
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfoBuffer"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape, @Cast("bool") boolean biasCorrected, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets);
	public native void execSummaryStatsTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape, Boolean biasCorrected, LongPointer tadShapeInfo, LongPointer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape, @Cast("bool") boolean biasCorrected, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets);
	public native void execSummaryStatsTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape, Boolean biasCorrected, LongBuffer tadShapeInfo, LongBuffer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execSummaryStatsTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape, @Cast("bool") boolean biasCorrected, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets);
	public native void execSummaryStatsTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, Pointer extraParams, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape, Boolean biasCorrected, Long() tadShapeInfo, Long() tadOffsets)

	''' 
	''' <param name="opNum"> </param>
	''' <param name="dx"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="result"> </param>
	''' <param name="resultShapeInfo"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="n"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execTransformFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execTransformFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformFloat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execTransformFloat( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execTransformSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execTransformSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformSame(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execTransformSame( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformBool(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execTransformBool( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformAny(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execTransformAny( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformAny(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execTransformAny( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformAny(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execTransformAny( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformStrict(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, Pointer extraParams);
	public native void execTransformStrict( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformStrict(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, Pointer extraParams);
	public native void execTransformStrict( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, Pointer extraParams)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execTransformStrict(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, Pointer extraParams);
	public native void execTransformStrict( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, Pointer extraParams)

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="opNum"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="z"> </param>
	''' <param name="zShapeInfo"> </param>
	''' <param name="scalars"> </param>
	''' <param name="extraParams"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") LongPointer hScalarShapeInfo, @Cast("const Nd4jLong*") LongPointer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets, @Cast("const Nd4jLong*") LongPointer tadShapeInfoZ, @Cast("const Nd4jLong*") LongPointer tadOffsetsZ);
	public native void execScalarTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbScalars, LongPointer hScalarShapeInfo, LongPointer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape, LongPointer tadShapeInfo, LongPointer tadOffsets, LongPointer tadShapeInfoZ, LongPointer tadOffsetsZ)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") LongBuffer hScalarShapeInfo, @Cast("const Nd4jLong*") LongBuffer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets, @Cast("const Nd4jLong*") LongBuffer tadShapeInfoZ, @Cast("const Nd4jLong*") LongBuffer tadOffsetsZ);
	public native void execScalarTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalars, LongBuffer hScalarShapeInfo, LongBuffer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape, LongBuffer tadShapeInfo, LongBuffer tadOffsets, LongBuffer tadShapeInfoZ, LongBuffer tadOffsetsZ)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") long[] hScalarShapeInfo, @Cast("const Nd4jLong*") long[] dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets, @Cast("const Nd4jLong*") long[] tadShapeInfoZ, @Cast("const Nd4jLong*") long[] tadOffsetsZ);
	public native void execScalarTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbScalars, Long() hScalarShapeInfo, Long() dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape, Long() tadShapeInfo, Long() tadOffsets, Long() tadShapeInfoZ, Long() tadOffsetsZ)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBoolTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeInfo, @Cast("const Nd4jLong*") LongPointer dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") LongPointer hScalarShapeInfo, @Cast("const Nd4jLong*") LongPointer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongPointer hDimensionShape, @Cast("const Nd4jLong*") LongPointer dDimensionShape, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets, @Cast("const Nd4jLong*") LongPointer tadShapeInfoZ, @Cast("const Nd4jLong*") LongPointer tadOffsetsZ);
	public native void execScalarBoolTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongPointer hXShapeInfo, LongPointer dXShapeInfo, OpaqueDataBuffer dbZ, LongPointer hZShapeInfo, LongPointer dZShapeInfo, OpaqueDataBuffer dbScalars, LongPointer hScalarShapeInfo, LongPointer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongPointer hDimensionShape, LongPointer dDimensionShape, LongPointer tadShapeInfo, LongPointer tadOffsets, LongPointer tadShapeInfoZ, LongPointer tadOffsetsZ)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBoolTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeInfo, @Cast("const Nd4jLong*") LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") LongBuffer hScalarShapeInfo, @Cast("const Nd4jLong*") LongBuffer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") LongBuffer hDimensionShape, @Cast("const Nd4jLong*") LongBuffer dDimensionShape, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets, @Cast("const Nd4jLong*") LongBuffer tadShapeInfoZ, @Cast("const Nd4jLong*") LongBuffer tadOffsetsZ);
	public native void execScalarBoolTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, LongBuffer hXShapeInfo, LongBuffer dXShapeInfo, OpaqueDataBuffer dbZ, LongBuffer hZShapeInfo, LongBuffer dZShapeInfo, OpaqueDataBuffer dbScalars, LongBuffer hScalarShapeInfo, LongBuffer dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, LongBuffer hDimensionShape, LongBuffer dDimensionShape, LongBuffer tadShapeInfo, LongBuffer tadOffsets, LongBuffer tadShapeInfoZ, LongBuffer tadOffsetsZ)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execScalarBoolTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] dXShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeInfo, @Cast("const Nd4jLong*") long[] dZShapeInfo, OpaqueDataBuffer dbScalars, @Cast("const Nd4jLong*") long[] hScalarShapeInfo, @Cast("const Nd4jLong*") long[] dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, @Cast("const Nd4jLong*") long[] hDimensionShape, @Cast("const Nd4jLong*") long[] dDimensionShape, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets, @Cast("const Nd4jLong*") long[] tadShapeInfoZ, @Cast("const Nd4jLong*") long[] tadOffsetsZ);
	public native void execScalarBoolTad( PointerPointer extraPointers, Integer opNum, OpaqueDataBuffer dbX, Long() hXShapeInfo, Long() dXShapeInfo, OpaqueDataBuffer dbZ, Long() hZShapeInfo, Long() dZShapeInfo, OpaqueDataBuffer dbScalars, Long() hScalarShapeInfo, Long() dScalarShapeInfo, Pointer extraParams, OpaqueDataBuffer dbDimension, Long() hDimensionShape, Long() dDimensionShape, Long() tadShapeInfo, Long() tadOffsets, Long() tadShapeInfoZ, Long() tadOffsetsZ)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void specialConcat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int dimension, int numArrays, @Cast("Nd4jPointer*") PointerPointer data, @Cast("Nd4jPointer*") PointerPointer inputShapeInfo, Pointer result, @Cast("const Nd4jLong*") LongPointer resultShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadPointers, @Cast("Nd4jPointer*") PointerPointer offsetPointers);
	public native void specialConcat( PointerPointer extraPointers, Integer dimension, Integer numArrays, PointerPointer data, PointerPointer inputShapeInfo, Pointer result, LongPointer resultShapeInfo, PointerPointer tadPointers, PointerPointer offsetPointers)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void specialConcat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int dimension, int numArrays, @Cast("Nd4jPointer*") PointerPointer data, @Cast("Nd4jPointer*") PointerPointer inputShapeInfo, Pointer result, @Cast("const Nd4jLong*") LongBuffer resultShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadPointers, @Cast("Nd4jPointer*") PointerPointer offsetPointers);
	public native void specialConcat( PointerPointer extraPointers, Integer dimension, Integer numArrays, PointerPointer data, PointerPointer inputShapeInfo, Pointer result, LongBuffer resultShapeInfo, PointerPointer tadPointers, PointerPointer offsetPointers)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void specialConcat(@Cast("Nd4jPointer*") PointerPointer extraPointers, int dimension, int numArrays, @Cast("Nd4jPointer*") PointerPointer data, @Cast("Nd4jPointer*") PointerPointer inputShapeInfo, Pointer result, @Cast("const Nd4jLong*") long[] resultShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadPointers, @Cast("Nd4jPointer*") PointerPointer offsetPointers);
	public native void specialConcat( PointerPointer extraPointers, Integer dimension, Integer numArrays, PointerPointer data, PointerPointer inputShapeInfo, Pointer result, Long() resultShapeInfo, PointerPointer tadPointers, PointerPointer offsetPointers)

	''' <summary>
	''' This method implementation exists only for cuda.
	''' The other backends should have dummy method for JNI compatibility reasons.
	''' </summary>
	public native void initializeDevicesAndFunctions()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void initializeFunctions(@Cast("Nd4jPointer*") PointerPointer functions);
	public native void initializeFunctions( PointerPointer functions)

	''' <summary>
	''' This method acquires memory chunk of requested size on host side
	''' </summary>
	''' <param name="pointer"> pointer that'll be used for allocation </param>
	''' <param name="memorySize"> memory size, in bytes </param>
	''' <param name="flags"> optional parameter </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer mallocHost(@Cast("Nd4jLong") long memorySize, int flags);
	public native Pointer mallocHost( Long memorySize, Integer flags)

	''' <summary>
	''' This method acquires memory chunk of requested size on specified device
	''' </summary>
	''' <param name="pointer"> pointer that'll be used for allocation </param>
	''' <param name="memorySize"> memory size, in bytes </param>
	''' <param name="ptrToDeviceId"> pointer to deviceId. For cuda that's just and int, for OpenCL that's pointer to device_id, etc </param>
	''' <param name="flags"> optional parameter </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer mallocDevice(@Cast("Nd4jLong") long memorySize, int deviceId, int flags);
	public native Pointer mallocDevice( Long memorySize, Integer deviceId, Integer flags)

	''' <summary>
	''' This method releases previously allocated host memory space
	''' </summary>
	''' <param name="pointer"> pointer that'll be freed </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int freeHost(@Cast("Nd4jPointer") Pointer pointer);
	public native Integer freeHost( Pointer pointer)

	''' <summary>
	''' This method releases previously allocated memory space on device
	''' </summary>
	''' <param name="pointer"> pointer that'll be freed </param>
	''' <param name="ptrToDeviceId"> pointer to deviceId. </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int freeDevice(@Cast("Nd4jPointer") Pointer pointer, int deviceId);
	public native Integer freeDevice( Pointer pointer, Integer deviceId)

	''' 
	''' <summary>
	''' @return
	''' </summary>
	public native Integer ompGetMaxThreads()

	''' 
	''' <summary>
	''' @return
	''' </summary>
	public native Integer ompGetNumThreads()

	''' 
	''' <param name="threads"> </param>
	public native void setOmpNumThreads(Integer threads)

	''' 
	''' <param name="threads"> </param>
	public native void setOmpMinThreads(Integer threads)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isBlasVersionMatches(int major, int minor, int build);
	public native Boolean isBlasVersionMatches(Integer major, Integer minor, Integer build)

	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer createContext();
	public native Pointer createContext()

	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer createStream();
	public native Pointer createStream()

	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer createEvent();
	public native Pointer createEvent()

	''' 
	''' <param name="event"> </param>
	''' <param name="stream">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int registerEvent(@Cast("Nd4jPointer") Pointer event, @Cast("Nd4jPointer") Pointer stream);
	public native Integer registerEvent( Pointer [event], Pointer stream)

	''' 
	''' <param name="event">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int destroyEvent(@Cast("Nd4jPointer") Pointer event);
	public native Integer destroyEvent( Pointer [event])

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
	public native Integer setDevice(Integer deviceId)

	''' 
	''' <summary>
	''' @return
	''' </summary>
	public native Integer getDevice()

	''' 
	''' <param name="stream">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int streamSynchronize(@Cast("Nd4jPointer") Pointer stream);
	public native Integer streamSynchronize( Pointer stream)

	''' 
	''' <param name="event">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int eventSynchronize(@Cast("Nd4jPointer") Pointer event);
	public native Integer eventSynchronize( Pointer [event])

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getDeviceFreeMemory(int deviceId);
	public native Long getDeviceFreeMemory(Integer deviceId)

	''' <summary>
	''' Returns amount of free memory for current device
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getDeviceFreeMemoryDefault();
	public native Long getDeviceFreeMemoryDefault()

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getDeviceTotalMemory(int deviceId);
	public native Long getDeviceTotalMemory(Integer deviceId)

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
	public native Integer getDeviceMajor(Integer deviceId)

	''' <summary>
	''' This method returns amount of cached memory </summary>
	''' <param name="deviceId">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getCachedMemory(int deviceId);
	public native Long getCachedMemory(Integer deviceId)

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
	public native Integer getDeviceMinor(Integer deviceId)

	''' 
	''' <param name="ptrToDeviceId">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getDeviceName(int deviceId);
	public native String getDeviceName(Integer deviceId)

	''' 
	''' <param name="dst"> </param>
	''' <param name="src"> </param>
	''' <param name="size"> </param>
	''' <param name="flags"> </param>
	''' <param name="reserved">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int memcpySync(@Cast("Nd4jPointer") Pointer dst, @Cast("Nd4jPointer") Pointer src, @Cast("Nd4jLong") long size, int flags, @Cast("Nd4jPointer") Pointer reserved);
	public native Integer memcpySync( Pointer dst, Pointer src, Long size, Integer flags, Pointer reserved)

	''' 
	''' <param name="dst"> </param>
	''' <param name="src"> </param>
	''' <param name="size"> </param>
	''' <param name="flags"> </param>
	''' <param name="reserved">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int memcpyAsync(@Cast("Nd4jPointer") Pointer dst, @Cast("Nd4jPointer") Pointer src, @Cast("Nd4jLong") long size, int flags, @Cast("Nd4jPointer") Pointer reserved);
	public native Integer memcpyAsync( Pointer dst, Pointer src, Long size, Integer flags, Pointer reserved)

	''' 
	''' <param name="dst"> </param>
	''' <param name="value"> </param>
	''' <param name="size"> </param>
	''' <param name="flags"> </param>
	''' <param name="reserved">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int memsetSync(@Cast("Nd4jPointer") Pointer dst, int value, @Cast("Nd4jLong") long size, int flags, @Cast("Nd4jPointer") Pointer reserved);
	public native Integer memsetSync( Pointer dst, Integer value, Long size, Integer flags, Pointer reserved)

	''' 
	''' <param name="dst"> </param>
	''' <param name="value"> </param>
	''' <param name="size"> </param>
	''' <param name="flags"> </param>
	''' <param name="reserved">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int memsetAsync(@Cast("Nd4jPointer") Pointer dst, int value, @Cast("Nd4jLong") long size, int flags, @Cast("Nd4jPointer") Pointer reserved);
	public native Integer memsetAsync( Pointer dst, Integer value, Long size, Integer flags, Pointer reserved)

	''' 
	''' <param name="dst"> </param>
	''' <param name="src"> </param>
	''' <param name="size"> </param>
	''' <param name="flags"> </param>
	''' <param name="reserved">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int memcpyConstantAsync(@Cast("Nd4jLong") long dst, @Cast("Nd4jPointer") Pointer src, @Cast("Nd4jLong") long size, int flags, @Cast("Nd4jPointer") Pointer reserved);
	public native Integer memcpyConstantAsync( Long dst, Pointer src, Long size, Integer flags, Pointer reserved)

	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getConstantSpace();
	public native Pointer getConstantSpace()

	''' 
	''' <summary>
	''' @return
	''' </summary>
	public native Integer getAvailableDevices()

	''' 
	''' <param name="reallyEnable"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void enableDebugMode(@Cast("bool") boolean reallyEnable);
	public native void enableDebugMode( Boolean reallyEnable)

	''' 
	''' <param name="reallyEnable"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void enableVerboseMode(@Cast("bool") boolean reallyEnable);
	public native void enableVerboseMode( Boolean reallyEnable)

	''' 
	''' <param name="gridSize"> </param>
	public native void setGridLimit(Integer gridSize)

	''' 
	''' <param name="xShapeInfo"> </param>
	''' <param name="dimension"> </param>
	''' <param name="dimensionLength"> </param>
	''' <param name="targetBuffer"> </param>
	''' <param name="offsetsBuffer"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueTadPack tadOnlyShapeInfo(@Cast("const Nd4jLong*") LongPointer xShapeInfo, IntPointer dimension, int dimensionLength);
	public native OpaqueTadPack tadOnlyShapeInfo( LongPointer xShapeInfo, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueTadPack tadOnlyShapeInfo(@Cast("const Nd4jLong*") LongBuffer xShapeInfo, IntBuffer dimension, int dimensionLength);
	public native OpaqueTadPack tadOnlyShapeInfo( LongBuffer xShapeInfo, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueTadPack tadOnlyShapeInfo(@Cast("const Nd4jLong*") long[] xShapeInfo, int[] dimension, int dimensionLength);
	public native OpaqueTadPack tadOnlyShapeInfo( Long() xShapeInfo, Integer() dimension, Integer dimensionLength)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getPrimaryShapeInfo(OpaqueTadPack pack);
	public native LongPointer getPrimaryShapeInfo(OpaqueTadPack pack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getPrimaryOffsets(OpaqueTadPack pack);
	public native LongPointer getPrimaryOffsets(OpaqueTadPack pack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getSpecialShapeInfo(OpaqueTadPack pack);
	public native LongPointer getSpecialShapeInfo(OpaqueTadPack pack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getSpecialOffsets(OpaqueTadPack pack);
	public native LongPointer getSpecialOffsets(OpaqueTadPack pack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getNumberOfTads(OpaqueTadPack pack);
	public native Long getNumberOfTads(OpaqueTadPack pack)
	public native Integer getShapeInfoLength(OpaqueTadPack pack)

	public native void deleteTadPack(OpaqueTadPack ptr)

	'
	' * PullRow special op
	' 

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="z"> </param>
	''' <param name="zShapeInfo"> </param>
	''' <param name="n"> </param>
	''' <param name="indexes"> </param>
	''' <param name="tadShapeInfo"> </param>
	''' <param name="tadOffsets"> </param>
	''' <param name="zTadShapeInfo"> </param>
	''' <param name="zTadOffsets"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pullRows(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer xShapeInfo, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer zShapeInfo, @Cast("const Nd4jLong*") LongPointer dzShapeInfo, @Cast("Nd4jLong") long n, @Cast("Nd4jLong*") LongPointer indexes, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets, @Cast("const Nd4jLong*") LongPointer zTadShapeInfo, @Cast("const Nd4jLong*") LongPointer zTadOffsets);
	public native void pullRows( PointerPointer extraPointers, OpaqueDataBuffer dbX, LongPointer xShapeInfo, LongPointer dxShapeInfo, OpaqueDataBuffer dbZ, LongPointer zShapeInfo, LongPointer dzShapeInfo, Long n, LongPointer indexes, LongPointer tadShapeInfo, LongPointer tadOffsets, LongPointer zTadShapeInfo, LongPointer zTadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pullRows(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer zShapeInfo, @Cast("const Nd4jLong*") LongBuffer dzShapeInfo, @Cast("Nd4jLong") long n, @Cast("Nd4jLong*") LongBuffer indexes, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets, @Cast("const Nd4jLong*") LongBuffer zTadShapeInfo, @Cast("const Nd4jLong*") LongBuffer zTadOffsets);
	public native void pullRows( PointerPointer extraPointers, OpaqueDataBuffer dbX, LongBuffer xShapeInfo, LongBuffer dxShapeInfo, OpaqueDataBuffer dbZ, LongBuffer zShapeInfo, LongBuffer dzShapeInfo, Long n, LongBuffer indexes, LongBuffer tadShapeInfo, LongBuffer tadOffsets, LongBuffer zTadShapeInfo, LongBuffer zTadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pullRows(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] xShapeInfo, @Cast("const Nd4jLong*") long[] dxShapeInfo, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] zShapeInfo, @Cast("const Nd4jLong*") long[] dzShapeInfo, @Cast("Nd4jLong") long n, @Cast("Nd4jLong*") long[] indexes, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets, @Cast("const Nd4jLong*") long[] zTadShapeInfo, @Cast("const Nd4jLong*") long[] zTadOffsets);
	public native void pullRows( PointerPointer extraPointers, OpaqueDataBuffer dbX, Long() xShapeInfo, Long() dxShapeInfo, OpaqueDataBuffer dbZ, Long() zShapeInfo, Long() dzShapeInfo, Long n, Long() indexes, Long() tadShapeInfo, Long() tadOffsets, Long() zTadShapeInfo, Long() zTadOffsets)

	''' 
	''' <param name="extras"> </param>
	''' <param name="dx"> </param>
	''' <param name="dz"> </param>
	''' <param name="n"> </param>
	''' <param name="length"> </param>
	''' <param name="propagate"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void average(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") LongPointer zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") LongPointer dzShapeInfo, int n, @Cast("Nd4jLong") long length, @Cast("bool") boolean propagate);
	public native void average( PointerPointer extras, PointerPointer x, LongPointer xShapeInfo, PointerPointer dx, LongPointer dxShapeInfo, Pointer z, LongPointer zShapeInfo, Pointer dz, LongPointer dzShapeInfo, Integer n, Long length, Boolean propagate)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void average(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") LongBuffer zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") LongBuffer dzShapeInfo, int n, @Cast("Nd4jLong") long length, @Cast("bool") boolean propagate);
	public native void average( PointerPointer extras, PointerPointer x, LongBuffer xShapeInfo, PointerPointer dx, LongBuffer dxShapeInfo, Pointer z, LongBuffer zShapeInfo, Pointer dz, LongBuffer dzShapeInfo, Integer n, Long length, Boolean propagate)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void average(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") long[] zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") long[] dzShapeInfo, int n, @Cast("Nd4jLong") long length, @Cast("bool") boolean propagate);
	public native void average( PointerPointer extras, PointerPointer x, Long() xShapeInfo, PointerPointer dx, Long() dxShapeInfo, Pointer z, Long() zShapeInfo, Pointer dz, Long() dzShapeInfo, Integer n, Long length, Boolean propagate)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void accumulate(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") LongPointer zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") LongPointer dzShapeInfo, int n, @Cast("Nd4jLong") long length);
	public native void accumulate( PointerPointer extras, PointerPointer x, LongPointer xShapeInfo, PointerPointer dx, LongPointer dxShapeInfo, Pointer z, LongPointer zShapeInfo, Pointer dz, LongPointer dzShapeInfo, Integer n, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void accumulate(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") LongBuffer zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") LongBuffer dzShapeInfo, int n, @Cast("Nd4jLong") long length);
	public native void accumulate( PointerPointer extras, PointerPointer x, LongBuffer xShapeInfo, PointerPointer dx, LongBuffer dxShapeInfo, Pointer z, LongBuffer zShapeInfo, Pointer dz, LongBuffer dzShapeInfo, Integer n, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void accumulate(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer z, @Cast("const Nd4jLong*") long[] zShapeInfo, Pointer dz, @Cast("const Nd4jLong*") long[] dzShapeInfo, int n, @Cast("Nd4jLong") long length);
	public native void accumulate( PointerPointer extras, PointerPointer x, Long() xShapeInfo, PointerPointer dx, Long() dxShapeInfo, Pointer z, Long() zShapeInfo, Pointer dz, Long() dzShapeInfo, Integer n, Long length)


	''' <summary>
	''' P2P enabler
	''' </summary>
	''' 
	''' <param name="enable"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void enableP2P(@Cast("bool") boolean enable);
	public native void enableP2P( Boolean enable)

	''' 
	public native void checkP2P()

	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isP2PAvailable();
	public native Boolean isP2PAvailable()

	''' <summary>
	''' Shuffle methods
	''' </summary>

	''' 
	''' <param name="extras"> </param>
	''' <param name="dx"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="dz"> </param>
	''' <param name="zShapeInfo"> </param>
	''' <param name="N"> </param>
	''' <param name="shuffleMap"> </param>
	''' <param name="tadShapeInfo"> </param>
	''' <param name="tadOffsets"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void shuffle(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("Nd4jPointer*") PointerPointer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("Nd4jPointer*") PointerPointer dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer z, @Cast("Nd4jPointer*") PointerPointer zShapeInfo, @Cast("Nd4jPointer*") PointerPointer dz, @Cast("Nd4jPointer*") PointerPointer dzShapeInfo, int N, IntPointer shuffleMap, @Cast("Nd4jPointer*") PointerPointer tadShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadOffsets);
	public native void shuffle( PointerPointer extras, PointerPointer x, PointerPointer xShapeInfo, PointerPointer dx, PointerPointer dxShapeInfo, PointerPointer z, PointerPointer zShapeInfo, PointerPointer dz, PointerPointer dzShapeInfo, Integer N, IntPointer shuffleMap, PointerPointer tadShapeInfo, PointerPointer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void shuffle(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("Nd4jPointer*") PointerPointer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("Nd4jPointer*") PointerPointer dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer z, @Cast("Nd4jPointer*") PointerPointer zShapeInfo, @Cast("Nd4jPointer*") PointerPointer dz, @Cast("Nd4jPointer*") PointerPointer dzShapeInfo, int N, IntBuffer shuffleMap, @Cast("Nd4jPointer*") PointerPointer tadShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadOffsets);
	public native void shuffle( PointerPointer extras, PointerPointer x, PointerPointer xShapeInfo, PointerPointer dx, PointerPointer dxShapeInfo, PointerPointer z, PointerPointer zShapeInfo, PointerPointer dz, PointerPointer dzShapeInfo, Integer N, IntBuffer shuffleMap, PointerPointer tadShapeInfo, PointerPointer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void shuffle(@Cast("Nd4jPointer*") PointerPointer extras, @Cast("Nd4jPointer*") PointerPointer x, @Cast("Nd4jPointer*") PointerPointer xShapeInfo, @Cast("Nd4jPointer*") PointerPointer dx, @Cast("Nd4jPointer*") PointerPointer dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer z, @Cast("Nd4jPointer*") PointerPointer zShapeInfo, @Cast("Nd4jPointer*") PointerPointer dz, @Cast("Nd4jPointer*") PointerPointer dzShapeInfo, int N, int[] shuffleMap, @Cast("Nd4jPointer*") PointerPointer tadShapeInfo, @Cast("Nd4jPointer*") PointerPointer tadOffsets);
	public native void shuffle( PointerPointer extras, PointerPointer x, PointerPointer xShapeInfo, PointerPointer dx, PointerPointer dxShapeInfo, PointerPointer z, PointerPointer zShapeInfo, PointerPointer dz, PointerPointer dzShapeInfo, Integer N, Integer() shuffleMap, PointerPointer tadShapeInfo, PointerPointer tadOffsets)


	''' <summary>
	''' Type Conversions
	''' </summary>

	''' 
	''' <param name="extras"> </param>
	''' <param name="srcType"> </param>
	''' <param name="x"> </param>
	''' <param name="N"> </param>
	''' <param name="dstType"> </param>
	''' <param name="z"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void convertTypes(@Cast("Nd4jPointer*") PointerPointer extras, int srcType, @Cast("Nd4jPointer") Pointer x, @Cast("Nd4jLong") long N, int dstType, @Cast("Nd4jPointer") Pointer z);
	public native void convertTypes( PointerPointer extras, Integer srcType, Pointer x, Long N, Integer dstType, Pointer z)


	''' 
	''' <summary>
	''' @return
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isExperimentalEnabled();
	public native Boolean isExperimentalEnabled()

	''' <summary>
	''' Aggregate
	''' </summary>

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="opNum"> </param>
	''' <param name="arguments"> </param>
	''' <param name="numArguments"> </param>
	''' <param name="shapeArguments"> </param>
	''' <param name="numShapeArguments"> </param>
	''' <param name="indexArguments"> </param>
	''' <param name="numIndexArguments"> </param>
	''' <param name="intArrays"> </param>
	''' <param name="numIntArrays"> </param>
	''' <param name="realArguments"> </param>
	''' <param name="numRealArguments"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execAggregate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("void**") PointerPointer arguments, int numArguments, @Cast("Nd4jLong**") PointerPointer shapeArguments, int numShapeArguments, IntPointer indexArguments, int numIndexArguments, @Cast("int**") PointerPointer intArrays, int numIntArrays, Pointer realArguments, int numRealArguments, @Cast("sd::DataType") int dtype);
	public native void execAggregate( PointerPointer extraPointers, Integer opNum, PointerPointer arguments, Integer numArguments, PointerPointer shapeArguments, Integer numShapeArguments, IntPointer indexArguments, Integer numIndexArguments, PointerPointer intArrays, Integer numIntArrays, Pointer realArguments, Integer numRealArguments, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execAggregate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("void**") @ByPtrPtr Pointer arguments, int numArguments, @Cast("Nd4jLong**") @ByPtrPtr LongPointer shapeArguments, int numShapeArguments, IntPointer indexArguments, int numIndexArguments, @ByPtrPtr IntPointer intArrays, int numIntArrays, Pointer realArguments, int numRealArguments, @Cast("sd::DataType") int dtype);
	public native void execAggregate( PointerPointer extraPointers, Integer opNum, @ByPtrPtr Pointer arguments, Integer numArguments, @ByPtrPtr LongPointer shapeArguments, Integer numShapeArguments, IntPointer indexArguments, Integer numIndexArguments, IntPointer intArrays, Integer numIntArrays, Pointer realArguments, Integer numRealArguments, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execAggregate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("void**") @ByPtrPtr Pointer arguments, int numArguments, @Cast("Nd4jLong**") @ByPtrPtr LongBuffer shapeArguments, int numShapeArguments, IntBuffer indexArguments, int numIndexArguments, @ByPtrPtr IntBuffer intArrays, int numIntArrays, Pointer realArguments, int numRealArguments, @Cast("sd::DataType") int dtype);
	public native void execAggregate( PointerPointer extraPointers, Integer opNum, @ByPtrPtr Pointer arguments, Integer numArguments, @ByPtrPtr LongBuffer shapeArguments, Integer numShapeArguments, IntBuffer indexArguments, Integer numIndexArguments, IntBuffer intArrays, Integer numIntArrays, Pointer realArguments, Integer numRealArguments, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execAggregate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("void**") @ByPtrPtr Pointer arguments, int numArguments, @Cast("Nd4jLong**") @ByPtrPtr long[] shapeArguments, int numShapeArguments, int[] indexArguments, int numIndexArguments, @ByPtrPtr int[] intArrays, int numIntArrays, Pointer realArguments, int numRealArguments, @Cast("sd::DataType") int dtype);
	public native void execAggregate( PointerPointer extraPointers, Integer opNum, @ByPtrPtr Pointer arguments, Integer numArguments, @ByPtrPtr Long() shapeArguments, Integer numShapeArguments, Integer() indexArguments, Integer numIndexArguments, Integer() intArrays, Integer numIntArrays, Pointer realArguments, Integer numRealArguments, Integer dtype)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void batchExecutor(@Cast("Nd4jPointer*") PointerPointer extraPointers, int numAggregates, int opNum, int maxArgs, int maxShapes, int maxIntArrays, int maxIntArraySize, int maxIdx, int maxReals, Pointer ptrToArguments, @Cast("sd::DataType") int dtype);
	public native void batchExecutor( PointerPointer extraPointers, Integer numAggregates, Integer opNum, Integer maxArgs, Integer maxShapes, Integer maxIntArrays, Integer maxIntArraySize, Integer maxIdx, Integer maxReals, Pointer ptrToArguments, Integer dtype)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execAggregateBatch(@Cast("Nd4jPointer*") PointerPointer extraPointers, int numAggregates, int opNum, int maxArgs, int maxShapes, int maxIntArrays, int maxIntArraySize, int maxIdx, int maxReals, Pointer ptrToArguments, @Cast("sd::DataType") int dtype);
	public native void execAggregateBatch( PointerPointer extraPointers, Integer numAggregates, Integer opNum, Integer maxArgs, Integer maxShapes, Integer maxIntArrays, Integer maxIntArraySize, Integer maxIdx, Integer maxReals, Pointer ptrToArguments, Integer dtype)

	''' <summary>
	''' Random operations
	''' </summary>

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="opNum"> </param>
	''' <param name="state"> </param>
	''' <param name="z"> </param>
	''' <param name="zShapeBuffer"> </param>
	''' <param name="extraArguments"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeBuffer, @Cast("const Nd4jLong*") LongPointer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbZ, LongPointer hZShapeBuffer, LongPointer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbZ, LongBuffer hZShapeBuffer, LongBuffer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeBuffer, @Cast("const Nd4jLong*") long[] dZShapeBuffer, Pointer extraArguments);
	public native void execRandom( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbZ, Long() hZShapeBuffer, Long() dZShapeBuffer, Pointer extraArguments)

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="opNum"> </param>
	''' <param name="state"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeBuffer"> </param>
	''' <param name="y"> </param>
	''' <param name="yShapeBuffer"> </param>
	''' <param name="z"> </param>
	''' <param name="zShapeBuffer"> </param>
	''' <param name="extraArguments"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeBuffer, @Cast("const Nd4jLong*") LongPointer dXShapeBuffer, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongPointer hYShapeBuffer, @Cast("const Nd4jLong*") LongPointer dYShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeBuffer, @Cast("const Nd4jLong*") LongPointer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom3( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, LongPointer hXShapeBuffer, LongPointer dXShapeBuffer, OpaqueDataBuffer dbY, LongPointer hYShapeBuffer, LongPointer dYShapeBuffer, OpaqueDataBuffer dbZ, LongPointer hZShapeBuffer, LongPointer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dXShapeBuffer, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") LongBuffer hYShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dYShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom3( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, LongBuffer hXShapeBuffer, LongBuffer dXShapeBuffer, OpaqueDataBuffer dbY, LongBuffer hYShapeBuffer, LongBuffer dYShapeBuffer, OpaqueDataBuffer dbZ, LongBuffer hZShapeBuffer, LongBuffer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom3(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeBuffer, @Cast("const Nd4jLong*") long[] dXShapeBuffer, OpaqueDataBuffer dbY, @Cast("const Nd4jLong*") long[] hYShapeBuffer, @Cast("const Nd4jLong*") long[] dYShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeBuffer, @Cast("const Nd4jLong*") long[] dZShapeBuffer, Pointer extraArguments);
	public native void execRandom3( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, Long() hXShapeBuffer, Long() dXShapeBuffer, OpaqueDataBuffer dbY, Long() hYShapeBuffer, Long() dYShapeBuffer, OpaqueDataBuffer dbZ, Long() hZShapeBuffer, Long() dZShapeBuffer, Pointer extraArguments)

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="opNum"> </param>
	''' <param name="state"> </param>
	''' <param name="x"> </param>
	''' <param name="xShapeBuffer"> </param>
	''' <param name="z"> </param>
	''' <param name="zShapeBuffer"> </param>
	''' <param name="extraArguments"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer hXShapeBuffer, @Cast("const Nd4jLong*") LongPointer dXShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongPointer hZShapeBuffer, @Cast("const Nd4jLong*") LongPointer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom2( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, LongPointer hXShapeBuffer, LongPointer dXShapeBuffer, OpaqueDataBuffer dbZ, LongPointer hZShapeBuffer, LongPointer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer hXShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dXShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") LongBuffer hZShapeBuffer, @Cast("const Nd4jLong*") LongBuffer dZShapeBuffer, Pointer extraArguments);
	public native void execRandom2( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, LongBuffer hXShapeBuffer, LongBuffer dXShapeBuffer, OpaqueDataBuffer dbZ, LongBuffer hZShapeBuffer, LongBuffer dZShapeBuffer, Pointer extraArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void execRandom2(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opNum, @Cast("Nd4jPointer") Pointer state, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] hXShapeBuffer, @Cast("const Nd4jLong*") long[] dXShapeBuffer, OpaqueDataBuffer dbZ, @Cast("const Nd4jLong*") long[] hZShapeBuffer, @Cast("const Nd4jLong*") long[] dZShapeBuffer, Pointer extraArguments);
	public native void execRandom2( PointerPointer extraPointers, Integer opNum, Pointer state, OpaqueDataBuffer dbX, Long() hXShapeBuffer, Long() dXShapeBuffer, OpaqueDataBuffer dbZ, Long() hZShapeBuffer, Long() dZShapeBuffer, Pointer extraArguments)


	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="seed"> </param>
	''' <param name="bufferSize"> </param>
	''' <param name="ptrToBuffer">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer initRandom(@Cast("Nd4jPointer*") PointerPointer extraPointers, long seed, long bufferSize, @Cast("Nd4jPointer") Pointer ptrToBuffer);
	public native Pointer initRandom( PointerPointer extraPointers, Long seed, Long bufferSize, Pointer ptrToBuffer)

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="seed"> </param>
	''' <param name="ptrRandom"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void refreshBuffer(@Cast("Nd4jPointer*") PointerPointer extraPointers, long seed, @Cast("Nd4jPointer") Pointer ptrRandom);
	public native void refreshBuffer( PointerPointer extraPointers, Long seed, Pointer ptrRandom)

	''' 
	''' <param name="extraPointers"> </param>
	''' <param name="seed"> </param>
	''' <param name="ptrRandom"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void reSeedBuffer(@Cast("Nd4jPointer*") PointerPointer extraPointers, long seed, @Cast("Nd4jPointer") Pointer ptrRandom);
	public native void reSeedBuffer( PointerPointer extraPointers, Long seed, Pointer ptrRandom)

	''' 
	''' <param name="ptrRandom"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void destroyRandom(@Cast("Nd4jPointer") Pointer ptrRandom);
	public native void destroyRandom( Pointer ptrRandom)

	''' 
	''' <param name="data"> </param>
	''' <param name="shapeBuffer"> </param>
	''' <param name="wordSize"> </param>
	''' <param name="headerSize">
	''' @return </param>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyHeaderForNd4j(@Cast("Nd4jPointer") Pointer data,@Cast("Nd4jPointer") Pointer shapeBuffer,@Cast("Nd4jLong") long wordSize,@Cast("Nd4jLong*") LongPointer headerSize);
	public native Pointer numpyHeaderForNd4j( Pointer data, Pointer shapeBuffer, Long wordSize, LongPointer headerSize)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyHeaderForNd4j(@Cast("Nd4jPointer") Pointer data,@Cast("Nd4jPointer") Pointer shapeBuffer,@Cast("Nd4jLong") long wordSize,@Cast("Nd4jLong*") LongBuffer headerSize);
	public native Pointer numpyHeaderForNd4j( Pointer data, Pointer shapeBuffer, Long wordSize, LongBuffer headerSize)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyHeaderForNd4j(@Cast("Nd4jPointer") Pointer data,@Cast("Nd4jPointer") Pointer shapeBuffer,@Cast("Nd4jLong") long wordSize,@Cast("Nd4jLong*") long[] headerSize);
	public native Pointer numpyHeaderForNd4j( Pointer data, Pointer shapeBuffer, Long wordSize, Long() headerSize)

	''' <summary>
	''' Load numpy from a header
	''' based on the cnpy parse from header method. </summary>
	''' <param name="data"> the header data to parse </param>
	''' <returns> a pointer to a numpy cnpy:NpyArray struct </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer loadNpyFromHeader(@Cast("Nd4jPointer") Pointer data);
	public native Pointer loadNpyFromHeader( Pointer data)

	''' <summary>
	''' Create a numpy array from an nd4j
	''' array </summary>
	''' <param name="data"> a pointer to the data </param>
	''' <param name="shapeBuffer">  the shapebuffer for the nd4j array </param>
	''' <param name="wordSize">  the word size (4 for float, 8 for doubles) </param>
	''' <returns> a pointer to a numpy array </returns>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyFromNd4j(@Cast("Nd4jPointer") Pointer data,@Cast("Nd4jPointer") Pointer shapeBuffer,@Cast("Nd4jLong") long wordSize);
	public native Pointer numpyFromNd4j( Pointer data, Pointer shapeBuffer, Long wordSize)


	''' 
	''' <param name="npyArray">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer shapeBufferForNumpy(@Cast("Nd4jPointer") Pointer npyArray);
	public native Pointer shapeBufferForNumpy( Pointer npyArray)


	''' <summary>
	''' Get the shape buffer from a
	''' numpy array.
	''' **Warning** this allocates memory </summary>
	''' <param name="npyArray">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer shapeBufferForNumpyHeader(@Cast("Nd4jPointer") Pointer npyArray);
	public native Pointer shapeBufferForNumpyHeader( Pointer npyArray)



	''' 
	''' <param name="npyArray">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer dataPointForNumpyHeader(@Cast("Nd4jPointer") Pointer npyArray);
	public native Pointer dataPointForNumpyHeader( Pointer npyArray)

	''' 
	''' <param name="npyArray">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer dataPointForNumpyStruct(@Cast("Nd4jPointer") Pointer npyArrayStruct);
	public native Pointer dataPointForNumpyStruct( Pointer npyArrayStruct)

	''' 
	''' <param name="npyArray"> </param>
	''' <param name="fromFile">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer dataPointForNumpy(@Cast("Nd4jPointer") Pointer npyArray);
	public native Pointer dataPointForNumpy( Pointer npyArray)

	''' <summary>
	''' Load a numpy array from a file
	''' and return it as an Nd4jPointer </summary>
	''' <param name="path">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyFromFile(@StdString BytePointer path);
	public native Pointer numpyFromFile( BytePointer path)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer numpyFromFile(@StdString String path);
	public native Pointer numpyFromFile( String path)


	'//// NPZ //////

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer mapFromNpzFile(@StdString BytePointer path);
	public native Pointer mapFromNpzFile( BytePointer path)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer mapFromNpzFile(@StdString String path);
	public native Pointer mapFromNpzFile( String path)


	public native Integer getNumNpyArraysInMap(Pointer map)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getNpyArrayNameFromMap(Pointer map, int index,@Cast("char*") BytePointer nameBuffer);
	public native String getNpyArrayNameFromMap(Pointer map, Integer index, BytePointer nameBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") BytePointer getNpyArrayNameFromMap(Pointer map, int index,@Cast("char*") String nameBuffer);
	public native BytePointer getNpyArrayNameFromMap(Pointer map, Integer index, String nameBuffer)

	public native Pointer getNpyArrayFromMap(Pointer map, Integer index)

	public native Integer dataTypeFromNpyHeader(Pointer header)

	public native Pointer getNpyArrayData(Pointer npArray)

	public native Integer getNpyArrayRank(Pointer npArray)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer getNpyArrayShape(Pointer npArray);
	public native LongPointer getNpyArrayShape(Pointer npArray)

	public native Char getNpyArrayOrder(Pointer npArray)

	public native Integer getNpyArrayElemSize(Pointer npArray)

	public native void deleteNPArrayStruct(Pointer npArray)

	public native void deleteNPArrayMap(Pointer map)
	'////

	''' <summary>
	''' Get the element size for a numpy array </summary>
	''' <param name="npyArray">  the numpy array's address
	''' to get the length for
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int elementSizeForNpyArray(@Cast("Nd4jPointer") Pointer npyArray);
	public native Integer elementSizeForNpyArray( Pointer npyArray)


	''' <summary>
	''' Get the element size for a numpy array </summary>
	''' <param name="npyArray">  the numpy array's address
	''' to get the length for
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int elementSizeForNpyArrayHeader(@Cast("Nd4jPointer") Pointer npyArray);
	public native Integer elementSizeForNpyArrayHeader( Pointer npyArray)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void releaseNumpy(@Cast("Nd4jPointer") Pointer npyArray);
	public native void releaseNumpy( Pointer npyArray)


	''' <summary>
	''' Return the length of a shape buffer
	''' based on the pointer </summary>
	''' <param name="buffer">  the buffer pointer to check
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int lengthForShapeBufferPointer(@Cast("Nd4jPointer") Pointer buffer);
	public native Integer lengthForShapeBufferPointer( Pointer buffer)


	''' <summary>
	''' The pointer to get the address for
	''' </summary>
	''' <param name="address"> the address to get the pointer </param>
	''' <returns> the pointer for the given address </returns>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer pointerForAddress(@Cast("Nd4jLong") long _address);
	public native Pointer pointerForAddress( Long _address)

	''' <summary>
	''' This method takes single N-dimensional tensor, and copies its TADs to target arrays
	''' </summary>
	''' <param name="x"> </param>
	''' <param name="xShapeInfo"> </param>
	''' <param name="targets"> </param>
	''' <param name="zShapeInfo">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tear(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongPointer xShapeInfo, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer targets, @Cast("const Nd4jLong*") LongPointer zShapeInfo, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets);
	public native void tear( PointerPointer extraPointers, OpaqueDataBuffer dbX, LongPointer xShapeInfo, LongPointer dxShapeInfo, PointerPointer targets, LongPointer zShapeInfo, LongPointer tadShapeInfo, LongPointer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tear(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer targets, @Cast("const Nd4jLong*") LongBuffer zShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets);
	public native void tear( PointerPointer extraPointers, OpaqueDataBuffer dbX, LongBuffer xShapeInfo, LongBuffer dxShapeInfo, PointerPointer targets, LongBuffer zShapeInfo, LongBuffer tadShapeInfo, LongBuffer tadOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tear(@Cast("Nd4jPointer*") PointerPointer extraPointers, OpaqueDataBuffer dbX, @Cast("const Nd4jLong*") long[] xShapeInfo, @Cast("const Nd4jLong*") long[] dxShapeInfo, @Cast("Nd4jPointer*") PointerPointer targets, @Cast("const Nd4jLong*") long[] zShapeInfo, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets);
	public native void tear( PointerPointer extraPointers, OpaqueDataBuffer dbX, Long() xShapeInfo, Long() dxShapeInfo, PointerPointer targets, Long() zShapeInfo, Long() tadShapeInfo, Long() tadOffsets)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sort(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, @Cast("bool") boolean descending);
	public native void sort( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sort(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, @Cast("bool") boolean descending);
	public native void sort( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sort(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, @Cast("bool") boolean descending);
	public native void sort( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Boolean descending)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongPointer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongPointer dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByKey( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, Pointer y, LongPointer yShapeInfo, Pointer dy, LongPointer dyShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongBuffer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongBuffer dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByKey( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, Pointer y, LongBuffer yShapeInfo, Pointer dy, LongBuffer dyShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") long[] yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") long[] dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByKey( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Pointer y, Long() yShapeInfo, Pointer dy, Long() dyShapeInfo, Boolean descending)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongPointer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongPointer dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByValue( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, Pointer y, LongPointer yShapeInfo, Pointer dy, LongPointer dyShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongBuffer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongBuffer dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByValue( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, Pointer y, LongBuffer yShapeInfo, Pointer dy, LongBuffer dyShapeInfo, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") long[] yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") long[] dyShapeInfo, @Cast("bool") boolean descending);
	public native void sortByValue( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Pointer y, Long() yShapeInfo, Pointer dy, Long() dyShapeInfo, Boolean descending)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, IntPointer dimension, int dimensionLength, @Cast("const Nd4jLong*") LongPointer tadShapeInfo, @Cast("const Nd4jLong*") LongPointer tadOffsets, @Cast("bool") boolean descending);
	public native void sortTad( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, IntPointer dimension, Integer dimensionLength, LongPointer tadShapeInfo, LongPointer tadOffsets, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, IntBuffer dimension, int dimensionLength, @Cast("const Nd4jLong*") LongBuffer tadShapeInfo, @Cast("const Nd4jLong*") LongBuffer tadOffsets, @Cast("bool") boolean descending);
	public native void sortTad( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, IntBuffer dimension, Integer dimensionLength, LongBuffer tadShapeInfo, LongBuffer tadOffsets, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTad(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, int[] dimension, int dimensionLength, @Cast("const Nd4jLong*") long[] tadShapeInfo, @Cast("const Nd4jLong*") long[] tadOffsets, @Cast("bool") boolean descending);
	public native void sortTad( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Integer() dimension, Integer dimensionLength, Long() tadShapeInfo, Long() tadOffsets, Boolean descending)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongPointer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongPointer dyShapeInfo, IntPointer dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByKey( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, Pointer y, LongPointer yShapeInfo, Pointer dy, LongPointer dyShapeInfo, IntPointer dimension, Integer dimensionLength, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongBuffer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongBuffer dyShapeInfo, IntBuffer dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByKey( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, Pointer y, LongBuffer yShapeInfo, Pointer dy, LongBuffer dyShapeInfo, IntBuffer dimension, Integer dimensionLength, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByKey(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") long[] yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") long[] dyShapeInfo, int[] dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByKey( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Pointer y, Long() yShapeInfo, Pointer dy, Long() dyShapeInfo, Integer() dimension, Integer dimensionLength, Boolean descending)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongPointer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongPointer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongPointer dyShapeInfo, IntPointer dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByValue( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Pointer dx, LongPointer dxShapeInfo, Pointer y, LongPointer yShapeInfo, Pointer dy, LongPointer dyShapeInfo, IntPointer dimension, Integer dimensionLength, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") LongBuffer dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") LongBuffer yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") LongBuffer dyShapeInfo, IntBuffer dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByValue( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Pointer dx, LongBuffer dxShapeInfo, Pointer y, LongBuffer yShapeInfo, Pointer dy, LongBuffer dyShapeInfo, IntBuffer dimension, Integer dimensionLength, Boolean descending)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortTadByValue(@Cast("Nd4jPointer*") PointerPointer extraPointers, Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, Pointer dx, @Cast("const Nd4jLong*") long[] dxShapeInfo, Pointer y, @Cast("const Nd4jLong*") long[] yShapeInfo, Pointer dy, @Cast("const Nd4jLong*") long[] dyShapeInfo, int[] dimension, int dimensionLength, @Cast("bool") boolean descending);
	public native void sortTadByValue( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Pointer dx, Long() dxShapeInfo, Pointer y, Long() yShapeInfo, Pointer dy, Long() dyShapeInfo, Integer() dimension, Integer dimensionLength, Boolean descending)


	' special sort impl for sorting out COO indices and values
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortCooIndices(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongPointer indices, Pointer x, @Cast("Nd4jLong") long length, @Cast("const Nd4jLong*") LongPointer xShapeInfo);
	public native void sortCooIndices( PointerPointer extraPointers, LongPointer indices, Pointer x, Long length, LongPointer xShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortCooIndices(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongBuffer indices, Pointer x, @Cast("Nd4jLong") long length, @Cast("const Nd4jLong*") LongBuffer xShapeInfo);
	public native void sortCooIndices( PointerPointer extraPointers, LongBuffer indices, Pointer x, Long length, LongBuffer xShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void sortCooIndices(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") long[] indices, Pointer x, @Cast("Nd4jLong") long length, @Cast("const Nd4jLong*") long[] xShapeInfo);
	public native void sortCooIndices( PointerPointer extraPointers, Long() indices, Pointer x, Long length, Long() xShapeInfo)

	''' 
	''' <param name="extraPointers">     not used </param>
	''' <param name="indices">           DataBuffer containing COO indices for a sparse matrix that is to be raveled/flattened </param>
	''' <param name="flatIndices">       DataBuffer where the raveled/flattened indices are to be written to </param>
	''' <param name="length">            number of non-zero entries (length of flatIndices) </param>
	''' <param name="fullShapeBuffer">   DataBuffer with ShapeInfo for the full matrix to be flattened </param>
	''' <param name="mode">              clipMode determines the strategy to use if some of the the passed COO indices does
	'''                          not fit into the shape determined by fullShapeBuffer
	'''                              0   throw an exception (default)
	'''                              1   wrap around shape
	'''                              2   clip to shape </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void ravelMultiIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongPointer indices, @Cast("Nd4jLong*") LongPointer flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") LongPointer shapeInfo, int mode);
	public native void ravelMultiIndex( PointerPointer extraPointers, LongPointer indices, LongPointer flatIndices, Long length, LongPointer shapeInfo, Integer mode)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void ravelMultiIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongBuffer indices, @Cast("Nd4jLong*") LongBuffer flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") LongBuffer shapeInfo, int mode);
	public native void ravelMultiIndex( PointerPointer extraPointers, LongBuffer indices, LongBuffer flatIndices, Long length, LongBuffer shapeInfo, Integer mode)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void ravelMultiIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") long[] indices, @Cast("Nd4jLong*") long[] flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") long[] shapeInfo, int mode);
	public native void ravelMultiIndex( PointerPointer extraPointers, Long() indices, Long() flatIndices, Long length, Long() shapeInfo, Integer mode)

	''' 
	''' <param name="extraPointers">     not used </param>
	''' <param name="indices">           DataBuffer where the unraveled COO indices are to be written </param>
	''' <param name="flatIndices">       DataBuffer containing the raveled/flattened indices to be unravel </param>
	''' <param name="length">            number of non-zero entries (length of flatIndices) </param>
	''' <param name="fullShapeBuffer">   DataBuffer with ShapeInfo for the full matrix to be unraveled </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void unravelIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongPointer indices, @Cast("Nd4jLong*") LongPointer flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") LongPointer shapeInfo);
	public native void unravelIndex( PointerPointer extraPointers, LongPointer indices, LongPointer flatIndices, Long length, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void unravelIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongBuffer indices, @Cast("Nd4jLong*") LongBuffer flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") LongBuffer shapeInfo);
	public native void unravelIndex( PointerPointer extraPointers, LongBuffer indices, LongBuffer flatIndices, Long length, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void unravelIndex(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") long[] indices, @Cast("Nd4jLong*") long[] flatIndices, @Cast("Nd4jLong") long length, @Cast("Nd4jLong*") long[] shapeInfo);
	public native void unravelIndex( PointerPointer extraPointers, Long() indices, Long() flatIndices, Long length, Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer mmapFile(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("char*") String fileName, @Cast("Nd4jLong") long length);
	public native LongPointer mmapFile( PointerPointer extraPointers, String fileName, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongBuffer mmapFile(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("char*") BytePointer fileName, @Cast("Nd4jLong") long length);
	public native LongBuffer mmapFile( PointerPointer extraPointers, BytePointer fileName, Long length)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void munmapFile(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongPointer ptrMap, @Cast("Nd4jLong") long length);
	public native void munmapFile( PointerPointer extraPointers, LongPointer ptrMap, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void munmapFile(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") LongBuffer ptrMap, @Cast("Nd4jLong") long length);
	public native void munmapFile( PointerPointer extraPointers, LongBuffer ptrMap, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void munmapFile(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong*") long[] ptrMap, @Cast("Nd4jLong") long length);
	public native void munmapFile( PointerPointer extraPointers, Long() ptrMap, Long length)

	' flatbuffers execution
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueResultWrapper executeFlatGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer flatBufferPointer);
	public native OpaqueResultWrapper executeFlatGraph( PointerPointer extraPointers, Pointer flatBufferPointer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getResultWrapperSize(OpaqueResultWrapper ptr);
	public native Long getResultWrapperSize(OpaqueResultWrapper ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getResultWrapperPointer(OpaqueResultWrapper ptr);
	public native Pointer getResultWrapperPointer(OpaqueResultWrapper ptr)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getAllCustomOps();
	public native String getAllCustomOps()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getAllOperations();
	public native String getAllOperations()

	' customOp executioner
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, DoublePointer tArgs, int numTArgs, @Cast("Nd4jLong*") LongPointer iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, DoublePointer tArgs, Integer numTArgs, LongPointer iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, DoubleBuffer tArgs, int numTArgs, @Cast("Nd4jLong*") LongBuffer iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, DoubleBuffer tArgs, Integer numTArgs, LongBuffer iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, double[] tArgs, int numTArgs, @Cast("Nd4jLong*") long[] iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, Double() tArgs, Integer numTArgs, Long() iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, DoublePointer tArgs, int numTArgs, @Cast("Nd4jLong*") LongPointer iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, DoublePointer tArgs, Integer numTArgs, LongPointer iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, DoubleBuffer tArgs, int numTArgs, @Cast("Nd4jLong*") LongBuffer iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, DoubleBuffer tArgs, Integer numTArgs, LongBuffer iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs, double[] tArgs, int numTArgs, @Cast("Nd4jLong*") long[] iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, @Cast("bool") boolean isInplace);
	public native Integer execCustomOp( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs, Double() tArgs, Integer numTArgs, Long() iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int execCustomOp2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer") Pointer opContext);
	public native Integer execCustomOp2( PointerPointer extraPointers, Long hash, Pointer opContext)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoublePointer tArgs, int numTArgs, @Cast("Nd4jLong*") LongPointer iArgs, int numIArgs);
	public native OpaqueShapeList calculateOutputShapes( PointerPointer extraPointers, Long hash, PointerPointer inputShapes, Integer numInputShapes, DoublePointer tArgs, Integer numTArgs, LongPointer iArgs, Integer numIArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoubleBuffer tArgs, int numTArgs, @Cast("Nd4jLong*") LongBuffer iArgs, int numIArgs);
	public native OpaqueShapeList calculateOutputShapes( PointerPointer extraPointers, Long hash, PointerPointer inputShapes, Integer numInputShapes, DoubleBuffer tArgs, Integer numTArgs, LongBuffer iArgs, Integer numIArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, double[] tArgs, int numTArgs, @Cast("Nd4jLong*") long[] iArgs, int numIArgs);
	public native OpaqueShapeList calculateOutputShapes( PointerPointer extraPointers, Long hash, PointerPointer inputShapes, Integer numInputShapes, Double() tArgs, Integer numTArgs, Long() iArgs, Integer numIArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoublePointer tArgs, int numTArgs, @Cast("Nd4jLong*") LongPointer iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, IntPointer dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, DoublePointer tArgs, Integer numTArgs, LongPointer iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, IntPointer dArgs, Integer numDArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoubleBuffer tArgs, int numTArgs, @Cast("Nd4jLong*") LongBuffer iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, IntBuffer dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, DoubleBuffer tArgs, Integer numTArgs, LongBuffer iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, IntBuffer dArgs, Integer numDArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, double[] tArgs, int numTArgs, @Cast("Nd4jLong*") long[] iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, int[] dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, Double() tArgs, Integer numTArgs, Long() iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, Integer() dArgs, Integer numDArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoublePointer tArgs, int numTArgs, @Cast("Nd4jLong*") LongPointer iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, IntPointer dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, DoublePointer tArgs, Integer numTArgs, LongPointer iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, IntPointer dArgs, Integer numDArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, DoubleBuffer tArgs, int numTArgs, @Cast("Nd4jLong*") LongBuffer iArgs, int numIArgs, @Cast("bool*") BooleanPointer bArgs, int numBArgs, IntBuffer dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, DoubleBuffer tArgs, Integer numTArgs, LongBuffer iArgs, Integer numIArgs, BooleanPointer bArgs, Integer numBArgs, IntBuffer dArgs, Integer numDArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueShapeList calculateOutputShapes2(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long hash, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputShapes, double[] tArgs, int numTArgs, @Cast("Nd4jLong*") long[] iArgs, int numIArgs, @Cast("bool*") boolean[] bArgs, int numBArgs, int[] dArgs, int numDArgs);
	public native OpaqueShapeList calculateOutputShapes2( PointerPointer extraPointers, Long hash, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputShapes, Double() tArgs, Integer numTArgs, Long() iArgs, Integer numIArgs, Boolean() bArgs, Integer numBArgs, Integer() dArgs, Integer numDArgs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getShapeListSize(OpaqueShapeList list);
	public native Long getShapeListSize(OpaqueShapeList list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getShape(OpaqueShapeList list, @Cast("Nd4jLong") long i);
	public native LongPointer getShape(OpaqueShapeList list, Long i)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteShapeList(@Cast("Nd4jPointer") Pointer shapeList);
	public native void deleteShapeList( Pointer shapeList)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int registerGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long graphId, @Cast("Nd4jPointer") Pointer flatBufferPointer);
	public native Integer registerGraph( PointerPointer extraPointers, Long graphId, Pointer flatBufferPointer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueVariablesSet executeStoredGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long graphId, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, IntPointer inputIndices, int numInputs);
	public native OpaqueVariablesSet executeStoredGraph( PointerPointer extraPointers, Long graphId, PointerPointer inputBuffers, PointerPointer inputShapes, IntPointer inputIndices, Integer numInputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueVariablesSet executeStoredGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long graphId, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, IntBuffer inputIndices, int numInputs);
	public native OpaqueVariablesSet executeStoredGraph( PointerPointer extraPointers, Long graphId, PointerPointer inputBuffers, PointerPointer inputShapes, IntBuffer inputIndices, Integer numInputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueVariablesSet executeStoredGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long graphId, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int[] inputIndices, int numInputs);
	public native OpaqueVariablesSet executeStoredGraph( PointerPointer extraPointers, Long graphId, PointerPointer inputBuffers, PointerPointer inputShapes, Integer() inputIndices, Integer numInputs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getVariablesSetSize(OpaqueVariablesSet set);
	public native Long getVariablesSetSize(OpaqueVariablesSet set)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int getVariablesSetStatus(OpaqueVariablesSet set);
	public native Integer getVariablesSetStatus(OpaqueVariablesSet set)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueVariable getVariable(OpaqueVariablesSet set, @Cast("Nd4jLong") long i);
	public native OpaqueVariable getVariable(OpaqueVariablesSet set, Long i)
	public native Integer getVariableId(OpaqueVariable variable)
	public native Integer getVariableIndex(OpaqueVariable variable)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getVariableName(OpaqueVariable variable);
	public native String getVariableName(OpaqueVariable variable)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer getVariableShape(OpaqueVariable variable);
	public native LongPointer getVariableShape(OpaqueVariable variable)
	public native Pointer getVariableBuffer(OpaqueVariable variable)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int unregisterGraph(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jLong") long graphId);
	public native Integer unregisterGraph( PointerPointer extraPointers, Long graphId)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteCharArray(@Cast("Nd4jPointer") Pointer pointer);
	public native void deleteCharArray( Pointer pointer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteIntArray(@Cast("Nd4jPointer") Pointer pointer);
	public native void deleteIntArray( Pointer pointer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteLongArray(@Cast("Nd4jPointer") Pointer pointer);
	public native void deleteLongArray( Pointer pointer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deletePointerArray(@Cast("Nd4jPointer") Pointer pointer);
	public native void deletePointerArray( Pointer pointer)

	public native void deleteVariablesSet(OpaqueVariablesSet pointer)

	' GraphState creation
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getGraphState(@Cast("Nd4jLong") long id);
	public native Pointer getGraphState( Long id)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteGraphState(@Cast("Nd4jPointer") Pointer state);
	public native void deleteGraphState( Pointer state)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteResultWrapper(@Cast("Nd4jPointer") Pointer ptr);
	public native void deleteResultWrapper( Pointer ptr)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int estimateThreshold(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer x, @Cast("const Nd4jLong*") LongPointer xShapeInfo, int N, float threshold);
	public native Integer estimateThreshold( PointerPointer extraPointers, Pointer x, LongPointer xShapeInfo, Integer N, Single threshold)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int estimateThreshold(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer x, @Cast("const Nd4jLong*") LongBuffer xShapeInfo, int N, float threshold);
	public native Integer estimateThreshold( PointerPointer extraPointers, Pointer x, LongBuffer xShapeInfo, Integer N, Single threshold)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int estimateThreshold(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer x, @Cast("const Nd4jLong*") long[] xShapeInfo, int N, float threshold);
	public native Integer estimateThreshold( PointerPointer extraPointers, Pointer x, Long() xShapeInfo, Integer N, Single threshold)

	' this method executes op that requires scope to be present: if/while/cond/whatever
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execCustomOpWithScope(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer state, @Cast("Nd4jLong") long opHash, @Cast("Nd4jLong*") LongPointer scopes, int numScopes, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs);
	public native Integer execCustomOpWithScope( PointerPointer extraPointers, Pointer state, Long opHash, LongPointer scopes, Integer numScopes, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execCustomOpWithScope(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer state, @Cast("Nd4jLong") long opHash, @Cast("Nd4jLong*") LongBuffer scopes, int numScopes, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs);
	public native Integer execCustomOpWithScope( PointerPointer extraPointers, Pointer state, Long opHash, LongBuffer scopes, Integer numScopes, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execCustomOpWithScope(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer state, @Cast("Nd4jLong") long opHash, @Cast("Nd4jLong*") long[] scopes, int numScopes, @Cast("Nd4jPointer*") PointerPointer inputBuffers, @Cast("Nd4jPointer*") PointerPointer inputShapes, int numInputs, @Cast("Nd4jPointer*") PointerPointer outputBuffers, @Cast("Nd4jPointer*") PointerPointer outputShapes, int numOutputs);
	public native Integer execCustomOpWithScope( PointerPointer extraPointers, Pointer state, Long opHash, Long() scopes, Integer numScopes, PointerPointer inputBuffers, PointerPointer inputShapes, Integer numInputs, PointerPointer outputBuffers, PointerPointer outputShapes, Integer numOutputs)

	'void fillUtf8String(Nd4jPointer *extraPointers, const char **string, int numStrings, Nd4jPointer buffer);
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer createUtf8String(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("char*") String string, int length);
	public native Pointer createUtf8String( PointerPointer extraPointers, String [string], Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer createUtf8String(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("char*") BytePointer string, int length);
	public native Pointer createUtf8String( PointerPointer extraPointers, BytePointer [string], Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getUtf8StringLength(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer ptr);
	public native Long getUtf8StringLength( PointerPointer extraPointers, Pointer ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") BytePointer getUtf8StringBuffer(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer ptr);
	public native BytePointer getUtf8StringBuffer( PointerPointer extraPointers, Pointer ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteUtf8String(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer ptr);
	public native void deleteUtf8String( PointerPointer extraPointers, Pointer ptr)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void scatterUpdate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opCode, int numOfSubArrs, Pointer hX, @Cast("const Nd4jLong*") LongPointer hXShapeInfo, @Cast("const Nd4jLong*") LongPointer hXOffsets, Pointer dX, @Cast("const Nd4jLong*") LongPointer dXShapeInfo, @Cast("const Nd4jLong*") LongPointer dXOffsets, Pointer hY, @Cast("const Nd4jLong*") LongPointer hYShapeInfo, @Cast("const Nd4jLong*") LongPointer hYOffsets, Pointer dY, @Cast("const Nd4jLong*") LongPointer dYShapeInfo, @Cast("const Nd4jLong*") LongPointer dYOffsets, Pointer hIindexes, @Cast("const Nd4jLong*") LongPointer hIndicesShapeInfo, Pointer dIindexes, @Cast("const Nd4jLong*") LongPointer dIndicesShapeInfo);
	public native void scatterUpdate( PointerPointer extraPointers, Integer opCode, Integer numOfSubArrs, Pointer hX, LongPointer hXShapeInfo, LongPointer hXOffsets, Pointer dX, LongPointer dXShapeInfo, LongPointer dXOffsets, Pointer hY, LongPointer hYShapeInfo, LongPointer hYOffsets, Pointer dY, LongPointer dYShapeInfo, LongPointer dYOffsets, Pointer hIindexes, LongPointer hIndicesShapeInfo, Pointer dIindexes, LongPointer dIndicesShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void scatterUpdate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opCode, int numOfSubArrs, Pointer hX, @Cast("const Nd4jLong*") LongBuffer hXShapeInfo, @Cast("const Nd4jLong*") LongBuffer hXOffsets, Pointer dX, @Cast("const Nd4jLong*") LongBuffer dXShapeInfo, @Cast("const Nd4jLong*") LongBuffer dXOffsets, Pointer hY, @Cast("const Nd4jLong*") LongBuffer hYShapeInfo, @Cast("const Nd4jLong*") LongBuffer hYOffsets, Pointer dY, @Cast("const Nd4jLong*") LongBuffer dYShapeInfo, @Cast("const Nd4jLong*") LongBuffer dYOffsets, Pointer hIindexes, @Cast("const Nd4jLong*") LongBuffer hIndicesShapeInfo, Pointer dIindexes, @Cast("const Nd4jLong*") LongBuffer dIndicesShapeInfo);
	public native void scatterUpdate( PointerPointer extraPointers, Integer opCode, Integer numOfSubArrs, Pointer hX, LongBuffer hXShapeInfo, LongBuffer hXOffsets, Pointer dX, LongBuffer dXShapeInfo, LongBuffer dXOffsets, Pointer hY, LongBuffer hYShapeInfo, LongBuffer hYOffsets, Pointer dY, LongBuffer dYShapeInfo, LongBuffer dYOffsets, Pointer hIindexes, LongBuffer hIndicesShapeInfo, Pointer dIindexes, LongBuffer dIndicesShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void scatterUpdate(@Cast("Nd4jPointer*") PointerPointer extraPointers, int opCode, int numOfSubArrs, Pointer hX, @Cast("const Nd4jLong*") long[] hXShapeInfo, @Cast("const Nd4jLong*") long[] hXOffsets, Pointer dX, @Cast("const Nd4jLong*") long[] dXShapeInfo, @Cast("const Nd4jLong*") long[] dXOffsets, Pointer hY, @Cast("const Nd4jLong*") long[] hYShapeInfo, @Cast("const Nd4jLong*") long[] hYOffsets, Pointer dY, @Cast("const Nd4jLong*") long[] dYShapeInfo, @Cast("const Nd4jLong*") long[] dYOffsets, Pointer hIindexes, @Cast("const Nd4jLong*") long[] hIndicesShapeInfo, Pointer dIindexes, @Cast("const Nd4jLong*") long[] dIndicesShapeInfo);
	public native void scatterUpdate( PointerPointer extraPointers, Integer opCode, Integer numOfSubArrs, Pointer hX, Long() hXShapeInfo, Long() hXOffsets, Pointer dX, Long() dXShapeInfo, Long() dXOffsets, Pointer hY, Long() hYShapeInfo, Long() hYOffsets, Pointer dY, Long() dYShapeInfo, Long() dYOffsets, Pointer hIindexes, Long() hIndicesShapeInfo, Pointer dIindexes, Long() dIndicesShapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void inspectArray(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer buffer, @Cast("Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jPointer") Pointer specialBuffer, @Cast("Nd4jLong*") LongPointer specialShapeInfo, @Cast("Nd4jPointer") Pointer debugInfo);
	public native void inspectArray( PointerPointer extraPointers, Pointer buffer, LongPointer shapeInfo, Pointer specialBuffer, LongPointer specialShapeInfo, Pointer debugInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void inspectArray(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer buffer, @Cast("Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jPointer") Pointer specialBuffer, @Cast("Nd4jLong*") LongBuffer specialShapeInfo, @Cast("Nd4jPointer") Pointer debugInfo);
	public native void inspectArray( PointerPointer extraPointers, Pointer buffer, LongBuffer shapeInfo, Pointer specialBuffer, LongBuffer specialShapeInfo, Pointer debugInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void inspectArray(@Cast("Nd4jPointer*") PointerPointer extraPointers, @Cast("Nd4jPointer") Pointer buffer, @Cast("Nd4jLong*") long[] shapeInfo, @Cast("Nd4jPointer") Pointer specialBuffer, @Cast("Nd4jLong*") long[] specialShapeInfo, @Cast("Nd4jPointer") Pointer debugInfo);
	public native void inspectArray( PointerPointer extraPointers, Pointer buffer, Long() shapeInfo, Pointer specialBuffer, Long() specialShapeInfo, Pointer debugInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBuffer(int rank, @Cast("Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("bool") boolean empty);
	public native OpaqueConstantShapeBuffer shapeBuffer(Integer rank, LongPointer shape, LongPointer strides, Integer dtype, Char order, Long ews, Boolean empty)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBuffer(int rank, @Cast("Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("bool") boolean empty);
	public native OpaqueConstantShapeBuffer shapeBuffer(Integer rank, LongBuffer shape, LongBuffer strides, Integer dtype, Char order, Long ews, Boolean empty)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBuffer(int rank, @Cast("Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("bool") boolean empty);
	public native OpaqueConstantShapeBuffer shapeBuffer(Integer rank, Long() shape, Long() strides, Integer dtype, Char order, Long ews, Boolean empty)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBufferEx(int rank, @Cast("Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
	public native OpaqueConstantShapeBuffer shapeBufferEx(Integer rank, LongPointer shape, LongPointer strides, Integer dtype, Char order, Long ews, Long extras)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBufferEx(int rank, @Cast("Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
	public native OpaqueConstantShapeBuffer shapeBufferEx(Integer rank, LongBuffer shape, LongBuffer strides, Integer dtype, Char order, Long ews, Long extras)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantShapeBuffer shapeBufferEx(int rank, @Cast("Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] strides, @Cast("sd::DataType") int dtype, char order, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
	public native OpaqueConstantShapeBuffer shapeBufferEx(Integer rank, Long() shape, Long() strides, Integer dtype, Char order, Long ews, Long extras)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferLong(@Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongPointer data, int length);
	public native OpaqueConstantDataBuffer constantBufferLong( Integer dtype, LongPointer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferLong(@Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongBuffer data, int length);
	public native OpaqueConstantDataBuffer constantBufferLong( Integer dtype, LongBuffer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferLong(@Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") long[] data, int length);
	public native OpaqueConstantDataBuffer constantBufferLong( Integer dtype, Long() data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferDouble(@Cast("sd::DataType") int dtype, DoublePointer data, int length);
	public native OpaqueConstantDataBuffer constantBufferDouble( Integer dtype, DoublePointer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferDouble(@Cast("sd::DataType") int dtype, DoubleBuffer data, int length);
	public native OpaqueConstantDataBuffer constantBufferDouble( Integer dtype, DoubleBuffer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBufferDouble(@Cast("sd::DataType") int dtype, double[] data, int length);
	public native OpaqueConstantDataBuffer constantBufferDouble( Integer dtype, Double() data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueConstantDataBuffer constantBuffer(@Cast("sd::DataType") int dtype, ConstantDescriptor descriptor);
	public native OpaqueConstantDataBuffer constantBuffer( Integer dtype, ConstantDescriptor descriptor)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getConstantDataBufferPrimary(OpaqueConstantDataBuffer dbf);
	public native Pointer getConstantDataBufferPrimary(OpaqueConstantDataBuffer dbf)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getConstantDataBufferSpecial(OpaqueConstantDataBuffer dbf);
	public native Pointer getConstantDataBufferSpecial(OpaqueConstantDataBuffer dbf)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getConstantDataBufferLength(OpaqueConstantDataBuffer dbf);
	public native Long getConstantDataBufferLength(OpaqueConstantDataBuffer dbf)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getConstantShapeBufferPrimary(OpaqueConstantShapeBuffer dbf);
	public native Pointer getConstantShapeBufferPrimary(OpaqueConstantShapeBuffer dbf)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer getConstantShapeBufferSpecial(OpaqueConstantShapeBuffer dbf);
	public native Pointer getConstantShapeBufferSpecial(OpaqueConstantShapeBuffer dbf)

	public native void deleteConstantShapeBuffer(OpaqueConstantShapeBuffer ptr)
	public native void deleteConstantDataBuffer(OpaqueConstantDataBuffer ptr)

	public native OpaqueContext createGraphContext(Integer nodeId)
	public native OpaqueRandomGenerator getGraphContextRandomGenerator(OpaqueContext ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void ctxAllowHelpers(OpaqueContext ptr, @Cast("bool") boolean reallyAllow);
	public native void ctxAllowHelpers(OpaqueContext ptr, Boolean reallyAllow)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void ctxShapeFunctionOverride(OpaqueContext ptr, @Cast("bool") boolean reallyOverride);
	public native void ctxShapeFunctionOverride(OpaqueContext ptr, Boolean reallyOverride)
	public native void ctxSetExecutionMode(OpaqueContext ptr, Integer execMode)
	public native void ctxPurge(OpaqueContext ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markGraphContextInplace(OpaqueContext ptr, @Cast("bool") boolean reallyInplace);
	public native void markGraphContextInplace(OpaqueContext ptr, Boolean reallyInplace)
	public native void setGraphContextCudaContext(OpaqueContext ptr, Pointer stream, Pointer reductionPointer, Pointer allocationPointer)
	public native void setGraphContextInputArray(OpaqueContext ptr, Integer index, Pointer buffer, Pointer shapeInfo, Pointer specialBuffer, Pointer specialShapeInfo)
	public native void setGraphContextOutputArray(OpaqueContext ptr, Integer index, Pointer buffer, Pointer shapeInfo, Pointer specialBuffer, Pointer specialShapeInfo)
	public native void setGraphContextInputBuffer(OpaqueContext ptr, Integer index, OpaqueDataBuffer buffer, Pointer shapeInfo, Pointer specialShapeInfo)
	public native void setGraphContextOutputBuffer(OpaqueContext ptr, Integer index, OpaqueDataBuffer buffer, Pointer shapeInfo, Pointer specialShapeInfo)
	public native void setGraphContextDArguments(OpaqueContext ptr, IntPointer arguments, Integer numberOfArguments)
	public native void setGraphContextDArguments(OpaqueContext ptr, IntBuffer arguments, Integer numberOfArguments)
	public native void setGraphContextDArguments(OpaqueContext ptr, Integer() arguments, Integer numberOfArguments)
	public native void setGraphContextTArguments(OpaqueContext ptr, DoublePointer arguments, Integer numberOfArguments)
	public native void setGraphContextTArguments(OpaqueContext ptr, DoubleBuffer arguments, Integer numberOfArguments)
	public native void setGraphContextTArguments(OpaqueContext ptr, Double() arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGraphContextIArguments(OpaqueContext ptr, @Cast("Nd4jLong*") LongPointer arguments, int numberOfArguments);
	public native void setGraphContextIArguments(OpaqueContext ptr, LongPointer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGraphContextIArguments(OpaqueContext ptr, @Cast("Nd4jLong*") LongBuffer arguments, int numberOfArguments);
	public native void setGraphContextIArguments(OpaqueContext ptr, LongBuffer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGraphContextIArguments(OpaqueContext ptr, @Cast("Nd4jLong*") long[] arguments, int numberOfArguments);
	public native void setGraphContextIArguments(OpaqueContext ptr, Long() arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGraphContextBArguments(OpaqueContext ptr, @Cast("bool*") BooleanPointer arguments, int numberOfArguments);
	public native void setGraphContextBArguments(OpaqueContext ptr, BooleanPointer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setGraphContextBArguments(OpaqueContext ptr, @Cast("bool*") boolean[] arguments, int numberOfArguments);
	public native void setGraphContextBArguments(OpaqueContext ptr, Boolean() arguments, Integer numberOfArguments)
	public native void deleteGraphContext(OpaqueContext ptr)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueRandomGenerator createRandomGenerator(@Cast("Nd4jLong") long rootSeed, @Cast("Nd4jLong") long nodeSeed);
	public native OpaqueRandomGenerator createRandomGenerator( Long rootSeed, Long nodeSeed)
	public native OpaqueRandomGenerator createRandomGenerator()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getRandomGeneratorRootState(OpaqueRandomGenerator ptr);
	public native Long getRandomGeneratorRootState(OpaqueRandomGenerator ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getRandomGeneratorNodeState(OpaqueRandomGenerator ptr);
	public native Long getRandomGeneratorNodeState(OpaqueRandomGenerator ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRandomGeneratorStates(OpaqueRandomGenerator ptr, @Cast("Nd4jLong") long rootSeed, @Cast("Nd4jLong") long nodeSeed);
	public native void setRandomGeneratorStates(OpaqueRandomGenerator ptr, Long rootSeed, Long nodeSeed)
	public native void setRandomGeneratorStates(OpaqueRandomGenerator ptr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native float getRandomGeneratorRelativeFloat(OpaqueRandomGenerator ptr, @Cast("Nd4jLong") long index);
	public native Single getRandomGeneratorRelativeFloat(OpaqueRandomGenerator ptr, Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native double getRandomGeneratorRelativeDouble(OpaqueRandomGenerator ptr, @Cast("Nd4jLong") long index);
	public native Double getRandomGeneratorRelativeDouble(OpaqueRandomGenerator ptr, Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int getRandomGeneratorRelativeInt(OpaqueRandomGenerator ptr, @Cast("Nd4jLong") long index);
	public native Integer getRandomGeneratorRelativeInt(OpaqueRandomGenerator ptr, Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getRandomGeneratorRelativeLong(OpaqueRandomGenerator ptr, @Cast("Nd4jLong") long index);
	public native Long getRandomGeneratorRelativeLong(OpaqueRandomGenerator ptr, Long index)
	public native void deleteRandomGenerator(OpaqueRandomGenerator ptr)

	public native OpaqueLaunchContext defaultLaunchContext()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcScalarPointer(OpaqueLaunchContext lc);
	public native Pointer lcScalarPointer(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcReductionPointer(OpaqueLaunchContext lc);
	public native Pointer lcReductionPointer(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcAllocationPointer(OpaqueLaunchContext lc);
	public native Pointer lcAllocationPointer(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcExecutionStream(OpaqueLaunchContext lc);
	public native Pointer lcExecutionStream(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcCopyStream(OpaqueLaunchContext lc);
	public native Pointer lcCopyStream(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcBlasHandle(OpaqueLaunchContext lc);
	public native Pointer lcBlasHandle(OpaqueLaunchContext lc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer lcSolverHandle(OpaqueLaunchContext lc);
	public native Pointer lcSolverHandle(OpaqueLaunchContext lc)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueDataBuffer allocateDataBuffer(@Cast("Nd4jLong") long elements, int dataType, @Cast("bool") boolean allocateBoth);
	public native OpaqueDataBuffer allocateDataBuffer( Long elements, Integer dataType, Boolean allocateBoth)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueDataBuffer dbAllocateDataBuffer(@Cast("Nd4jLong") long elements, int dataType, @Cast("bool") boolean allocateBoth);
	public native OpaqueDataBuffer dbAllocateDataBuffer( Long elements, Integer dataType, Boolean allocateBoth)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueDataBuffer dbCreateExternalDataBuffer(@Cast("Nd4jLong") long elements, int dataType, @Cast("Nd4jPointer") Pointer primary, @Cast("Nd4jPointer") Pointer special);
	public native OpaqueDataBuffer dbCreateExternalDataBuffer( Long elements, Integer dataType, Pointer primary, Pointer special)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpaqueDataBuffer dbCreateView(OpaqueDataBuffer dataBuffer, @Cast("Nd4jLong") long length, @Cast("Nd4jLong") long offset);
	public native OpaqueDataBuffer dbCreateView(OpaqueDataBuffer dataBuffer, Long length, Long offset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer dbPrimaryBuffer(OpaqueDataBuffer dataBuffer);
	public native Pointer dbPrimaryBuffer(OpaqueDataBuffer dataBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer dbSpecialBuffer(OpaqueDataBuffer dataBuffer);
	public native Pointer dbSpecialBuffer(OpaqueDataBuffer dataBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void dbExpandBuffer(OpaqueDataBuffer dataBuffer, @Cast("Nd4jLong") long elements);
	public native void dbExpandBuffer(OpaqueDataBuffer dataBuffer, Long elements)
	public native void dbAllocatePrimaryBuffer(OpaqueDataBuffer dataBuffer)
	public native void dbAllocateSpecialBuffer(OpaqueDataBuffer dataBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void dbSetPrimaryBuffer(OpaqueDataBuffer dataBuffer, @Cast("Nd4jPointer") Pointer primaryBuffer, @Cast("Nd4jLong") long numBytes);
	public native void dbSetPrimaryBuffer(OpaqueDataBuffer dataBuffer, Pointer primaryBuffer, Long numBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void dbSetSpecialBuffer(OpaqueDataBuffer dataBuffer, @Cast("Nd4jPointer") Pointer specialBuffer, @Cast("Nd4jLong") long numBytes);
	public native void dbSetSpecialBuffer(OpaqueDataBuffer dataBuffer, Pointer specialBuffer, Long numBytes)
	public native void dbSyncToSpecial(OpaqueDataBuffer dataBuffer)
	public native void dbSyncToPrimary(OpaqueDataBuffer dataBuffer)
	public native Integer dbLocality(OpaqueDataBuffer dataBuffer)
	public native Integer dbDeviceId(OpaqueDataBuffer dataBuffer)
	public native void dbSetDeviceId(OpaqueDataBuffer dataBuffer, Integer deviceId)
	public native void dbTickHostRead(OpaqueDataBuffer dataBuffer)
	public native void dbTickHostWrite(OpaqueDataBuffer dataBuffer)
	public native void dbTickDeviceRead(OpaqueDataBuffer dataBuffer)
	public native void dbTickDeviceWrite(OpaqueDataBuffer dataBuffer)
	public native void dbClose(OpaqueDataBuffer dataBuffer)
	public native void deleteDataBuffer(OpaqueDataBuffer dataBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void dbExpand(OpaqueDataBuffer dataBuffer, @Cast("Nd4jLong") long elements);
	public native void dbExpand(OpaqueDataBuffer dataBuffer, Long elements)


	public native Integer binaryLevel()
	public native Integer optimalLevel()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isMinimalRequirementsMet();
	public native Boolean isMinimalRequirementsMet()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isOptimalRequirementsMet();
	public native Boolean isOptimalRequirementsMet()

	' #endif //NATIVEOPERATIONS_NATIVEOPS_H


	' Parsed from build_info.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	' #ifndef LIBND4J_BUILD_INFO_H
	' #define LIBND4J_BUILD_INFO_H

	' #ifdef  _WIN32
	' #define ND4J_EXPORT   __declspec( dllexport )
	' #else
	' #define ND4J_EXPORT
	' #endif

	' #define STRINGIFY(x) #x
	' #define TOSTRING(x) STRINGIFY(x)

	' #ifdef __cplusplus
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String buildInfo();
	public native String buildInfo()

	' #ifdef __cplusplus
	' #endif

	' #endif


	' Parsed from memory/ExternalWorkspace.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_EXTERNALWORKSPACE_H
	' #define LIBND4J_EXTERNALWORKSPACE_H

	' #include <system/pointercast.h>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::memory") @NoOffset public static class ExternalWorkspace extends Pointer
			public static class ExternalWorkspace extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ExternalWorkspace(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ExternalWorkspace(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ExternalWorkspace position(Long position)
				If True Then
					Return CType(MyBase.position(position), ExternalWorkspace)
				End If
				public ExternalWorkspace getPointer(Long i)
				If True Then
					Return (New ExternalWorkspace(CType(Me, Pointer))).position(position + i)
				End If

				public ExternalWorkspace()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ExternalWorkspace(@Cast("Nd4jPointer") Pointer ptrH, @Cast("Nd4jLong") long sizeH, @Cast("Nd4jPointer") Pointer ptrD, @Cast("Nd4jLong") long sizeD)
				public ExternalWorkspace( Pointer ptrH, Long sizeH, Pointer ptrD, Long sizeD)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(ptrH, sizeH, ptrD, sizeD)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jPointer") Pointer ptrH, @Cast("Nd4jLong") long sizeH, @Cast("Nd4jPointer") Pointer ptrD, @Cast("Nd4jLong") long sizeD);
				private native void allocate( Pointer ptrH, Long sizeH, Pointer ptrD, Long sizeD)

				public native Pointer pointerHost()
				public native Pointer pointerDevice()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long sizeHost();
				public native Long sizeHost()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long sizeDevice();
				public native Long sizeDevice()
			End If



	' #endif

	' Parsed from memory/Workspace.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' This class implements Workspace functionality in c++
	'
	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_WORKSPACE_H
	' #define LIBND4J_WORKSPACE_H

	' #include <atomic>
	' #include <vector>
	' #include <mutex>
	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <types/float16.h>
	' #include <memory/ExternalWorkspace.h>
	' #include <memory/MemoryType.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::memory") @NoOffset public static class Workspace extends Pointer
			public static class Workspace extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Workspace(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Workspace(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Workspace position(Long position)
				If True Then
					Return CType(MyBase.position(position), Workspace)
				End If
				public Workspace getPointer(Long i)
				If True Then
					Return (New Workspace(CType(Me, Pointer))).position(position + i)
				End If

				public Workspace(ExternalWorkspace external)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(external)
				End If
				private native void allocate(ExternalWorkspace external)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Workspace(@Cast("Nd4jLong") long initialSize, @Cast("Nd4jLong") long secondaryBytes)
				public Workspace( Long initialSize, Long secondaryBytes)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(initialSize, secondaryBytes)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long initialSize, @Cast("Nd4jLong") long secondaryBytes);
				private native void allocate( Long initialSize, Long secondaryBytes)
				public Workspace()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getAllocatedSize();
				public native Long getAllocatedSize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getCurrentSize();
				public native Long getCurrentSize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getCurrentOffset();
				public native Long getCurrentOffset()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getSpilledSize();
				public native Long getSpilledSize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getUsedSize();
				public native Long getUsedSize()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getAllocatedSecondarySize();
				public native Long getAllocatedSecondarySize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getCurrentSecondarySize();
				public native Long getCurrentSecondarySize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getCurrentSecondaryOffset();
				public native Long getCurrentSecondaryOffset()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getSpilledSecondarySize();
				public native Long getSpilledSecondarySize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getUsedSecondarySize();
				public native Long getUsedSecondarySize()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void expandBy(@Cast("Nd4jLong") long primaryBytes, @Cast("Nd4jLong") long secondaryBytes);
				public native void expandBy( Long primaryBytes, Long secondaryBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void expandBy(@Cast("Nd4jLong") long primaryBytes);
				public native void expandBy( Long primaryBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void expandTo(@Cast("Nd4jLong") long primaryBytes, @Cast("Nd4jLong") long secondaryBytes);
				public native void expandTo( Long primaryBytes, Long secondaryBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void expandTo(@Cast("Nd4jLong") long primaryBytes);
				public native void expandTo( Long primaryBytes)

	'            bool resizeSupported();

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer allocateBytes(@Cast("Nd4jLong") long numBytes);
				public native Pointer allocateBytes( Long numBytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer allocateBytes(@Cast("sd::memory::MemoryType") int type, @Cast("Nd4jLong") long numBytes);
				public native Pointer allocateBytes( Integer type, Long numBytes)

				public native void scopeIn()
				public native void scopeOut()

	'            
	'             * This method creates NEW workspace of the same memory size and returns pointer to it
	'             
				public native Workspace MemberwiseClone()
			End If



	' #endif //LIBND4J_WORKSPACE_H


	' Parsed from indexing/NDIndex.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_NDINDEX_H
	' #define LIBND4J_NDINDEX_H

	' #include <system/pointercast.h>
	' #include <vector>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class NDIndex extends Pointer
		public static class NDIndex extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDIndex(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public NDIndex(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public NDIndex position(Long position)
			If True Then
				Return CType(MyBase.position(position), NDIndex)
			End If
			public NDIndex getPointer(Long i)
			If True Then
				Return (New NDIndex(CType(Me, Pointer))).position(position + i)
			End If

			public NDIndex()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isAll();
			public native Boolean isAll()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isPoint();
			public native Boolean isPoint()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInterval();
			public native Boolean isInterval()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer getIndices();
			public native @StdVector LongPointer getIndices()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long stride();
			public native Long stride()

			public native NDIndex all()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDIndex point(@Cast("Nd4jLong") long pt);
			public native NDIndex point( Long pt)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDIndex interval(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end, @Cast("Nd4jLong") long stride);
			public native NDIndex interval( Long start, Long [end], Long stride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDIndex interval(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end);
			public native NDIndex interval( Long start, Long [end])
		End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class NDIndexAll extends NDIndex
		public static class NDIndexAll extends NDIndex
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDIndexAll(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public NDIndexAll(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public NDIndexAll position(Long position)
			If True Then
				Return CType(MyBase.position(position), NDIndexAll)
			End If
			public NDIndexAll getPointer(Long i)
			If True Then
				Return (New NDIndexAll(CType(Me, Pointer))).position(position + i)
			End If

			public NDIndexAll()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInterval();
			public native Boolean isInterval()
		End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class NDIndexPoint extends NDIndex
		public static class NDIndexPoint extends NDIndex
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDIndexPoint(Pointer p)
			If True Then
				MyBase(p)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDIndexPoint(@Cast("Nd4jLong") long point)
			public NDIndexPoint( Long point)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(point)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long point);
			private native void allocate( Long point)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInterval();
			public native Boolean isInterval()
		End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class NDIndexInterval extends NDIndex
		public static class NDIndexInterval extends NDIndex
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDIndexInterval(Pointer p)
			If True Then
				MyBase(p)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDIndexInterval(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end, @Cast("Nd4jLong") long stride)
			public NDIndexInterval( Long start, Long [end], Long stride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(start, [end], stride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end, @Cast("Nd4jLong") long stride);
			private native void allocate( Long start, Long [end], Long stride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDIndexInterval(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end)
			public NDIndexInterval( Long start, Long [end])
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(start, [end])
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long start, @Cast("Nd4jLong") long end);
			private native void allocate( Long start, Long [end])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInterval();
			public native Boolean isInterval()
		End If




	' #endif //LIBND4J_NDINDEX_H


	' Parsed from indexing/IndicesList.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_INDICESLIST_H
	' #define LIBND4J_INDICESLIST_H

	' #include <initializer_list>
	' #include "NDIndex.h"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class IndicesList extends Pointer
		public static class IndicesList extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public IndicesList(Pointer p)
			If True Then
				MyBase(p)
			End If


			public native Integer size()
			public native NDIndex at(Integer idx)
			public native void push_back(NDIndex idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isScalar();
			public native Boolean isScalar()
		End If

	' #endif //LIBND4J_INDICESLIST_H


	' Parsed from graph/VariableType.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef ND4J_VARIABLE_TYPE_H
	' #define ND4J_VARIABLE_TYPE_H
			''' <summary>
			''' enum sd::graph::VariableType </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int NDARRAY = 0, ARRAY_LIST = 1, FLOW = 2, CONSTANT = 3, PLACEHOLDER = 4;
			3, PLACEHOLDER = 4
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int NDARRAY = 0, ARRAY_LIST = 1, FLOW = 2, CONSTANT = 3, PLACEHOLDER
				2, CONSTANT = 3, PLACEHOLDER
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int NDARRAY = 0, ARRAY_LIST = 1, FLOW = 2, CONSTANT
					1, FLOW = 2, CONSTANT
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int NDARRAY = 0, ARRAY_LIST = 1, FLOW
						0, ARRAY_LIST = 1, FLOW
							public static final Integer NDARRAY = 0, ARRAY_LIST



	' #endif

	' Parsed from graph/ArgumentsList.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 24.01.18.
	'

	' #ifndef LIBND4J_INPUTLIST_H
	' #define LIBND4J_INPUTLIST_H

	' #include <system/op_boilerplate.h>
	' #include <system/pointercast.h>
	' #include <system/dll.h>
	' #include <vector>
	' #include <types/pair.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class ArgumentsList extends Pointer
		public static class ArgumentsList extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ArgumentsList(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ArgumentsList(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ArgumentsList position(Long position)
			If True Then
				Return CType(MyBase.position(position), ArgumentsList)
			End If
			public ArgumentsList getPointer(Long i)
			If True Then
				Return (New ArgumentsList(CType(Me, Pointer))).position(position + i)
			End If

			public ArgumentsList()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			''' <summary>
			''' This method returns number of argument pairs available
			''' 
			''' @return
			''' </summary>
			public native Integer size()

			''' <summary>
			''' This method returns Pair at specified index
			''' </summary>
			''' <param name="index">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef Pair at(int index);
			public native Pair at(Integer index)
		End If



	' #endif //LIBND4J_INPUTLIST_H


	' Parsed from types/pair.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 24.01.18.
	'

	' #ifndef LIBND4J_PAIR_H
	' #define LIBND4J_PAIR_H

	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class Pair extends Pointer
		public static class Pair extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public Pair(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public Pair(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public Pair position(Long position)
			If True Then
				Return CType(MyBase.position(position), Pair)
			End If
			public Pair getPointer(Long i)
			If True Then
				Return (New Pair(CType(Me, Pointer))).position(position + i)
			End If

			public Pair(Integer first, Integer second)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(first, second)
			End If
			private native void allocate(Integer first, Integer second)
			public Pair()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			public native Integer first()
			public native Integer second()
		End If



	' #endif //LIBND4J_PAIR_H


	' Parsed from array/NDArray.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	' #ifndef NDARRAY_H
	' #define NDARRAY_H

	' #include <system/dll.h>
	' #include <initializer_list>
	' #include <functional>
	' #include <helpers/shape.h>
	' #include "legacy/NativeOpExecutioner.h"
	' #include <indexing/NDIndex.h>
	' #include <indexing/IndicesList.h>
	' #include <graph/Intervals.h>
	' #include <array/DataType.h>
	' #include <array/DataTypeUtils.h>
	' #include <stdint.h>
	' #include <array/ArrayOptions.h>
	' #include <array/ArrayType.h>
	' #include <array/ResultSet.h>
	' #include <helpers/ShapeBuilders.h>
	' #include <system/op_enums.h>
	' #include <ops/BroadcastOpsTuple.h>
	' #include <ops/BroadcastBoolOpsTuple.h>
	' #include <ops/BroadcastIntOpsTuple.h>
	' #include <array/ExtraArguments.h>
	' #include <graph/Status.h>
	' #include <array/ShapeDescriptor.h>
	' #include <helpers/ConstantShapeHelper.h>
	' #include <array/DataBuffer.h>
	' #include <execution/AffinityManager.h>
	' #include <memory>
	' #include <array/InteropDataBuffer.h>
	' #include <memory/MemoryCounter.h>
	' #include <array/ConstantShapeBuffer.h>




'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public native @ByVal NDArray mmul(@Const @ByRef NDArray arg0, @Const @ByRef NDArray arg1);
		NDArray mmul( NDArray arg0, @ByRef NDArray arg1)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class NDArray extends Pointer
		public static class NDArray extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDArray(Pointer p)
			If True Then
				MyBase(p)
			End If

			public NDArray()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			''' <summary>
			'''  do not allocate memory, memory for array is passed from outside
			''' </summary>
	' #ifndef __JAVACPP_HACK__

	' #endif

			''' <summary>
			'''  do not allocate memory, memory for array is passed from outside
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") LongPointer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, LongPointer shapeInfo, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") LongPointer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, LongPointer shapeInfo, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") LongPointer shapeInfo)
			public NDArray(Pointer buffer, LongPointer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") LongPointer shapeInfo);
			private native void allocate(Pointer buffer, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") LongBuffer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, LongBuffer shapeInfo, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") LongBuffer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, LongBuffer shapeInfo, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") LongBuffer shapeInfo)
			public NDArray(Pointer buffer, LongBuffer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") LongBuffer shapeInfo);
			private native void allocate(Pointer buffer, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") long[] shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, Long() shapeInfo, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") long[] shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, Long() shapeInfo, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, @Cast("Nd4jLong*") long[] shapeInfo)
			public NDArray(Pointer buffer, Long() shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, @Cast("Nd4jLong*") long[] shapeInfo);
			private native void allocate(Pointer buffer, Long() shapeInfo)

			''' <summary>
			'''  do not allocate memory, memory for array is passed from outside
			'''  we suppose the content of both (device and host) buffers is identical
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongPointer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc)
			public NDArray(Pointer buffer, Pointer bufferD, LongPointer shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo, context, isBuffAlloc, isBuffDAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongPointer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc);
			private native void allocate(Pointer buffer, Pointer bufferD, LongPointer shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongPointer shapeInfo)
			public NDArray(Pointer buffer, Pointer bufferD, LongPointer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongPointer shapeInfo);
			private native void allocate(Pointer buffer, Pointer bufferD, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongBuffer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc)
			public NDArray(Pointer buffer, Pointer bufferD, LongBuffer shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo, context, isBuffAlloc, isBuffDAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongBuffer shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc);
			private native void allocate(Pointer buffer, Pointer bufferD, LongBuffer shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongBuffer shapeInfo)
			public NDArray(Pointer buffer, Pointer bufferD, LongBuffer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") LongBuffer shapeInfo);
			private native void allocate(Pointer buffer, Pointer bufferD, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") long[] shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc)
			public NDArray(Pointer buffer, Pointer bufferD, Long() shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo, context, isBuffAlloc, isBuffDAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") long[] shapeInfo, LaunchContext context, @Cast("bool") boolean isBuffAlloc, @Cast("bool") boolean isBuffDAlloc);
			private native void allocate(Pointer buffer, Pointer bufferD, Long() shapeInfo, LaunchContext context, Boolean isBuffAlloc, Boolean isBuffDAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") long[] shapeInfo)
			public NDArray(Pointer buffer, Pointer bufferD, Long() shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, bufferD, shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, Pointer bufferD, @Cast("const Nd4jLong*") long[] shapeInfo);
			private native void allocate(Pointer buffer, Pointer bufferD, Long() shapeInfo)

			''' <summary>
			'''  copy constructor
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Const @ByRef NDArray other)
			public NDArray( NDArray other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArray other);
			private native void allocate( NDArray other)

			''' <summary>
			'''  move constructor
			''' </summary>

			''' <summary>
			'''  constructor, create array stored at given workspace
			''' </summary>
			public NDArray(LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(context)
			End If
			private native void allocate(LaunchContext context)


			''' <summary>
			'''  constructor creates new NDArray using shape information from "shapeInfo", set all elements in new array to zeros, if copyStrides is true then use stride values from "shapeInfo", else calculate strides independently
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( LongPointer shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( LongPointer shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongPointer shapeInfo)
			public NDArray( LongPointer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo);
			private native void allocate( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( LongBuffer shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( LongBuffer shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongBuffer shapeInfo)
			public NDArray( LongBuffer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
			private native void allocate( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( Long() shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( Long() shapeInfo, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") long[] shapeInfo)
			public NDArray( Long() shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo);
			private native void allocate( Long() shapeInfo)

			''' <summary>
			'''  constructor creates new NDArray using shape information from "shapeInfo", set all elements in new array to be zeros, if copyStrides is true then use stride values from "shapeInfo", else calculate strides independently
			'''  set dtype as array type
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( LongPointer shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( LongPointer shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("sd::DataType") int dtype)
			public NDArray( LongPointer shapeInfo, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("sd::DataType") int dtype);
			private native void allocate( LongPointer shapeInfo, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( LongBuffer shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( LongBuffer shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("sd::DataType") int dtype)
			public NDArray( LongBuffer shapeInfo, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("sd::DataType") int dtype);
			private native void allocate( LongBuffer shapeInfo, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify)
			public NDArray( Long() shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype, copyStrides, context, nullify)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("sd::DataType") int dtype, @Cast("bool") boolean copyStrides, LaunchContext context, @Cast("bool") boolean nullify);
			private native void allocate( Long() shapeInfo, Integer dtype, Boolean copyStrides, LaunchContext context, Boolean nullify)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("sd::DataType") int dtype)
			public NDArray( Long() shapeInfo, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("sd::DataType") int dtype);
			private native void allocate( Long() shapeInfo, Integer dtype)

			''' <summary>
			'''  this constructor creates new array using shape information contained in vector argument
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector LongPointer shape, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector LongPointer shape, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape)
			public NDArray(Char order, @StdVector LongPointer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape);
			private native void allocate(Char order, @StdVector LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector LongBuffer shape, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector LongBuffer shape, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape)
			public NDArray(Char order, @StdVector LongBuffer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape);
			private native void allocate(Char order, @StdVector LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector Long() shape, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector Long() shape, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector long[] shape)
			public NDArray(Char order, @StdVector Long() shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector long[] shape);
			private native void allocate(Char order, @StdVector Long() shape)

			''' <summary>
			''' This constructor creates new array with elements copied from data and using shape information stored in shape, elements from data will be casted to dtype
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @StdVector DoublePointer data, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector LongPointer shape, DoublePointer data, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @StdVector DoublePointer data, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector LongPointer shape, DoublePointer data, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @StdVector DoublePointer data)
			public NDArray(Char order, @StdVector LongPointer shape, DoublePointer data)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @StdVector DoublePointer data);
			private native void allocate(Char order, @StdVector LongPointer shape, DoublePointer data)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @StdVector DoubleBuffer data, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector LongBuffer shape, DoubleBuffer data, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @StdVector DoubleBuffer data, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector LongBuffer shape, DoubleBuffer data, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @StdVector DoubleBuffer data)
			public NDArray(Char order, @StdVector LongBuffer shape, DoubleBuffer data)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @StdVector DoubleBuffer data);
			private native void allocate(Char order, @StdVector LongBuffer shape, DoubleBuffer data)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @StdVector double[] data, @Cast("sd::DataType") int dtype, LaunchContext context)
			public NDArray(Char order, @StdVector Long() shape, Double() data, Integer dtype, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data, dtype, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @StdVector double[] data, @Cast("sd::DataType") int dtype, LaunchContext context);
			private native void allocate(Char order, @StdVector Long() shape, Double() data, Integer dtype, LaunchContext context)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @StdVector double[] data)
			public NDArray(Char order, @StdVector Long() shape, Double() data)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(order, shape, data)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(char order, @Cast("Nd4jLong*") @StdVector long[] shape, @StdVector double[] data);
			private native void allocate(Char order, @StdVector Long() shape, Double() data)

			''' <summary>
			'''  this constructor creates new array using given buffer (without memory allocation) and shape information stored in shape
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, Char order, @StdVector LongPointer shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, Char order, @StdVector LongPointer shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype)
			public NDArray(Pointer buffer, Char order, @StdVector LongPointer shape, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("sd::DataType") int dtype);
			private native void allocate(Pointer buffer, Char order, @StdVector LongPointer shape, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, Char order, @StdVector LongBuffer shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, Char order, @StdVector LongBuffer shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype)
			public NDArray(Pointer buffer, Char order, @StdVector LongBuffer shape, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("sd::DataType") int dtype);
			private native void allocate(Pointer buffer, Char order, @StdVector LongBuffer shape, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc)
			public NDArray(Pointer buffer, Char order, @StdVector Long() shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype, context, isBuffAlloc)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype, LaunchContext context, @Cast("const bool") boolean isBuffAlloc);
			private native void allocate(Pointer buffer, Char order, @StdVector Long() shape, Integer dtype, LaunchContext context, Boolean isBuffAlloc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype)
			public NDArray(Pointer buffer, Char order, @StdVector Long() shape, Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(buffer, order, shape, dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer buffer, char order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("sd::DataType") int dtype);
			private native void allocate(Pointer buffer, Char order, @StdVector Long() shape, Integer dtype)

			''' <summary>
			''' This method returns new array with the same shape & data type
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray like();
			public native NDArray [like]()

			''' <summary>
			''' This method returns new uninitialized array with the same shape & data type
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray ulike();
			public native NDArray ulike()


			''' <summary>
			'''  this constructor creates new NDArray with shape matching "other" array,
			'''  doesn't copy "other" elements into new array !!!
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Const NDArray other, @Cast("bool") boolean copyStrides, LaunchContext context)
			public NDArray( NDArray other, Boolean copyStrides, LaunchContext context)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other, copyStrides, context)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const NDArray other, @Cast("bool") boolean copyStrides, LaunchContext context);
			private native void allocate( NDArray other, Boolean copyStrides, LaunchContext context)

			''' <summary>
			'''  this constructor creates scalar(and set its value = 0) or empty array depending on bool argument isScalar
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("sd::DataType") int dtype, LaunchContext context, @Cast("bool") boolean isScalar)
			public NDArray( Integer dtype, LaunchContext context, Boolean isScalar)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(dtype, context, isScalar)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("sd::DataType") int dtype, LaunchContext context, @Cast("bool") boolean isScalar);
			private native void allocate( Integer dtype, LaunchContext context, Boolean isScalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArray(@Cast("sd::DataType") int dtype)
			public NDArray( Integer dtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(dtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("sd::DataType") int dtype);
			private native void allocate( Integer dtype)

			''' <summary>
			''' This method blocks until asynchronous operation finishes
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void synchronize(@Cast("char*") String msg);
			public native void synchronize( String msg)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void synchronize(@Cast("char*") BytePointer msg);
			public native void synchronize( BytePointer msg)

			''' <summary>
			''' This method allows to set _isAttached flag </summary>
			''' <param name="reallyAttached"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setAttached(@Cast("bool") boolean reallyAttached);
			public native void setAttached( Boolean reallyAttached)

			public native void tickWriteHost()
			public native void tickWriteDevice()
			public native void tickReadHost()
			public native void tickReadDevice()
			public native void tickBothActual()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isActualOnHostSide();
			public native Boolean isActualOnHostSide()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isActualOnDeviceSide();
			public native Boolean isActualOnDeviceSide()
			public native void makeBothBuffersActual()

			public native void syncToHost()
			public native void syncToDevice()
			public native void syncShape()

			''' <summary>
			''' This method can be used on architectures that use special buffers </summary>
			''' <param name="writeList"> </param>
			''' <param name="readList"> </param>
			nullValue = "std::vector<const sd::NDArray*>({})"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void registerSpecialUse(@Const @ByRef ConstNDArrayVector writeList, @Const @ByRef(nullValue = "std::vector<const sd::NDArray*>({})") ConstNDArrayVector readList);
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
			public native void registerSpecialUse( ConstNDArrayVector writeList, @ByRef(nullValue) ConstNDArrayVector readList)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void registerSpecialUse(@Const @ByRef ConstNDArrayVector writeList);
			public native void registerSpecialUse( ConstNDArrayVector writeList)
			nullValue = "std::vector<const sd::NDArray*>({})"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void prepareSpecialUse(@Const @ByRef ConstNDArrayVector writeList, @Const @ByRef(nullValue = "std::vector<const sd::NDArray*>({})") ConstNDArrayVector readList, @Cast("bool") boolean synchronizeWritables);
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
			public native void prepareSpecialUse( ConstNDArrayVector writeList, @ByRef(nullValue) ConstNDArrayVector readList, Boolean synchronizeWritables)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void prepareSpecialUse(@Const @ByRef ConstNDArrayVector writeList);
			public native void prepareSpecialUse( ConstNDArrayVector writeList)

			nullValue = "std::vector<const sd::NDArray*>({})"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void registerPrimaryUse(@Const @ByRef ConstNDArrayVector writeList, @Const @ByRef(nullValue = "std::vector<const sd::NDArray*>({})") ConstNDArrayVector readList);
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
			public native void registerPrimaryUse( ConstNDArrayVector writeList, @ByRef(nullValue) ConstNDArrayVector readList)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void registerPrimaryUse(@Const @ByRef ConstNDArrayVector writeList);
			public native void registerPrimaryUse( ConstNDArrayVector writeList)
			nullValue = "std::vector<const sd::NDArray*>({})"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void preparePrimaryUse(@Const @ByRef ConstNDArrayVector writeList, @Const @ByRef(nullValue = "std::vector<const sd::NDArray*>({})") ConstNDArrayVector readList, @Cast("bool") boolean synchronizeWritables);
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
			public native void preparePrimaryUse( ConstNDArrayVector writeList, @ByRef(nullValue) ConstNDArrayVector readList, Boolean synchronizeWritables)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void preparePrimaryUse(@Const @ByRef ConstNDArrayVector writeList);
			public native void preparePrimaryUse( ConstNDArrayVector writeList)

			''' <summary>
			''' This method returns buffer pointer offset by given number of elements, wrt own data type </summary>
			''' <param name="offset">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer bufferWithOffset(@Cast("Nd4jLong") long offset);
			public native Pointer bufferWithOffset( Long offset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Pointer specialBufferWithOffset(@Cast("Nd4jLong") long offset);
			public native Pointer specialBufferWithOffset( Long offset)
			''' <summary>
			'''  copy assignment operator
			'''  in particular, when _dataType != other._dataType and both shapes are the same, there will be allocation of new _buffer and _dataType acquires other._dataType
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") NDArray put(@Const @ByRef NDArray other);
			public native @Name("operator =") NDArray put( NDArray other)

			''' <summary>
			'''  move assignment operator
			''' </summary>

			''' <summary>
			'''  assignment operator, assigns the same scalar to all array elements
			''' </summary>


			''' <summary>
			'''   operators for memory allocation and deletion
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator new") Pointer _new(@Cast("size_t") long i);
			public native Pointer _new( Long i)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator delete") void _delete(Pointer p);
			public native void _delete(Pointer p)


			public native void setContext(LaunchContext context)

			''' <summary>
			'''  create a new array by replicating current array by repeats times along given dimension
			'''  axis - axis along which to repeat elements
			'''  repeats - number of repetitions
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray repeat(int axis, @StdVector IntPointer repeats);
			public native NDArray repeat(Integer axis, IntPointer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray repeat(int axis, @StdVector IntBuffer repeats);
			public native NDArray repeat(Integer axis, IntBuffer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray repeat(int axis, @StdVector int[] repeats);
			public native NDArray repeat(Integer axis, Integer() repeats)

			''' <summary>
			''' This method fills this array with zeros
			''' </summary>
			public native void nullify()

			''' <summary>
			''' This method returns quantized copy of given array
			''' </summary>
			''' <param name="array">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray quantize(@Const @ByRef NDArray array);
			public native NDArray quantize( NDArray array)

			''' <summary>
			'''  fill target array by repeating current array
			'''  axis - axis along which to repeat elements
			'''  repeats - vector containing numbers of repetition for elements at given axis
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void repeat(int axis, @StdVector IntPointer repeats, @ByRef NDArray target);
			public native void repeat(Integer axis, IntPointer repeats, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void repeat(int axis, @StdVector IntBuffer repeats, @ByRef NDArray target);
			public native void repeat(Integer axis, IntBuffer repeats, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void repeat(int axis, @StdVector int[] repeats, @ByRef NDArray target);
			public native void repeat(Integer axis, Integer() repeats, NDArray target)

			''' <summary>
			'''  creates array which points on certain sub-range of this array, sub-range is defined by given indices
			''' </summary>




			''' <summary>
			'''  cast array elements to given dtype
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray cast(@Cast("sd::DataType") int dtype);
			public native NDArray cast( Integer dtype)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void cast(@ByRef NDArray target, @Cast("sd::DataType") int dtype);
			public native void cast( NDArray target, Integer dtype)

			''' <summary>
			'''   returns _context
			''' </summary>
			public native LaunchContext getContext()

	' #ifndef __JAVACPP_HACK__
	' #endif

			''' <summary>
			'''   returns host buffer
			''' </summary>
			public native Pointer buffer()


			''' <summary>
			'''   returns buffer offset (offset is the same for host and device buffers)
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long bufferOffset();
			public native Long bufferOffset()

			''' <summary>
			'''  checks if array has padded buffer
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasPaddedBuffer();
			public native Boolean hasPaddedBuffer()

			''' <summary>
			'''  if _bufferD==nullptr return _buffer, else return _bufferD
			''' </summary>
			public native Pointer specialBuffer()

			''' <summary>
			'''   returns device buffer if compilation is for cuda case, otherwise returns host buffer
			''' </summary>
			public native Pointer platformBuffer()

			''' <summary>
			'''   returns _shapeInfo
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer shapeInfo();
			public native LongPointer shapeInfo()


			''' <summary>
			''' Returns True if it's legally empty NDArray, or false otherwise
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isEmpty();
			public native Boolean isEmpty()

			''' <summary>
			'''  if _shapeInfoD==nullptr return _shapeInfo, else return _shapeInfoD
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer specialShapeInfo();
			public native LongPointer specialShapeInfo()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer platformShapeInfo();
			public native LongPointer platformShapeInfo()

			''' <summary>
			'''  permutes (in-place) the dimensions in array according to "dimensions" array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@StdVector IntPointer dimensions);
			public native Boolean permutei( IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@StdVector IntBuffer dimensions);
			public native Boolean permutei( IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@StdVector int[] dimensions);
			public native Boolean permutei( Integer() dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Const IntPointer dimensions, int rank);
			public native Boolean permutei( IntPointer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Const IntBuffer dimensions, int rank);
			public native Boolean permutei( IntBuffer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Const int[] dimensions, int rank);
			public native Boolean permutei( Integer() dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("Nd4jLong*") @StdVector LongPointer dimensions);
			public native Boolean permutei( LongPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("Nd4jLong*") @StdVector LongBuffer dimensions);
			public native Boolean permutei( LongBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("Nd4jLong*") @StdVector long[] dimensions);
			public native Boolean permutei( Long() dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("const Nd4jLong*") LongPointer dimensions, int rank);
			public native Boolean permutei( LongPointer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("const Nd4jLong*") LongBuffer dimensions, int rank);
			public native Boolean permutei( LongBuffer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean permutei(@Cast("const Nd4jLong*") long[] dimensions, int rank);
			public native Boolean permutei( Long() dimensions, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isFinite();
			public native Boolean isFinite()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasNaNs();
			public native Boolean hasNaNs()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasInfs();
			public native Boolean hasInfs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void copyBuffersContinuouslyFrom(@Const @ByRef NDArray other, @Cast("size_t") long sizeToCopyInBytes, @Cast("Nd4jLong") long offsetThis, @Cast("Nd4jLong") long offsetOther);
			public native void copyBuffersContinuouslyFrom( NDArray other, Long sizeToCopyInBytes, Long offsetThis, Long offsetOther)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void copyBuffersContinuouslyFrom(@Const @ByRef NDArray other);
			public native void copyBuffersContinuouslyFrom( NDArray other)

			''' <summary>
			'''  permutes the dimensions in array according to "dimensions" array, new array points on _buffer of this array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@StdVector IntPointer dimensions);
			public native NDArray permute( IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@StdVector IntBuffer dimensions);
			public native NDArray permute( IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@StdVector int[] dimensions);
			public native NDArray permute( Integer() dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Const IntPointer dimensions, int rank);
			public native NDArray permute( IntPointer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Const IntBuffer dimensions, int rank);
			public native NDArray permute( IntBuffer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Const int[] dimensions, int rank);
			public native NDArray permute( Integer() dimensions, Integer rank)




'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Const IntPointer dimensions, int rank, @ByRef NDArray target);
			public native void permute( IntPointer dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Const IntBuffer dimensions, int rank, @ByRef NDArray target);
			public native void permute( IntBuffer dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Const int[] dimensions, int rank, @ByRef NDArray target);
			public native void permute( Integer() dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@StdVector IntPointer dimensions, @ByRef NDArray target);
			public native void permute( IntPointer dimensions, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@StdVector IntBuffer dimensions, @ByRef NDArray target);
			public native void permute( IntBuffer dimensions, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@StdVector int[] dimensions, @ByRef NDArray target);
			public native void permute( Integer() dimensions, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("Nd4jLong*") @StdVector LongPointer dimensions);
			public native NDArray permute( LongPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("Nd4jLong*") @StdVector LongBuffer dimensions);
			public native NDArray permute( LongBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("Nd4jLong*") @StdVector long[] dimensions);
			public native NDArray permute( Long() dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("const Nd4jLong*") LongPointer dimensions, int rank);
			public native NDArray permute( LongPointer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("const Nd4jLong*") LongBuffer dimensions, int rank);
			public native NDArray permute( LongBuffer dimensions, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray permute(@Cast("const Nd4jLong*") long[] dimensions, int rank);
			public native NDArray permute( Long() dimensions, Integer rank)




'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("const Nd4jLong*") LongPointer dimensions, int rank, @ByRef NDArray target);
			public native void permute( LongPointer dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("const Nd4jLong*") LongBuffer dimensions, int rank, @ByRef NDArray target);
			public native void permute( LongBuffer dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("const Nd4jLong*") long[] dimensions, int rank, @ByRef NDArray target);
			public native void permute( Long() dimensions, Integer rank, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("Nd4jLong*") @StdVector LongPointer dimensions, @ByRef NDArray target);
			public native void permute( LongPointer dimensions, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("Nd4jLong*") @StdVector LongBuffer dimensions, @ByRef NDArray target);
			public native void permute( LongBuffer dimensions, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void permute(@Cast("Nd4jLong*") @StdVector long[] dimensions, @ByRef NDArray target);
			public native void permute( Long() dimensions, NDArray target)

			''' <summary>
			''' This method streamlines given view or permuted array, and reallocates buffer
			''' </summary>
			public native void streamline(Char order)
			public native void streamline()

			''' <summary>
			'''  prints information about array shape
			'''  msg - message to print out
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printShapeInfo(@Cast("char*") String msg);
			public native void printShapeInfo( String msg)
			public native void printShapeInfo()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printShapeInfo(@Cast("char*") BytePointer msg);
			public native void printShapeInfo( BytePointer msg)

			''' <summary>
			'''  prints buffer elements
			'''  msg - message to print out
			'''  limit - number of array elements to print out
			'''  sync - if true check whether host buffer is actual, if it is not then make it so
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printBuffer(@Cast("char*") String msg, @Cast("Nd4jLong") long _limit, @Cast("const bool") boolean sync);
			public native void printBuffer( String msg, Long _limit, Boolean sync)
			public native void printBuffer()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printBuffer(@Cast("char*") BytePointer msg, @Cast("Nd4jLong") long _limit, @Cast("const bool") boolean sync);
			public native void printBuffer( BytePointer msg, Long _limit, Boolean sync)

			''' <summary>
			''' print element by element consequently in a way they (elements) are stored in physical memory
			''' </summary>
			public native void printLinearBuffer()

			''' <summary>
			'''  prints _buffer (if host = true) or _bufferD (if host = false) as it is, that is in current state without checking buffer status
			''' </summary>

			''' <summary>
			'''  prints buffer elements, takes into account offset between elements (element-wise-stride)
			'''  msg - message to print out
			'''  limit - number of array elements to print out
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printIndexedBuffer(@Cast("char*") String msg, @Cast("Nd4jLong") long _limit);
			public native void printIndexedBuffer( String msg, Long _limit)
			public native void printIndexedBuffer()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void printIndexedBuffer(@Cast("char*") BytePointer msg, @Cast("Nd4jLong") long _limit);
			public native void printIndexedBuffer( BytePointer msg, Long _limit)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer asIndexedString(@Cast("Nd4jLong") long _limit);
			public native BytePointer asIndexedString( Long _limit)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer asIndexedString();
			public native BytePointer asIndexedString()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer asString(@Cast("Nd4jLong") long _limit);
			public native BytePointer asString( Long _limit)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer asString();
			public native BytePointer asString()

			''' <summary>
			'''  this method assigns values of given array to this one
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void assign(@Const NDArray other, @Cast("bool") boolean allowParallelism);
			public native void assign( NDArray other, Boolean allowParallelism)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void assign(@Const NDArray other);
			public native void assign( NDArray other)

			''' <summary>
			'''  this method assigns values of given array to this one
			''' </summary>

			''' <summary>
			'''  this method assigns given value to all elements in array
			''' </summary>

			''' <summary>
			'''  returns new copy of this array, optionally in different order
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray dup(byte newOrder);
			public native NDArray dup(SByte newOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray dup();
			public native NDArray dup()

			''' <summary>
			'''  returns sum of all elements of array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray sumNumber();
			public native NDArray sumNumber()

			''' <summary>
			'''  returns mean number of array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray meanNumber();
			public native NDArray meanNumber()

	' #ifndef __JAVACPP_HACK__

	' #endif

			''' <summary>
			'''   apply transpose operation to the copy of this array, that is this array remains unaffected
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray transpose();
			public native NDArray transpose()


			''' <summary>
			'''  perform transpose operation and store result in target, this array remains unaffected
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void transpose(@ByRef NDArray target);
			public native void transpose( NDArray target)

			''' <summary>
			'''  apply in-place transpose operation to this array, so this array becomes transposed
			''' </summary>
			public native void transposei()

			''' <summary>
			'''  returns the number of arrays pointing on specified dimension(s)
			'''  dimensions - array of dimensions to point on
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long tensorsAlongDimension(@StdVector IntPointer dimensions);
			public native Long tensorsAlongDimension( IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long tensorsAlongDimension(@StdVector IntBuffer dimensions);
			public native Long tensorsAlongDimension( IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long tensorsAlongDimension(@StdVector int[] dimensions);
			public native Long tensorsAlongDimension( Integer() dimensions)

			''' <summary>
			'''  returns true if elements of two arrays are equal to within given epsilon value
			'''  other - input array to compare
			'''  eps - epsilon, this value defines the precision of elements comparison
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean equalsTo(@Const NDArray other, double eps);
			public native Boolean equalsTo( NDArray other, Double eps)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean equalsTo(@Const NDArray other);
			public native Boolean equalsTo( NDArray other)

			''' <summary>
			'''  add given row vector to all rows of this array
			'''  row - row vector to add
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addiRowVector(@Const @ByRef NDArray row);
			public native void addiRowVector( NDArray row)

			''' <summary>
			'''  add given row vector to all rows of this array, store result in target
			'''  row - row vector to add
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addRowVector(@Const @ByRef NDArray row, @ByRef NDArray target);
			public native void addRowVector( NDArray row, NDArray target)

			''' <summary>
			'''  subtract given row vector from all rows of this array, store result in target
			'''  row - row vector to subtract
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void subRowVector(@Const @ByRef NDArray row, @ByRef NDArray target);
			public native void subRowVector( NDArray row, NDArray target)

			''' <summary>
			'''  multiply all rows of this array on given row vector, store result in target
			'''  row - row vector to multiply on
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void mulRowVector(@Const @ByRef NDArray row, @ByRef NDArray target);
			public native void mulRowVector( NDArray row, NDArray target)

			''' <summary>
			'''  divide all rows of this array on given row vector, store result in target
			'''  row - row vector to divide on
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void divRowVector(@Const @ByRef NDArray row, @ByRef NDArray target);
			public native void divRowVector( NDArray row, NDArray target)

			''' <summary>
			'''  add given column vector to all columns of this array, store result in target
			'''  column - column vector to add
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addColumnVector(@Const @ByRef NDArray column, @ByRef NDArray target);
			public native void addColumnVector( NDArray column, NDArray target)

			''' <summary>
			'''  add given column vector to all columns of this array, this array becomes affected (in-place operation)
			'''  column - column vector to add
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addiColumnVector(@Const @ByRef NDArray column);
			public native void addiColumnVector( NDArray column)

			''' <summary>
			'''  multiply all columns of this array on given column vector, this array becomes affected (in-place operation)
			'''  column - column vector to multiply on
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void muliColumnVector(@Const @ByRef NDArray column);
			public native void muliColumnVector( NDArray column)

			''' <summary>
			'''  returns number of bytes used by _buffer & _shapeInfo
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long memoryFootprint();
			public native Long memoryFootprint()

			''' <summary>
			'''  these methods suited for FlatBuffers use
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer getShapeAsVector();
			public native @StdVector LongPointer getShapeAsVector()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector IntPointer getShapeAsVectorInt();
			public native IntPointer getShapeAsVectorInt()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer getShapeInfoAsVector();
			public native @StdVector LongPointer getShapeInfoAsVector()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("int64_t*") @StdVector LongPointer getShapeInfoAsFlatVector();
			public native @StdVector LongPointer getShapeInfoAsFlatVector()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("int64_t*") @StdVector LongPointer getShapeAsFlatVector();
			public native @StdVector LongPointer getShapeAsFlatVector()

			''' <summary>
			'''  set new order and shape in case of suitable array length (in-place operation)
			'''  order - order to set
			'''  shape - shape to set
			'''  copyToNewBuff - if true then old buffer will be copied to new buffer if last one will be allocated after reshaping
			'''  if there was permute applied before or there are weird strides, then new buffer is allocated for array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei(SByte order, @StdVector LongPointer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape);
			public native Boolean reshapei(SByte order, @StdVector LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei(SByte order, @StdVector LongBuffer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape);
			public native Boolean reshapei(SByte order, @StdVector LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei(SByte order, @StdVector Long() shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(byte order, @Cast("Nd4jLong*") @StdVector long[] shape);
			public native Boolean reshapei(SByte order, @StdVector Long() shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei( LongPointer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector LongPointer shape);
			public native Boolean reshapei( LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei( LongBuffer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector LongBuffer shape);
			public native Boolean reshapei( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector long[] shape, @Cast("const bool") boolean copyToNewBuff);
			public native Boolean reshapei( Long() shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean reshapei(@Cast("Nd4jLong*") @StdVector long[] shape);
			public native Boolean reshapei( Long() shape)

			''' <summary>
			'''  creates new array with corresponding order and shape, new array will point on _buffer of this array
			'''  order - order to set
			'''  shape - shape to set
			''' 
			''' if permute have been applied before or there are weird strides, then new buffer is allocated for new array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("const bool") boolean copyToNewBuff);
			public native NDArray reshape(SByte order, @StdVector LongPointer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape);
			public native NDArray reshape(SByte order, @StdVector LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("const bool") boolean copyToNewBuff);
			public native NDArray reshape(SByte order, @StdVector LongBuffer shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape);
			public native NDArray reshape(SByte order, @StdVector LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("const bool") boolean copyToNewBuff);
			public native NDArray reshape(SByte order, @StdVector Long() shape, Boolean copyToNewBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray reshape(byte order, @Cast("Nd4jLong*") @StdVector long[] shape);
			public native NDArray reshape(SByte order, @StdVector Long() shape)


			''' <summary>
			'''  calculate strides and set given order
			'''  order - order to set
			''' </summary>
			public native void updateStrides(SByte order)

			''' <summary>
			'''  change an array by repeating it the number of times given by reps (in-place operation)
			'''  repeats - contains numbers of repetitions
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tilei(@Cast("Nd4jLong*") @StdVector LongPointer repeats);
			public native void tilei( LongPointer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tilei(@Cast("Nd4jLong*") @StdVector LongBuffer repeats);
			public native void tilei( LongBuffer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tilei(@Cast("Nd4jLong*") @StdVector long[] repeats);
			public native void tilei( Long() repeats)

			''' <summary>
			'''  returns new array which is created by repeating of this array the number of times given by reps
			'''  repeats - contains numbers of repetitions
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tile(@Cast("Nd4jLong*") @StdVector LongPointer repeats);
			public native NDArray tile( LongPointer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tile(@Cast("Nd4jLong*") @StdVector LongBuffer repeats);
			public native NDArray tile( LongBuffer repeats)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tile(@Cast("Nd4jLong*") @StdVector long[] repeats);
			public native NDArray tile( Long() repeats)

			''' <summary>
			'''  change an array by repeating it the number of times given by reps (in-place operation)
			'''  repeats - contains numbers of repetitions
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tile(@Cast("Nd4jLong*") @StdVector LongPointer repeats, @ByRef NDArray target);
			public native void tile( LongPointer repeats, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tile(@Cast("Nd4jLong*") @StdVector LongBuffer repeats, @ByRef NDArray target);
			public native void tile( LongBuffer repeats, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tile(@Cast("Nd4jLong*") @StdVector long[] repeats, @ByRef NDArray target);
			public native void tile( Long() repeats, NDArray target)

			''' <summary>
			'''  change an array by repeating it the number of times to acquire the new shape which is the same as target shape
			'''  target - where to store result
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tile(@ByRef NDArray target);
			public native void tile( NDArray target)

			''' <summary>
			'''  check whether array is identity matrix
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isIdentityMatrix();
			public native Boolean isIdentityMatrix()

			''' <summary>
			'''  check whether array is unitary matrix
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isUnitary();
			public native Boolean isUnitary()

			''' <summary>
			'''  operator returns subarray with buffer pointing at this->_buffer with offset defined by given intervals
			'''  idx - intervals of indexes which define the subarrays to point on, idx has form {dim0Start,dim0End,  dim1Start,dim1End, ....} and length (2 * this->rankOf())
			'''        when (dimStart == dimEnd) then whole range will be used for current dimension
			'''  keepUnitiesInShape - if false then eliminate unities from resulting array shape, for example {1,a,1,b} -> {a,b}
			'''  isStrided - if true then idx has length (3 * this->rankOf()) and contains additional stride numbers which correspond to stride between dimStart and dimEnd,
			'''              so structure of idx is like {dim0Start,dim0End,dim0Stride,    dim1Start,dim1End,dim1Stride, ....}
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector LongPointer idx, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided);
			public native @Name("operator ()") NDArray apply( LongPointer idx, Boolean keepUnitiesInShape, Boolean isStrided)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector LongPointer idx);
			public native @Name("operator ()") NDArray apply( LongPointer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector LongBuffer idx, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided);
			public native @Name("operator ()") NDArray apply( LongBuffer idx, Boolean keepUnitiesInShape, Boolean isStrided)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector LongBuffer idx);
			public native @Name("operator ()") NDArray apply( LongBuffer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector long[] idx, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided);
			public native @Name("operator ()") NDArray apply( Long() idx, Boolean keepUnitiesInShape, Boolean isStrided)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("Nd4jLong*") @StdVector long[] idx);
			public native @Name("operator ()") NDArray apply( Long() idx)

			''' <summary>
			'''  evaluates subarray with buffer pointing at this->_buffer and offset defined by given sequential index subArrIdx and dimensions in dimsToExclude
			'''  subArrIdx - index of current sub-array
			'''  dimsToExclude - MUST BE SORTED, dimensions to evaluate sub-array along, i.e. when shape is [2,3,4,5] and dimsToExclude={0,2}, then there will be 8 sub-arrays with shape [3,5], and subArrIdx must be in range [0,7]
			'''                  if dimsToExclude is empty then idxRanges containing all zeros (means whole array) will be returned.
			'''  keepUnitiesInShape - if false then eliminate unities from resulting array shape, for example {1,a,1,b} -> {a,b}
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector IntPointer dimsToExclude, @Cast("bool") boolean keepUnitiesInShape);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, IntPointer dimsToExclude, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector IntPointer dimsToExclude);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, IntPointer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector IntBuffer dimsToExclude, @Cast("bool") boolean keepUnitiesInShape);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, IntBuffer dimsToExclude, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector IntBuffer dimsToExclude);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, IntBuffer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector int[] dimsToExclude, @Cast("bool") boolean keepUnitiesInShape);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, Integer() dimsToExclude, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator ()") NDArray apply(@Cast("const Nd4jLong") long subArrIdx, @StdVector int[] dimsToExclude);
			public native @Name("operator ()") NDArray apply( Long subArrIdx, Integer() dimsToExclude)

			''' <summary>
			''' processes whole set of sub-arrays
			''' evaluates shapeInfo of sub-arrays (all sub-arrays have the same shapeInfo) and their buffer offsets (each sub-array has its own unique offset from original this-buffer)
			''' dimsToExclude - MUST BE SORTED, dimensions to evaluate sub-array along, i.e. when shape is [2,3,4,5] and dimsToExclude={0,2}, then there will be 8 sub-arrays with shape [3,5]
			'''                 if dimsToExclude.size() = array rank it means sub-array is whole array and copy of original_shapeInfo will be returned and one zero offset
			''' subArrShapeInfo    - output argument, contains shapeInfo common for all sub-arrays
			''' subArrOffsets      - output argument, contains successive sub-arrays offsets from original this-buffer
			''' keepUnitiesInShape - if false then eliminate unities from sub-array shapeInfo, for example {1,a,1,b} -> {a,b}
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector IntPointer dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef LongPointer subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongPointer subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
			public native void getSubArrShapeAndOffsets( IntPointer dimsToExclude, @ByPtrRef LongPointer subArrShapeInfo, @ByPtrRef LongPointer subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector IntPointer dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef LongPointer subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongPointer subArrOffsets);
			public native void getSubArrShapeAndOffsets( IntPointer dimsToExclude, @ByPtrRef LongPointer subArrShapeInfo, @ByPtrRef LongPointer subArrOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector IntBuffer dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
			public native void getSubArrShapeAndOffsets( IntBuffer dimsToExclude, @ByPtrRef LongBuffer subArrShapeInfo, @ByPtrRef LongBuffer subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector IntBuffer dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer subArrOffsets);
			public native void getSubArrShapeAndOffsets( IntBuffer dimsToExclude, @ByPtrRef LongBuffer subArrShapeInfo, @ByPtrRef LongBuffer subArrOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector int[] dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef long[] subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef long[] subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
			public native void getSubArrShapeAndOffsets( Integer() dimsToExclude, @ByPtrRef Long() subArrShapeInfo, @ByPtrRef Long() subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void getSubArrShapeAndOffsets(@StdVector int[] dimsToExclude, @Cast("Nd4jLong*&") @ByPtrRef long[] subArrShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef long[] subArrOffsets);
			public native void getSubArrShapeAndOffsets( Integer() dimsToExclude, @ByPtrRef Long() subArrShapeInfo, @ByPtrRef Long() subArrOffsets)

			''' <summary>
			'''  addition unary operator array += other
			'''  other - input array to add
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator +=") void addPut(@Const @ByRef NDArray other);
			public native void addPut( NDArray other)

			''' <summary>
			'''  subtraction unary operator array -= other
			'''  other - input array to add
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator -=") void subtractPut(@Const @ByRef NDArray other);
			public native void subtractPut( NDArray other)

			''' <summary>
			'''  negative operator, it changes sign of all array elements on opposite
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal @Name("operator -") NDArray subtract();
			public native @Name("operator -") NDArray subtract()


			''' <summary>
			'''  pairwise multiplication unary operator array *= other
			'''  other - input array to multiply on
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator *=") void multiplyPut(@Const @ByRef NDArray other);
			public native void multiplyPut( NDArray other)

			''' <summary>
			'''  multiplication unary operator array *= scalar
			'''  scalar - input scalar to multiply on
			''' </summary>

			''' <summary>
			'''  pairwise division unary operator: array /= other
			'''  other - input array to divide on
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator /=") void dividePut(@Const @ByRef NDArray other);
			public native void dividePut( NDArray other)

			''' <summary>
			'''  division unary operator: array /= scalar
			'''  scalar - input scalar to divide on
			''' </summary>

			''' <summary>
			'''  friend function which implements mathematical multiplication of two arrays
			'''  left - input array
			'''  right - input array
			''' </summary>


			''' <summary>
			'''  return vector containing _buffer as flat binary array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector BytePointer asByteVector();
			public native BytePointer asByteVector()

			''' <summary>
			'''  makes array to be identity matrix (not necessarily square), that is set all diagonal elements = 1, rest = 0
			''' </summary>
			public native void setIdentity()

			''' <summary>
			'''  swaps the contents of tow arrays,
			'''  PLEASE NOTE: method doesn't take into account the shapes of arrays, shapes may be different except one condition: arrays lengths must be the same
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void swapUnsafe(@ByRef NDArray other);
			public native void swapUnsafe( NDArray other)

			''' <summary>
			'''  return vector with buffer which points on corresponding diagonal elements of array
			'''  type - means of vector to be returned: column ('c') or row ('r')
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray diagonal(byte type);
			public native NDArray diagonal(SByte type)

			''' <summary>
			''' fill target matrix with given value in one or two directions from main diagonal:
			'''   - down from main diagonal starting at subdiagonal number "lower" if direction = 'l' (down) or 'b' (both)
			'''   - up from main diagonal starting at superdiagonal number "upper"if direction = 'u' (up) or 'b' (both)
			''' direction - in what direction to fill matrix. There are 3 possible directions:
			'''   'u' - fill up, mathematically this corresponds to lower triangular matrix, subdiagonal "lower" unaffected
			'''   'l' - fill down, mathematically this corresponds to upper triangular matrix, superdiagonal "upper" remains unaffected
			'''   'b' - fill in both directions, both "lower" and "upper" are taken into account
			''' rest of target elements are equal to this array elements
			''' target and this array should have same shapes, except when this_rank = 1 (in that case should be target_rank = 2)
			''' </summary>

			''' <summary>
			'''  change an array by repeating it the number of times in order to acquire new shape equal to the input shape
			'''      
			'''  shape  - contains new shape to broadcast array to
			'''  target - optional argument, if target != nullptr the resulting array will be placed in target, in opposite case tile operation is done in place
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tileToShape(@Cast("const Nd4jLong*") LongPointer shapeInfo);
			public native NDArray tileToShape( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tileToShape(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
			public native NDArray tileToShape( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray tileToShape(@Cast("const Nd4jLong*") long[] shapeInfo);
			public native NDArray tileToShape( Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tileToShape(@Cast("Nd4jLong*") @StdVector LongPointer shape, @ByRef NDArray target);
			public native void tileToShape( LongPointer shape, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tileToShape(@Cast("Nd4jLong*") @StdVector LongBuffer shape, @ByRef NDArray target);
			public native void tileToShape( LongBuffer shape, NDArray target)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void tileToShape(@Cast("Nd4jLong*") @StdVector long[] shape, @ByRef NDArray target);
			public native void tileToShape( Long() shape, NDArray target)
	' #ifndef __JAVACPP_HACK__
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray asT(@Cast("sd::DataType") int dtype);
			public native NDArray asT( Integer dtype)


			public native void linspace(Double start)

			public native void linspace(Double start, Double [step])

			''' <summary>
			'''  calculates the trace of an array, that is sum of elements on main diagonal = sum array[i, i, i, ...]
			''' </summary>
			public native Double getTrace()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet multipleTensorsAlongDimension(@StdVector IntPointer indices, @StdVector IntPointer dimensions);
			public native ResultSet multipleTensorsAlongDimension( IntPointer indices, IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet multipleTensorsAlongDimension(@StdVector IntBuffer indices, @StdVector IntBuffer dimensions);
			public native ResultSet multipleTensorsAlongDimension( IntBuffer indices, IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet multipleTensorsAlongDimension(@StdVector int[] indices, @StdVector int[] dimensions);
			public native ResultSet multipleTensorsAlongDimension( Integer() indices, Integer() dimensions)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet allTensorsAlongDimension(@StdVector IntPointer dimensions);
			public native ResultSet allTensorsAlongDimension( IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet allTensorsAlongDimension(@StdVector IntBuffer dimensions);
			public native ResultSet allTensorsAlongDimension( IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet allTensorsAlongDimension(@StdVector int[] dimensions);
			public native ResultSet allTensorsAlongDimension( Integer() dimensions)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet allExamples();
			public native ResultSet allExamples()

			''' <summary>
			'''  set _shapeInfo
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") LongPointer shapeInfo);
			public native void setShapeInfo( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
			public native void setShapeInfo( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") long[] shapeInfo);
			public native void setShapeInfo( Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const sd::DataType") int dtype);
			public native void setShapeInfo( LongPointer shapeInfo, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const sd::DataType") int dtype);
			public native void setShapeInfo( LongBuffer shapeInfo, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const sd::DataType") int dtype);
			public native void setShapeInfo( Long() shapeInfo, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Const @ByRef ShapeDescriptor descriptor);
			public native void setShapeInfo( ShapeDescriptor descriptor)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeInfo(@Const @ByRef ConstantShapeBuffer shapeBuffer);
			public native void setShapeInfo( ConstantShapeBuffer shapeBuffer)

			''' <summary>
			'''  returns absolute offset which corresponds to given sequential index
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong") long i);
			public native Long getOffset( Long i)

			''' <summary>
			'''  returns reference on array element with given index
			''' </summary>


			''' <summary>
			'''  returns array element with given index
			'''  i - element index in array
			''' </summary>


			''' <summary>
			'''  default destructor
			''' </summary>

			''' <summary>
			'''  set _shapeInfo
			''' </summary>

			''' <summary>
			'''  returns the value of "dim" dimension
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long sizeAt(int dim);
			public native Long sizeAt(Integer [dim])

			''' <summary>
			'''  returns stride of "dim" dimension
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long strideAt(int dim);
			public native Long strideAt(Integer [dim])

			''' <summary>
			'''  returns order of array
			''' </summary>
			public native Char ordering()

			''' <summary>
			'''  return _isView
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isView();
			public native Boolean isView()

			''' <summary>
			'''  returns shape portion of shapeInfo
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer shapeOf();
			public native LongPointer shapeOf()

			''' <summary>
			'''  returns strides portion of shapeInfo
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer stridesOf();
			public native LongPointer stridesOf()

			''' <summary>
			'''  returns rank of array
			''' </summary>
			public native Integer rankOf()

			''' <summary>
			'''  returns length of array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long lengthOf();
			public native Long lengthOf()

			''' <summary>
			'''  returns number of rows in array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long rows();
			public native Long rows()

			''' <summary>
			'''  returns number of columns in array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long columns();
			public native Long columns()

			''' <summary>
			'''  returns size of array elements type
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long sizeOfT();
			public native Long sizeOfT()

			''' <summary>
			'''  returns element-wise-stride
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long ews();
			public native Long ews()

			' returns true if arrays have same shape
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameShape(@Const NDArray other);
			public native Boolean isSameShape( NDArray other)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameShape(@Cast("Nd4jLong*") @StdVector LongPointer shape);
			public native Boolean isSameShape( LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameShape(@Cast("Nd4jLong*") @StdVector LongBuffer shape);
			public native Boolean isSameShape( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameShape(@Cast("Nd4jLong*") @StdVector long[] shape);
			public native Boolean isSameShape( Long() shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean areSameShapeAndType(@Const @ByRef NDArray other);
			public native Boolean areSameShapeAndType( NDArray other)

			''' <summary>
			'''  returns true if these two NDArrays have same rank, dimensions, strides, ews and order
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameShapeStrict(@Const @ByRef NDArray other);
			public native Boolean isSameShapeStrict( NDArray other)

			''' <summary>
			'''  returns true if buffer && shapeInfo were defined (non nullptr)
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean nonNull();
			public native Boolean nonNull()

			''' <summary>
			'''  returns array element with given index from linear buffer
			'''  i - element index in array
			''' </summary>

			''' <summary>
			'''  returns element with given indexes from 2D array
			'''  i - number of row
			'''  j - number of column
			''' </summary>

			''' <summary>
			'''  returns element with given indexes from 3D array
			'''  i - height
			'''  j - width
			'''  k - depth
			''' </summary>

			''' <summary>
			'''  returns element with given indexes from DD array
			''' </summary>

			''' <summary>
			'''  returns array-scalar containing element of this array with given index
			'''  i - element index in array
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal NDArray e(@Cast("const Nd4jLong") long i);
			public native NDArray e( Long i)

			''' <summary>
			'''  assigns given scalar to array element by given index, regards array buffer as linear
			'''  i - element index in array
			'''  value - scalar value to assign
			''' </summary>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void p(@Cast("const Nd4jLong") long i, @Const @ByRef NDArray value);
			public native void p( Long i, @ByRef NDArray value)

			''' <summary>
			'''  assigns given scalar to 2D array element by given indexes
			'''  i - number of row
			'''  j - number of row
			'''  value - scalar value to assign
			''' </summary>

			''' <summary>
			'''  assigns given scalar to 3D array element by given indexes
			'''  i - height
			'''  j - width
			'''  k - depth
			'''  value - scalar value to assign
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void p(@Cast("const Nd4jLong") long i, @Cast("const Nd4jLong") long j, @Cast("const Nd4jLong") long k, @Cast("const Nd4jLong") long l, @Const @ByRef NDArray value);
			public native void p( Long i, Long j, Long k, Long l, @ByRef NDArray value)

			''' <summary>
			'''  returns true if array is 2D
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isMatrix();
			public native Boolean isMatrix()

			''' <summary>
			'''  returns true if array is vector
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isVector();
			public native Boolean isVector()

			''' <summary>
			'''  returns true if array is column vector
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isColumnVector();
			public native Boolean isColumnVector()

			''' <summary>
			'''  returns true if array is row vector
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isRowVector();
			public native Boolean isRowVector()

			''' <summary>
			'''  returns true if all dimensions of array except one are unities, for example: [1,1,n,1], [n,1,1], [n], ...
			'''  posOfNonUnityDim - one dimension with value > 1
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isCommonVector(@ByRef IntPointer posOfNonUnityDim);
			public native Boolean isCommonVector( IntPointer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isCommonVector(@ByRef IntBuffer posOfNonUnityDim);
			public native Boolean isCommonVector( IntBuffer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isCommonVector(@ByRef int[] posOfNonUnityDim);
			public native Boolean isCommonVector( Integer() posOfNonUnityDim)


			''' <summary>
			'''  returns true if array is scalar
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isScalar();
			public native Boolean isScalar()

			''' <summary>
			''' Returns data type of this array
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType();
			public native Integer dataType()

			''' <summary>
			''' This method returns true if value is from Integer space
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isZ();
			public native Boolean isZ()

			''' <summary>
			''' This method returns true if array is from Real space
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isR();
			public native Boolean isR()

			''' <summary>
			''' This method returns true if array is from Boolean space
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isB();
			public native Boolean isB()

			''' <summary>
			''' This method returns true if array contains Complex numbers
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isC();
			public native Boolean isC()

			''' <summary>
			''' This method returns true if array contains String
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isS();
			public native Boolean isS()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isAttached();
			public native Boolean isAttached()

			public native NDArray detach()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef NDArray other);
			public native @Name("operator ==") Boolean Equals( NDArray other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef NDArray other);
			public native @Name("operator !=") Boolean notEquals( NDArray other)
		End If




	'////////////////////////////////////////////////////////////////////////
	'/// IMLEMENTATION OF INLINE METHODS /////
	'////////////////////////////////////////////////////////////////////////




	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////



	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////



	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////
	' still the definition of inline function must be in header file


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////
	' returns true if these two NDArrays have same _shapeInfo
	' still the definition of inline function must be in header file



	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////






	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	' #ifndef __JAVACPP_HACK__
	' #endif

	'//////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////


	'//////////////////////////////////////////////////////////////////////



	' #if defined(__CUDACC__) //&& defined(BUILD_TESTS)
	' for CUDA we need stil stuff inline
	' #include <array/NDArrayLambda.hXX>
	' #endif



	' #endif


	' Parsed from array/NDArrayList.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' This class describes collection of NDArrays
	'
	' @author raver119!gmail.com
	'

	' #ifndef NDARRAY_LIST_H
	' #define NDARRAY_LIST_H

	' #include <string>
	' #include <atomic>
	' #include <unordered_map>
	' #include <array/NDArray.h>
	' #include <memory/Workspace.h>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class NDArrayList extends Pointer
		public static class NDArrayList extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public NDArrayList(Pointer p)
			If True Then
				MyBase(p)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NDArrayList(int height, @Cast("bool") boolean expandable)
			public NDArrayList(Integer height, Boolean expandable)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(height, expandable)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int height, @Cast("bool") boolean expandable);
			private native void allocate(Integer height, Boolean expandable)
			public NDArrayList(Integer height)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(height)
			End If
			private native void allocate(Integer height)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType();
			public native Integer dataType()

			public native NDArray read(Integer idx)
			public native NDArray readRaw(Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int write(int idx, NDArray array);
			public native Integer write(Integer idx, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray pick(@StdVector IntPointer indices);
			public native NDArray pick( IntPointer indices)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray pick(@StdVector IntBuffer indices);
			public native NDArray pick( IntBuffer indices)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray pick(@StdVector int[] indices);
			public native NDArray pick( Integer() indices)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isWritten(int index);
			public native Boolean isWritten(Integer index)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer shape();
			public native @StdVector LongPointer shape()

			public native NDArray stack()
			public native void unstack(NDArray array, Integer axis)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef IntIntPair id();
			public native IntIntPair id()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString @ByRef @Cast({"char*", "std::string*"}) BytePointer name();
			public native @ByRef BytePointer name()
			'sd::memory::Workspace* workspace();
			public native LaunchContext context()
			public native NDArrayList MemberwiseClone()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean equals(@ByRef NDArrayList other);
			public native Boolean Equals( NDArrayList other)

			public native Integer elements()
			public native Integer height()

			public native Integer counter()
		End If


	' #endif

	' Parsed from array/ResultSet.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' This class is suited for execution results representation.
	'
	' PLESE NOTE: It will delete all stored NDArrays upon destructor call
	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_RESULTSET_H
	' #define LIBND4J_RESULTSET_H

	' #include <vector>
	' #include <graph/generated/result_generated.h>
	' #include <system/pointercast.h>
	' #include <system/dll.h> // forward declaration of template class NDArray

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ResultSet extends Pointer
		public static class ResultSet extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ResultSet(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ResultSet(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ResultSet position(Long position)
			If True Then
				Return CType(MyBase.position(position), ResultSet)
			End If
			public ResultSet getPointer(Long i)
			If True Then
				Return (New ResultSet(CType(Me, Pointer))).position(position + i)
			End If

			public ResultSet()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

	' #ifndef __JAVACPP_HACK__
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ResultSet(@Const @ByRef ResultSet other)
			public ResultSet( ResultSet other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @NoException private native void allocate(@Const @ByRef ResultSet other);
			private native void allocate( ResultSet other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") @NoException ResultSet put(@Const @ByRef ResultSet other);
			public native @Name("operator =") ResultSet put( ResultSet other)

			' move constructor

			' move assignment operator

			public native Integer size()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray at(@Cast("const unsigned long") long idx);
			public native NDArray at( Long idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Name("operator []") NDArray get(@Cast("const unsigned long") long idx);
			public native NDArray get( Long idx)
			public native void push_back(NDArray array)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int status();
			public native Integer status()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setStatus(@Cast("Nd4jStatus") int status);
			public native void setStatus( Integer status)
			public native void purge()
			public native void setNonRemovable()
		End If


	' #endif //LIBND4J_RESULTSET_H


	' Parsed from graph/RandomGenerator.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@protonmail.com
	'

	' #ifndef LIBND4J_GRAPH_RNG_H
	' #define LIBND4J_GRAPH_RNG_H

	' #include <types/u64.h>
	' #include <types/u32.h>
	' #include <system/pointercast.h>
	' #include <system/op_boilerplate.h>
	' #include <system/dll.h>
	' #include <chrono>
	' #include <array/DataTypeUtils.h>
	' #include <helpers/logger.h>
	' #include <stdexcept>
	' #include <math/templatemath.h>

	' #ifdef __CUDACC__
	' #endif
	' #ifdef __CUDACC__
	' #else
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class RandomGenerator extends Pointer
			public static class RandomGenerator extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public RandomGenerator(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public RandomGenerator(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public RandomGenerator position(Long position)
				If True Then
					Return CType(MyBase.position(position), RandomGenerator)
				End If
				public RandomGenerator getPointer(Long i)
				If True Then
					Return (New RandomGenerator(CType(Me, Pointer))).position(position + i)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint32_t") int xoroshiro32(@Cast("uint64_t") long index);
				public native Integer xoroshiro32( Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long xoroshiro64(@Cast("uint64_t") long index);
				public native Long xoroshiro64( Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public RandomGenerator(@Cast("Nd4jLong") long rootSeed, @Cast("Nd4jLong") long nodeSeed)
				public RandomGenerator( Long rootSeed, Long nodeSeed)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(rootSeed, nodeSeed)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long rootSeed, @Cast("Nd4jLong") long nodeSeed);
				private native void allocate( Long rootSeed, Long nodeSeed)
				public RandomGenerator()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

				''' <summary>
				''' This method allows to change graph-level state in runtime.
				''' PLEASE NOTE: this method will change state of node as well.
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setStates(@Cast("Nd4jLong") long rootSeed, @Cast("Nd4jLong") long nodeState);
				public native void setStates( Long rootSeed, Long nodeState)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setStates(@Cast("Nd4jLong") long rootSeed);
				public native void setStates( Long rootSeed)



				''' <summary>
				''' This method returns T value between from and to
				''' </summary>

				''' <summary>
				''' This method returns T value between 0 and MAX_T
				''' </summary>

				''' <summary>
				''' These two methods are made for JVM </summary>
				''' <param name="index">
				''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int relativeInt(@Cast("Nd4jLong") long index);
				public native Integer relativeInt( Long index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long relativeLong(@Cast("Nd4jLong") long index);
				public native Long relativeLong( Long index)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void rewindH(@Cast("uint64_t") long steps);
				public native void rewindH( Long steps)

				''' <summary>
				''' These methods set up only node states, with non-changed root ones
				''' </summary>
				public native void setSeed(Integer seed)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setSeed(@Cast("uint64_t") long seed);
				public native void setSeed( Long seed)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long rootState();
				public native Long rootState()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long nodeState();
				public native Long nodeState()
			End If

































			'////
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") public native @Cast("uint32_t") int rotl(@Cast("const uint32_t") int x, int k);
			Integer rotl( Integer x, Integer k)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") public native @Cast("uint64_t") long rotl(@Cast("const uint64_t") long x, int k);
			Long rotl( Long x, Integer k)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") public native @Cast("uint32_t") int next(@Cast("uint32_t") int s0, @Cast("uint32_t") int s1, @Cast("uint32_t") int s2, @Cast("uint32_t") int s3);
			Integer [next]( Integer s0, Integer s1, Integer s2, Integer s3)









	' #endif


	' Parsed from graph/Variable.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_VARIABLE_H
	' #define LIBND4J_VARIABLE_H

	' #include <string>
	' #include <array/NDArray.h>
	' #include <array/NDArrayList.h>
	' #include <graph/VariableType.h>
	' #include <graph/generated/array_generated.h>
	' #include <graph/generated/node_generated.h>
	' #include <graph/generated/graph_generated.h>

	' #ifndef __JAVACPP_HACK__

	' #endif
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class Variable extends Pointer
			public static class Variable extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Variable(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Variable(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Variable position(Long position)
				If True Then
					Return CType(MyBase.position(position), Variable)
				End If
				public Variable getPointer(Long i)
				If True Then
					Return (New Variable(CType(Me, Pointer))).position(position + i)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(@Cast("bool") boolean placeHolder)
				public Variable( Boolean placeHolder)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(placeHolder)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("bool") boolean placeHolder);
				private native void allocate( Boolean placeHolder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray arrayw, @Cast("char*") String name, int id, int idx)
				public Variable(NDArray arrayw, String name, Integer id, Integer idx)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(arrayw, name, id, idx)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray arrayw, @Cast("char*") String name, int id, int idx);
				private native void allocate(NDArray arrayw, String name, Integer id, Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray arrayw, @Cast("char*") String name, int id)
				public Variable(NDArray arrayw, String name, Integer id)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(arrayw, name, id)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray arrayw, @Cast("char*") String name, int id);
				private native void allocate(NDArray arrayw, String name, Integer id)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray arrayw, @Cast("char*") BytePointer name, int id, int idx)
				public Variable(NDArray arrayw, BytePointer name, Integer id, Integer idx)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(arrayw, name, id, idx)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray arrayw, @Cast("char*") BytePointer name, int id, int idx);
				private native void allocate(NDArray arrayw, BytePointer name, Integer id, Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray arrayw, @Cast("char*") BytePointer name, int id)
				public Variable(NDArray arrayw, BytePointer name, Integer id)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(arrayw, name, id)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray arrayw, @Cast("char*") BytePointer name, int id);
				private native void allocate(NDArray arrayw, BytePointer name, Integer id)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray array, @Cast("char*") String name)
				public Variable(NDArray array, String name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(array, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray array, @Cast("char*") String name);
				private native void allocate(NDArray array, String name)
				public Variable()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Variable(NDArray array, @Cast("char*") BytePointer name)
				public Variable(NDArray array, BytePointer name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(array, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(NDArray array, @Cast("char*") BytePointer name);
				private native void allocate(NDArray array, BytePointer name)

	' #ifndef __JAVACPP_HACK__
	' #endif

				public native Variable MemberwiseClone()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasNDArray();
				public native Boolean hasNDArray()
				public native NDArray getNDArray()
				public native void setNDArray(NDArray array)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasNDArrayList();
				public native Boolean hasNDArrayList()
				public native NDArrayList getNDArrayList()
				public native void setNDArrayList(NDArrayList list)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isExternal();
				public native Boolean isExternal()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isReadOnly();
				public native Boolean isReadOnly()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isEmpty();
				public native Boolean isEmpty()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isRemovable();
				public native Boolean isRemovable()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isPlaceholder();
				public native Boolean isPlaceholder()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::graph::VariableType") int variableType();
				public native Integer variableType()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setVariableType(@Cast("sd::graph::VariableType") int variableType);
				public native void setVariableType( Integer variableType)

				''' <summary>
				''' This method returns InputType of this variable  
				''' </summary>
				'InputType variableType() {
				'    return _variableType;
				'}

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markExternal(@Cast("bool") boolean reallyExternal);
				public native void markExternal( Boolean reallyExternal)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markReadOnly(@Cast("bool") boolean reallyReadOnly);
				public native void markReadOnly( Boolean reallyReadOnly)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markRemovable(@Cast("bool") boolean reallyRemovable);
				public native void markRemovable( Boolean reallyRemovable)

				public native Integer id()
				public native Integer index()
				public native void setIndex(Integer index)
				public native void setId(Integer id)
				public native void setId(Integer id, Integer idx)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString @Cast({"char*", "std::string*"}) BytePointer getName();
				public native @Cast({"char*", "std::string*"}) BytePointer getName()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setName(@StdString @Cast({"char*", "std::string*"}) BytePointer name);
				public native void setName( BytePointer name)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer shape();
				public native @StdVector LongPointer shape()

	' #ifndef __JAVACPP_HACK__
	' #endif
			End If




	' #endif //LIBND4J_VARIABLE_H


	' Parsed from graph/VariablesSet.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 15/11/17.
	'

	' #ifndef LIBND4J_VARIABLESSET_H
	' #define LIBND4J_VARIABLESSET_H

	' #include <iterator>
	' #include <vector>
	' #include <system/pointercast.h>
	' #include <system/dll.h>
	' #include <graph/Variable.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class VariablesSet extends Pointer
			public static class VariablesSet extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public VariablesSet(Pointer p)
				If True Then
					MyBase(p)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public VariablesSet(@Cast("Nd4jStatus") int status)
				public VariablesSet( Integer status)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(status)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jStatus") int status);
				private native void allocate( Integer status)
				public VariablesSet()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int status();
				public native Integer status()

				public native Integer size()

				public native void push_back(Variable variable)

				public native Variable at(Integer index)

			End If





	' #endif //LIBND4J_VARIABLESSET_H


	' Parsed from graph/FlowPath.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 16/11/17.
	'

	' #ifndef LIBND4J_FLOWPATH_H
	' #define LIBND4J_FLOWPATH_H

	' #include <system/op_boilerplate.h>
	' #include <unordered_map>
	' #include <map>
	' #include <system/pointercast.h>
	' #include <graph/NodeState.h>
	' #include <graph/FrameState.h>
	' #include <graph/profiling/GraphProfile.h>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class FlowPath extends Pointer
			public static class FlowPath extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public FlowPath(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public FlowPath(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public FlowPath position(Long position)
				If True Then
					Return CType(MyBase.position(position), FlowPath)
				End If
				public FlowPath getPointer(Long i)
				If True Then
					Return (New FlowPath(CType(Me, Pointer))).position(position + i)
				End If

				public FlowPath()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInnerTime(int nodeId, @Cast("Nd4jLong") long time);
				public native void setInnerTime(Integer nodeId, Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOuterTime(int nodeId, @Cast("Nd4jLong") long time);
				public native void setOuterTime(Integer nodeId, Long time)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long innerTime(int nodeId);
				public native Long innerTime(Integer nodeId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long outerTime(int nodeId);
				public native Long outerTime(Integer nodeId)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isNodeActive(int nodeId);
				public native Boolean isNodeActive(Integer nodeId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markNodeActive(int nodeId, @Cast("bool") boolean isActive);
				public native void markNodeActive(Integer nodeId, Boolean isActive)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean wasExecuted(int nodeId);
				public native Boolean wasExecuted(Integer nodeId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markExecuted(int nodeId, @Cast("bool") boolean wasExecuted);
				public native void markExecuted(Integer nodeId, Boolean wasExecuted)

				public native Integer branch(Integer nodeId)
				public native void markBranch(Integer nodeId, Integer index)

				' Frame-related methods

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void registerFrame(@Cast("Nd4jLong") long frameId);
				public native void registerFrame( Long frameId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void forgetFrame(@Cast("Nd4jLong") long frameId);
				public native void forgetFrame( Long frameId)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isFrameActive(@Cast("Nd4jLong") long frameId);
				public native Boolean isFrameActive( Long frameId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markFrameActive(@Cast("Nd4jLong") long frameId, @Cast("bool") boolean isActive);
				public native void markFrameActive( Long frameId, Boolean isActive)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isRewindPlanned(@Cast("Nd4jLong") long frameId);
				public native Boolean isRewindPlanned( Long frameId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void planRewind(@Cast("Nd4jLong") long frameId, @Cast("bool") boolean reallyRewind);
				public native void planRewind( Long frameId, Boolean reallyRewind)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int getRewindPosition(@Cast("Nd4jLong") long frameId);
				public native Integer getRewindPosition( Long frameId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRewindPosition(@Cast("Nd4jLong") long frameId, int _position);
				public native void setRewindPosition( Long frameId, Integer _position)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRewindPositionOnce(@Cast("Nd4jLong") long frameId, int _position);
				public native void setRewindPositionOnce( Long frameId, Integer _position)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void incrementNumberOfCycles(@Cast("Nd4jLong") long frameId);
				public native void incrementNumberOfCycles( Long frameId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getNumberOfCycles(@Cast("Nd4jLong") long frameId);
				public native Long getNumberOfCycles( Long frameId)

				public native GraphProfile profile()
			End If




	' #endif //LIBND4J_FLOWPATH_H


	' Parsed from graph/Intervals.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by yurii@skymind.io on 24.10.2017.
	'

	' #ifndef LIBND4J_INTERVALS_H
	' #define LIBND4J_INTERVALS_H

	' #include <system/pointercast.h>
	' #include <vector>
	' #include <initializer_list>
	' #include <system/dll.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class Intervals extends Pointer
		public static class Intervals extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public Intervals(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public Intervals(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public Intervals position(Long position)
			If True Then
				Return CType(MyBase.position(position), Intervals)
			End If
			public Intervals getPointer(Long i)
			If True Then
				Return (New Intervals(CType(Me, Pointer))).position(position + i)
			End If


			' default constructor
			public Intervals()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			' constructor
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Intervals(@Const @ByRef LongVectorVector content)
			public Intervals( LongVectorVector content)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(content)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef LongVectorVector content);
			private native void allocate( LongVectorVector content)

			' accessing operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector @Name("operator []") LongPointer get(@Cast("const Nd4jLong") long i);
			public native @StdVector LongPointer get( Long i)

			' returns size of _content
			public native Integer size()

		End If




	' #endif //LIBND4J_INTERVALS_H


	' Parsed from graph/Stash.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_STASH_H
	' #define LIBND4J_STASH_H

	'#include <graph/Block.h>
	' #include <array/NDArray.h>
	' #include <map>
	' #include <vector>
	' #include <string>
	' #include <atomic>
	' #include <functional>
	' #include <system/pointercast.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class KeyPair extends Pointer
			public static class KeyPair extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public KeyPair(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public KeyPair(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public KeyPair position(Long position)
				If True Then
					Return CType(MyBase.position(position), KeyPair)
				End If
				public KeyPair getPointer(Long i)
				If True Then
					Return (New KeyPair(CType(Me, Pointer))).position(position + i)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public KeyPair(int node, @Cast("char*") String name)
				public KeyPair(Integer node, String name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(node, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int node, @Cast("char*") String name);
				private native void allocate(Integer node, String name)
				public KeyPair()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public KeyPair(int node, @Cast("char*") BytePointer name)
				public KeyPair(Integer node, BytePointer name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(node, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int node, @Cast("char*") BytePointer name);
				private native void allocate(Integer node, BytePointer name)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef KeyPair other);
				public native @Name("operator <") Boolean lessThan( KeyPair other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef KeyPair other);
				public native @Name("operator ==") Boolean Equals( KeyPair other)

				public native Integer key()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer name();
				public native BytePointer name()
			End If



	' #ifndef __JAVACPP_HACK__

	' #endif
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class Stash extends Pointer
			public static class Stash extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Stash(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Stash(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Stash position(Long position)
				If True Then
					Return CType(MyBase.position(position), Stash)
				End If
				public Stash getPointer(Long i)
				If True Then
					Return (New Stash(CType(Me, Pointer))).position(position + i)
				End If

				public Stash()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

				'void storeArray(sd::graph::Block<T>& block, const char *name, sd::NDArray<T> *array);
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void storeArray(int nodeId, @Cast("char*") String name, NDArray array);
				public native void storeArray(Integer nodeId, String name, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void storeArray(int nodeId, @Cast("char*") BytePointer name, NDArray array);
				public native void storeArray(Integer nodeId, BytePointer name, NDArray array)

				'bool checkStash(sd::graph::Block<T>& block, const char *name);
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean checkStash(int nodeId, @Cast("char*") String name);
				public native Boolean checkStash(Integer nodeId, String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean checkStash(int nodeId, @Cast("char*") BytePointer name);
				public native Boolean checkStash(Integer nodeId, BytePointer name)

				'sd::NDArray<T>* extractArray(sd::graph::Block<T>& block, const char *name);
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray extractArray(int nodeId, @Cast("char*") String name);
				public native NDArray extractArray(Integer nodeId, String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray extractArray(int nodeId, @Cast("char*") BytePointer name);
				public native NDArray extractArray(Integer nodeId, BytePointer name)

				public native void clear()
			End If







	' #endif //LIBND4J_STASH_H


	' Parsed from graph/GraphState.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 23.01.18.
	'

	' #ifndef LIBND4J_GRAPHSTATE_H
	' #define LIBND4J_GRAPHSTATE_H

	' #include <system/pointercast.h>
	' #include <system/op_boilerplate.h>
	' #include <system/dll.h>
	' #include <vector>
	' #include <unordered_map>
	' #include <map>
	' #include <graph/Scope.h>
	' #include <graph/Status.h>
	' #include <graph/VariableSpace.h>
	' #include <ops/declarable/DeclarableOp.h>
	' #include <types/pair.h>
	' #include <graph/ArgumentsList.h>
	' #include <graph/Graph.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class GraphState extends Pointer
		public static class GraphState extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public GraphState(Pointer p)
			If True Then
				MyBase(p)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public GraphState(@Cast("Nd4jLong") long id)
			public GraphState( Long id)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(id)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long id);
			private native void allocate( Long id)

			''' 
			''' <summary>
			''' @return
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long id();
			public native Long id()

			''' <summary>
			''' This method adds scope to this state tracker
			''' </summary>
			''' <param name="scopeId">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int registerScope(int scopeId);
			public native Integer registerScope(Integer scopeId)

			''' <summary>
			''' This method cheks if scope with given ID exists
			''' </summary>
			''' <param name="scopeId"> - ID of the scope </param>
			''' <returns> - TRUE if scope exists, FALSE otherwise </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasScope(int scopeId);
			public native Boolean hasScope(Integer scopeId)

			''' <summary>
			''' This method removes specified scope from this state tracker
			''' </summary>
			''' <param name="scopeId">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int forgetScope(int scopeId);
			public native Integer forgetScope(Integer scopeId)

	' #ifndef __JAVACPP_HACK__
	' #endif
			''' <summary>
			''' This method adds given op to the end of specified scope
			''' </summary>
			''' <param name="scopeId"> </param>
			''' <param name="opNum"> </param>
			''' <param name="type">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int attachOpToScope(int scopeId, @Cast("Nd4jLong") long opNum, int type, @ByVal ArgumentsList inputs);
			public native Integer attachOpToScope(Integer scopeId, Long opNum, Integer type, ArgumentsList inputs)

			''' <summary>
			''' This method adds return statement to specified scope
			''' 
			''' PLEASE NOTE: should be used only in body scopes
			''' </summary>
			''' <param name="scopeId"> </param>
			''' <param name="nodeId"> </param>
			''' <param name="args">
			''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int defineReturn(int scopeId, int nodeId, @ByVal ArgumentsList args);
			public native Integer defineReturn(Integer scopeId, Integer nodeId, ArgumentsList args)

			''' <summary>
			''' This method returns current variable space of this state holder
			''' 
			''' @return
			''' </summary>
			public native VariableSpace variableSpace()
		End If





	' #endif //LIBND4J_GRAPHSTATE_H


	' Parsed from graph/VariableSpace.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_VARIABLESPACE_H
	' #define LIBND4J_VARIABLESPACE_H

	' #include <helpers/logger.h>
	' #include <helpers/helper_random.h>
	' #include <string>
	' #include <vector>
	' #include <list>
	' #include <unordered_map>
	' #include <mutex>
	' #include <array/NDArray.h>
	' #include <array/NDArrayList.h>
	' #include <graph/Variable.h>
	' #include <memory/Workspace.h>
	' #include <graph/Stash.h>
	' #include <graph/FlowPath.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class VariableSpace extends Pointer
			public static class VariableSpace extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public VariableSpace(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public VariableSpace(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public VariableSpace position(Long position)
				If True Then
					Return CType(MyBase.position(position), VariableSpace)
				End If
				public VariableSpace getPointer(Long i)
				If True Then
					Return (New VariableSpace(CType(Me, Pointer))).position(position + i)
				End If

				public VariableSpace()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") VariableSpace put(@Const @ByRef VariableSpace other);
				public native @Name("operator =") VariableSpace put( VariableSpace other)

				public native Integer numberOfPlaceholders()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::graph::Variable**") @StdVector PointerPointer getPlaceholders();
				public native @StdVector PointerPointer getPlaceholders()
				public native void setWorkspace(Workspace workspace)

				public native LaunchContext launchContext()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasExternalVariable(int it);
				public native Boolean hasExternalVariable(Integer it)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasExternalVariable(@ByRef IntIntPair pair);
				public native Boolean hasExternalVariable( IntIntPair pair)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasExternalVariable(@StdString @Cast({"char*", "std::string*"}) BytePointer symbol);
				public native Boolean hasExternalVariable( BytePointer symbol)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasVariable(int id);
				public native Boolean hasVariable(Integer id)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasVariable(int id, int idx);
				public native Boolean hasVariable(Integer id, Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasVariable(@ByRef IntIntPair pair);
				public native Boolean hasVariable( IntIntPair pair)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasVariable(@StdString @Cast({"char*", "std::string*"}) BytePointer symbol);
				public native Boolean hasVariable( BytePointer symbol)

				public native Variable getVariable(Integer id)
				public native Variable getVariable(Integer id, Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Variable getVariable(@ByRef IntIntPair pair);
				public native Variable getVariable( IntIntPair pair)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Variable getVariable(@StdString @Cast({"char*", "std::string*"}) BytePointer symbol);
				public native Variable getVariable( BytePointer symbol)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::graph::Variable**") @StdVector PointerPointer getVariables();
				public native @StdVector PointerPointer getVariables()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Variable putVariable(@ByRef IntIntPair pair, NDArray array);
				public native Variable putVariable( IntIntPair pair, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void putVariable(@ByRef IntIntPair pair, Variable variable);
				public native void putVariable( IntIntPair pair, Variable variable)
				public native void putVariable(Integer id, Variable variable)
				public native void putVariable(Integer id, NDArray array)
				public native Variable putVariable(Integer id, Integer idx, NDArray array)
				public native void putVariable(Integer id, Integer idx, Variable array)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void dropVariable(@ByRef IntIntPair pair);
				public native void dropVariable( IntIntPair pair)
				public native void dropVariable(Integer id, Integer idx)

				public native void trackList(NDArrayList list)

				public native void putOutputVariable(Variable variable)

				public native void replaceVariable(Variable variable)

				' memory-related statistics
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long externalMemory();
				public native Long externalMemory()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long internalMemory();
				public native Long internalMemory()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long totalMemory();
				public native Long totalMemory()

				public native Integer externalEntries()
				public native Integer internalEntries()
				public native Integer totalEntries()

				public native VariableSpace MemberwiseClone()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::graph::Variable**") @StdVector PointerPointer handles();
				public native @StdVector PointerPointer [handles]()


				public native VariableSpace asT()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void injectVariable(@ByRef IntIntPair pair, Variable variable);
				public native void injectVariable( IntIntPair pair, Variable variable)

				public native Stash getStash()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::graph::Variable**") @StdVector PointerPointer getExternalVariables();
				public native @StdVector PointerPointer getExternalVariables()

				public native void setFlowPath(FlowPath timers)
				public native FlowPath flowPath()
			End If




	' #endif //LIBND4J_VARIABLESPACE_H


	' Parsed from helpers/helper_generator.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HELPER_GENERATOR_H
	' #define LIBND4J_HELPER_GENERATOR_H

	' #include <system/op_boilerplate.h>
	' #include <system/pointercast.h>
	' #include <array/DataTypeUtils.h>
	' #include <system/dll.h>

	' #ifdef _MSC_VER
	' include for uint64_t on MSVC
	' #include <stdint.h>
	' #elif ANDROID
	' #include <stdint.h>

	' #ifndef UINT64_C
	' #if defined(__LP64__)
	' #define UINT64_C(c)     c ## UL
	' #else
	' #define UINT64_C(c)     c ## ULL
	' #endif //LP64
	' #endif // UINT64

	' #endif // MSVC/ANDROID


	' #ifdef __GNUC__
	' #include <inttypes.h>
	' #endif

	' #ifdef __CUDACC__
	' #else
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::random") @NoOffset public static class RandomBuffer extends Pointer
			public static class RandomBuffer extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public RandomBuffer(Pointer p)
				If True Then
					MyBase(p)
				End If

				''' <summary>
				''' This method allocates buffer of size * sizeof(Nd4jLong)
				''' </summary>
				''' <param name="size">
				''' @return </param>
	' #ifdef __CUDACC__
	' #endif
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public RandomBuffer(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") LongPointer buffer)
				public RandomBuffer( Long seed, Long size, LongPointer buffer)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(seed, size, buffer)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") LongPointer buffer);
				private native void allocate( Long seed, Long size, LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public RandomBuffer(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") LongBuffer buffer)
				public RandomBuffer( Long seed, Long size, LongBuffer buffer)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(seed, size, buffer)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") LongBuffer buffer);
				private native void allocate( Long seed, Long size, LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public RandomBuffer(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") long[] buffer)
				public RandomBuffer( Long seed, Long size, Long() buffer)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(seed, size, buffer)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long seed, @Cast("Nd4jLong") long size, @Cast("uint64_t*") long[] buffer);
				private native void allocate( Long seed, Long size, Long() buffer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t*") LongPointer getBuffer();
				public native LongPointer getBuffer()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t*") LongPointer getDeviceBuffer();
				public native LongPointer getDeviceBuffer()

	' #ifdef __CUDACC__
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getSize();
				public native Long getSize()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getSeed();
				public native Long getSeed()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setSeed(@Cast("Nd4jLong") long seed);
				public native void setSeed( Long seed)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getAllocatedSize();
				public native Long getAllocatedSize()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getOffset();
				public native Long getOffset()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOffset(@Cast("Nd4jLong") long offset);
				public native void setOffset( Long offset)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void reSeed(@Cast("Nd4jLong") long amplifier);
				public native void reSeed( Long amplifier)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long getElement(@Cast("Nd4jLong") long _position);
				public native Long getElement( Long _position)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long next64(@Cast("uint64_t") long shiftedSeed);
				public native Long next64( Long shiftedSeed)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long rotl(@Cast("const uint64_t") long x, @Cast("uint64_t") long k);
				public native Long rotl( Long x, Long k)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long safeShift(@Cast("uint64_t") long x, @Cast("uint64_t") long y);
				public native Long safeShift( Long x, Long y)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long seedConv(@Cast("Nd4jLong") long seed);
				public native Long seedConv( Long seed)

				public native void incrementGeneration()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getNextIndex();
				public native Long getNextIndex()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long getNextElement();
				public native Long getNextElement()


				''' <summary>
				''' This method skips X elements from buffer
				''' </summary>
				''' <param name="numberOfElements"> number of elements to skip </param>
	' #ifdef __CUDACC__
	' #endif
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void rewindH(@Cast("Nd4jLong") long numberOfElements);
				public native void rewindH( Long numberOfElements)

				''' <summary>
				''' This method returns random int in range [0..MAX_INT]
				''' @return
				''' </summary>
				public native Integer nextInt()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long nextUInt64();
				public native Long nextUInt64()

				''' <summary>
				''' This method returns random int in range [0..to] </summary>
				''' <param name="to">
				''' @return </param>
				public native Integer nextInt(Integer [to])

				''' <summary>
				''' This method returns random int in range [from..to] </summary>
				''' <param name="from"> </param>
				''' <param name="to">
				''' @return </param>
				public native Integer nextInt(Integer from, Integer [to])


				''' <summary>
				''' This method returns random T in range of [0..1]
				''' @return
				''' </summary>

				''' <summary>
				''' This method returns random T in range of [0..to] </summary>
				''' <param name="to">
				''' @return </param>

				''' <summary>
				''' This method returns random T in range [from..to] </summary>
				''' <param name="from"> </param>
				''' <param name="to">
				''' @return </param>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long relativeUInt64(@Cast("Nd4jLong") long index);
				public native Long relativeUInt64( Long index)

				''' <summary>
				'''  relative methods are made as workaround for lock-free concurrent execution
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int relativeInt(@Cast("Nd4jLong") long index);
				public native Integer relativeInt( Long index)

				''' <summary>
				''' This method returns random int within [0..to]
				''' </summary>
				''' <param name="index"> </param>
				''' <param name="to">
				''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int relativeInt(@Cast("Nd4jLong") long index, int to);
				public native Integer relativeInt( Long index, Integer [to])

				''' <summary>
				''' This method returns random int within [from..to]
				''' </summary>
				''' <param name="index"> </param>
				''' <param name="to"> </param>
				''' <param name="from">
				''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native int relativeInt(@Cast("Nd4jLong") long index, int from, int to);
				public native Integer relativeInt( Long index, Integer from, Integer [to])

				''' <summary>
				''' This method returns random T within [0..1]
				''' </summary>
				''' <param name="index">
				''' @return </param>

	''' <summary>
	''' This method returns random T within [0..to]
	''' </summary>
	''' <param name="index"> </param>
	''' <param name="to">
	''' @return </param>

	''' <summary>
	''' This method returns random T within [from..to]
	''' </summary>
	''' <param name="index"> </param>
	''' <param name="from"> </param>
	''' <param name="to">
	''' @return </param>

			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::random") @NoOffset public static class IGenerator extends Pointer
			public static class IGenerator extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public IGenerator(Pointer p)
				If True Then
					MyBase(p)
				End If



				public native RandomBuffer getBuffer()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOffset(@Cast("Nd4jLong") long offset);
				public native void setOffset( Long offset)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getElementAbsolute(@Cast("Nd4jLong") long _position);
				public native Long getElementAbsolute( Long _position)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getElementRelative(@Cast("Nd4jLong") long _position);
				public native Long getElementRelative( Long _position)

				public native void refreshBuffer()
			End If



'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::random") @NoOffset public static class Xoroshiro128 extends IGenerator
			public static class Xoroshiro128 extends IGenerator
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Xoroshiro128(Pointer p)
				If True Then
					MyBase(p)
				End If

				public Xoroshiro128(RandomBuffer buffer)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(buffer)
				End If
				private native void allocate(RandomBuffer buffer)

				public native void refreshBuffer()
			End If


	' #endif //LIBND4J_HELPER_GENERATOR_H


	' Parsed from graph/profiling/GraphProfile.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef ND4J_GRAPH_PROFILE_H
	' #define ND4J_GRAPH_PROFILE_H

	' #include "NodeProfile.h"
	' #include <system/pointercast.h>
	' #include <system/dll.h>
	' #include <vector>
	' #include <string>
	' #include <map>
	' #include <chrono>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class GraphProfile extends Pointer
			public static class GraphProfile extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public GraphProfile(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public GraphProfile(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public GraphProfile position(Long position)
				If True Then
					Return CType(MyBase.position(position), GraphProfile)
				End If
				public GraphProfile getPointer(Long i)
				If True Then
					Return (New GraphProfile(CType(Me, Pointer))).position(position + i)
				End If

				public GraphProfile()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

				''' <summary>
				''' These methods just adding amount of bytes to various counters
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addToTotal(@Cast("Nd4jLong") long bytes);
				public native void addToTotal( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addToActivations(@Cast("Nd4jLong") long bytes);
				public native void addToActivations( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addToTemporary(@Cast("Nd4jLong") long bytes);
				public native void addToTemporary( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addToObjects(@Cast("Nd4jLong") long bytes);
				public native void addToObjects( Long bytes)

				''' <summary>
				''' This method allows to set graph construction (i.e. deserialization) time in nanoseconds
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBuildTime(@Cast("Nd4jLong") long nanos);
				public native void setBuildTime( Long nanos)

				''' <summary>
				''' This method sets graph execution time in nanoseconds.
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setExecutionTime(@Cast("Nd4jLong") long nanos);
				public native void setExecutionTime( Long nanos)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void startEvent(@Cast("char*") String name);
				public native void startEvent( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void startEvent(@Cast("char*") BytePointer name);
				public native void startEvent( BytePointer name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void recordEvent(@Cast("char*") String name);
				public native void recordEvent( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void recordEvent(@Cast("char*") BytePointer name);
				public native void recordEvent( BytePointer name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteEvent(@Cast("char*") String name);
				public native void deleteEvent( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void deleteEvent(@Cast("char*") BytePointer name);
				public native void deleteEvent( BytePointer name)

				''' <summary>
				''' This method saves time as delta from last saved time
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void spotEvent(@Cast("char*") String name);
				public native void spotEvent( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void spotEvent(@Cast("char*") BytePointer name);
				public native void spotEvent( BytePointer name)

				''' <summary>
				''' This method returns pointer to NodeProfile by ID
				''' PLEASE NOTE: this method will create new NodeProfile if there's none
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NodeProfile nodeById(int id, @Cast("char*") String name);
				public native NodeProfile nodeById(Integer id, String name)
				public native NodeProfile nodeById(Integer id)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NodeProfile nodeById(int id, @Cast("char*") BytePointer name);
				public native NodeProfile nodeById(Integer id, BytePointer name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean nodeExists(int id);
				public native Boolean nodeExists(Integer id)

				''' <summary>
				''' This method merges values from other profile report </summary>
				''' <param name="other"> </param>
				public native void merge(GraphProfile other)
				public native void assign(GraphProfile other)

				''' <summary>
				''' These methods are just utility methods for time
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long currentTime();
				public native Long currentTime()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long relativeTime(@Cast("Nd4jLong") long time);
				public native Long relativeTime( Long time)

				public native void printOut()
			End If



	' #endif

	' Parsed from graph/profiling/NodeProfile.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_NODE_PROFILE_H
	' #define LIBND4J_NODE_PROFILE_H

	' #include <system/pointercast.h>
	' #include <system/dll.h>
	' #include <string>
	' #include <vector>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class NodeProfile extends Pointer
			public static class NodeProfile extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public NodeProfile(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public NodeProfile(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public NodeProfile position(Long position)
				If True Then
					Return CType(MyBase.position(position), NodeProfile)
				End If
				public NodeProfile getPointer(Long i)
				If True Then
					Return (New NodeProfile(CType(Me, Pointer))).position(position + i)
				End If

				public NodeProfile()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NodeProfile(int id, @Cast("char*") String name)
				public NodeProfile(Integer id, String name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(id, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int id, @Cast("char*") String name);
				private native void allocate(Integer id, String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public NodeProfile(int id, @Cast("char*") BytePointer name)
				public NodeProfile(Integer id, BytePointer name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(id, name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int id, @Cast("char*") BytePointer name);
				private native void allocate(Integer id, BytePointer name)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBuildTime(@Cast("Nd4jLong") long time);
				public native void setBuildTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setPreparationTime(@Cast("Nd4jLong") long time);
				public native void setPreparationTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setExecutionTime(@Cast("Nd4jLong") long time);
				public native void setExecutionTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTotalTime(@Cast("Nd4jLong") long time);
				public native void setTotalTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeFunctionTime(@Cast("Nd4jLong") long time);
				public native void setShapeFunctionTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setArrayTime(@Cast("Nd4jLong") long time);
				public native void setArrayTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInputTime(@Cast("Nd4jLong") long time);
				public native void setInputTime( Long time)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setActivationsSize(@Cast("Nd4jLong") long bytes);
				public native void setActivationsSize( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTemporarySize(@Cast("Nd4jLong") long bytes);
				public native void setTemporarySize( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setObjectsSize(@Cast("Nd4jLong") long bytes);
				public native void setObjectsSize( Long bytes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTotalSize(@Cast("Nd4jLong") long bytes);
				public native void setTotalSize( Long bytes)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addInputShape(@Cast("const Nd4jLong*") LongPointer shapeInfo);
				public native void addInputShape( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addInputShape(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
				public native void addInputShape( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addInputShape(@Cast("const Nd4jLong*") long[] shapeInfo);
				public native void addInputShape( Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addOutputShape(@Cast("const Nd4jLong*") LongPointer shapeInfo);
				public native void addOutputShape( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addOutputShape(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
				public native void addOutputShape( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void addOutputShape(@Cast("const Nd4jLong*") long[] shapeInfo);
				public native void addOutputShape( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getActivationsSize();
				public native Long getActivationsSize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getTemporarySize();
				public native Long getTemporarySize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getObjectsSize();
				public native Long getObjectsSize()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getTotalSize();
				public native Long getTotalSize()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getExecutionTime();
				public native Long getExecutionTime()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString @ByRef @Cast({"char*", "std::string*"}) BytePointer name();
				public native @ByRef BytePointer name()

				public native void merge(NodeProfile other)
				public native void assign(NodeProfile other)

				public native void printOut()
			End If



	' #endif

	' Parsed from graph/Context.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  *  See the NOTICE file distributed with this work for additional
	' *  *  information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_CONTEXT_H
	' #define LIBND4J_CONTEXT_H

	' #include <vector>
	' #include <array/NDArray.h>
	' #include <graph/Variable.h>
	' #include <graph/VariableSpace.h>
	' #include <graph/ContextPrototype.h>
	' #include <memory/Workspace.h>
	' #include <execution/Engine.h>

	' CUDA-specific includes
	' #ifdef __CUDACC__
	' #endif
			''' <summary>
			''' This class defines input desired for any given node/operation within graph
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class Context extends ContextPrototype
			public static class Context extends ContextPrototype
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Context(Pointer p)
				If True Then
					MyBase(p)
				End If

				public Context(ContextPrototype prototype, VariableSpace variableSpace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(prototype, variableSpace)
				End If
				private native void allocate(ContextPrototype prototype, VariableSpace variableSpace)

				public Context(Integer nodeId, VariableSpace variableSpace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(nodeId, variableSpace)
				End If
				private native void allocate(Integer nodeId, VariableSpace variableSpace)
				public Context(Integer nodeId)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(nodeId)
				End If
				private native void allocate(Integer nodeId)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public Context(int nodeId, VariableSpace variableSpace, @Cast("bool") boolean isInplace)
				public Context(Integer nodeId, VariableSpace variableSpace, Boolean isInplace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(nodeId, variableSpace, isInplace)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int nodeId, VariableSpace variableSpace, @Cast("bool") boolean isInplace);
				private native void allocate(Integer nodeId, VariableSpace variableSpace, Boolean isInplace)

				' default destructor

				' these methods are for execution timing
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOuterTime(@Cast("Nd4jLong") long time);
				public native void setOuterTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInnerTime(@Cast("Nd4jLong") long time);
				public native void setInnerTime( Long time)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getOuterTime();
				public native Long getOuterTime()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getInnerTime();
				public native Long getInnerTime()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType();
				public native Integer dataType()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType(int index);
				public native Integer dataType(Integer index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDataType(int index, @Cast("sd::DataType") int type);
				public native void setDataType(Integer index, Integer type)
				' these methods are related to Workspace abstraction
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasWorkspaceProvided();
				public native Boolean hasWorkspaceProvided()
				public native void attachWorkspace(Workspace workspace)
				public native void forgetWorkspace()

				' these methods return full-time workspace
				public native Workspace getWorkspace()
				public native Workspace workspace()
				public native Workspace fWorkspace()

				' this method returns workspace for temporary allocations
				public native Workspace tWorkspace()

				' this method returns workspace for object allocations
				public native Workspace oWorkspace()

				public native void setVariableSpace(VariableSpace variableSpace)

				public native RandomBuffer getRNG()
				public native void setRNG(RandomBuffer rng)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTargetEngine(@Cast("samediff::Engine") int engine);
				public native void setTargetEngine( Integer engine)

				public native VariableSpace getVariableSpace()

				public native LaunchContext launchContext()

				' these fields define, if we can execute specific node in-place, without generating new array


				' these variables are only for Divergent Nodes
				public native Integer getBranch()
				public native void setBranch(Integer branch)

				''' 
				''' <summary>
				''' @return
				''' </summary>
				public native Stash getStash()

				''' 
				public native void trackList(NDArrayList list)


				''' <summary>
				''' This method returns variable for a given input index for this block </summary>
				''' <param name="idx">
				''' @return </param>
				public native Variable getVariable(Integer idx)
				public native Variable variable(Integer idx)

				''' <summary>
				''' This method is shortcut to getVariable(int idx);
				''' 
				''' + it check fastpath for array availability (preferred)
				''' @return
				''' </summary>
				public native NDArray getNDArray(Integer idx)
				public native NDArray array(Integer idx)


				''' <summary>
				''' This method fetches variable from VariableSpace DIRECTLY </summary>
				''' <param name="p">
				''' @return </param>
				public native Variable variable(Integer node, Integer index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native Variable variable(@ByRef IntIntPair p);
				public native Variable variable( IntIntPair p)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayToVariableSpace(int nodeId, int index, NDArray array, @Cast("bool") boolean removable);
				public native void pushNDArrayToVariableSpace(Integer nodeId, Integer index, NDArray array, Boolean removable)
				public native void pushNDArrayToVariableSpace(Integer nodeId, Integer index, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayToVariableSpace(@ByRef IntIntPair pair, NDArray array, @Cast("bool") boolean removable);
				public native void pushNDArrayToVariableSpace( IntIntPair pair, NDArray array, Boolean removable)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayToVariableSpace(@ByRef IntIntPair pair, NDArray array);
				public native void pushNDArrayToVariableSpace( IntIntPair pair, NDArray array)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayListToVariableSpace(int nodeId, int index, NDArrayList list, @Cast("bool") boolean track);
				public native void pushNDArrayListToVariableSpace(Integer nodeId, Integer index, NDArrayList list, Boolean track)
				public native void pushNDArrayListToVariableSpace(Integer nodeId, Integer index, NDArrayList list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayListToVariableSpace(@ByRef IntIntPair pair, NDArrayList list, @Cast("bool") boolean track);
				public native void pushNDArrayListToVariableSpace( IntIntPair pair, NDArrayList list, Boolean track)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pushNDArrayListToVariableSpace(@ByRef IntIntPair pair, NDArrayList list);
				public native void pushNDArrayListToVariableSpace( IntIntPair pair, NDArrayList list)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isValueAvailable(int idx);
				public native Boolean isValueAvailable(Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isValueAvailable();
				public native Boolean isValueAvailable()

				public native Variable ensureVariable(Integer idx)
				public native Variable ensureVariable()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("unsigned long") long width();
				public native Long width()

				' methods used in java interop
				''' <summary>
				''' This method checks if Context uses fastpath variable access
				''' @return
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isFastPath();
				public native Boolean isFastPath()

				''' <summary>
				''' Method allows to forbid FastPath execution </summary>
				''' <param name="reallyForbid"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void forbidFastPath(@Cast("bool") boolean reallyForbid);
				public native void forbidFastPath( Boolean reallyForbid)

	' #ifndef __JAVACPP_HACK__
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInputArray(int index, NDArray array, @Cast("bool") boolean removable);
				public native void setInputArray(Integer index, NDArray array, Boolean removable)
				public native void setInputArray(Integer index, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInputArray(int index, Pointer buffer, @Const Pointer shapeInfo, Pointer specialBuffer, @Const Pointer specialShapeInfo);
				public native void setInputArray(Integer index, Pointer buffer, Pointer shapeInfo, Pointer specialBuffer, Pointer specialShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setInputArray(int index, Pointer databuffer, @Const Pointer shapeInfo, @Const Pointer specialShapeInfo);
				public native void setInputArray(Integer index, Pointer databuffer, Pointer shapeInfo, Pointer specialShapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOutputArray(int index, NDArray array, @Cast("bool") boolean removable);
				public native void setOutputArray(Integer index, NDArray array, Boolean removable)
				public native void setOutputArray(Integer index, NDArray array)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOutputArray(int index, Pointer buffer, @Const Pointer shapeInfo, Pointer specialBuffer, @Const Pointer specialShapeInfo);
				public native void setOutputArray(Integer index, Pointer buffer, Pointer shapeInfo, Pointer specialBuffer, Pointer specialShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setOutputArray(int index, Pointer databuffer, @Const Pointer shapeInfo, @Const Pointer specialShapeInfo);
				public native void setOutputArray(Integer index, Pointer databuffer, Pointer shapeInfo, Pointer specialShapeInfo)

				public native void setTArguments(DoublePointer arguments, Integer numberOfArguments)
				public native void setTArguments(DoubleBuffer arguments, Integer numberOfArguments)
				public native void setTArguments(Double() arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") LongPointer arguments, int numberOfArguments);
				public native void setIArguments( LongPointer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") LongBuffer arguments, int numberOfArguments);
				public native void setIArguments( LongBuffer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") long[] arguments, int numberOfArguments);
				public native void setIArguments( Long() arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBArguments(@Cast("bool*") BooleanPointer arguments, int numberOfArguments);
				public native void setBArguments( BooleanPointer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBArguments(@Cast("bool*") boolean[] arguments, int numberOfArguments);
				public native void setBArguments( Boolean() arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") IntPointer arguments, int numberOfArguments);
				public native void setDArguments( IntPointer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") IntBuffer arguments, int numberOfArguments);
				public native void setDArguments( IntBuffer arguments, Integer numberOfArguments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") int[] arguments, int numberOfArguments);
				public native void setDArguments( Integer() arguments, Integer numberOfArguments)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTArguments(@StdVector DoublePointer tArgs);
				public native void setTArguments( DoublePointer tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTArguments(@StdVector DoubleBuffer tArgs);
				public native void setTArguments( DoubleBuffer tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setTArguments(@StdVector double[] tArgs);
				public native void setTArguments( Double() tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") @StdVector LongPointer tArgs);
				public native void setIArguments( LongPointer tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") @StdVector LongBuffer tArgs);
				public native void setIArguments( LongBuffer tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setIArguments(@Cast("Nd4jLong*") @StdVector long[] tArgs);
				public native void setIArguments( Long() tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBArguments(@Cast("bool*") @StdVector BooleanPointer tArgs);
				public native void setBArguments( BooleanPointer tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setBArguments(@Cast("bool*") @StdVector boolean[] tArgs);
				public native void setBArguments( Boolean() tArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") @StdVector IntPointer dArgs);
				public native void setDArguments( IntPointer dArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") @StdVector IntBuffer dArgs);
				public native void setDArguments( IntBuffer dArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDArguments(@Cast("sd::DataType*") @StdVector int[] dArgs);
				public native void setDArguments( Integer() dArgs)

				''' <summary>
				''' This method purges fastpath in/out contents and releases all the handles.
				''' 
				''' PLEASE NOTE: I/T/B/D args will stay intact
				''' </summary>
				public native void clearFastPath()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setCudaContext(@Cast("Nd4jPointer") Pointer cudaStream, @Cast("Nd4jPointer") Pointer reductionPointer, @Cast("Nd4jPointer") Pointer allocationPointer);
				public native void setCudaContext( Pointer cudaStream, Pointer reductionPointer, Pointer allocationPointer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void allowHelpers(@Cast("bool") boolean reallyAllow);
				public native void allowHelpers( Boolean reallyAllow)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean helpersAllowed();
				public native Boolean helpersAllowed()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setShapeFunctionOverride(@Cast("bool") boolean reallyOverride);
				public native void setShapeFunctionOverride( Boolean reallyOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean shapeFunctionOverride();
				public native Boolean shapeFunctionOverride()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("samediff::ExecutionMode") int executionMode();
				public native Integer executionMode()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setExecutionMode(@Cast("samediff::ExecutionMode") int executionMode);
				public native void setExecutionMode( Integer executionMode)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isTraining();
				public native Boolean isTraining()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInference();
				public native Boolean isInference()
			End If




	' #endif //LIBND4J_BLOCK_H


	' Parsed from graph/ContextPrototype.h

	''' <summary>
	'''*****************************************************************************
	''' Copyright (c) 2015-2018 Skymind, Inc.
	''' Copyright (c) 2019-2020 Konduit K.K.
	''' 
	''' /* ******************************************************************************
	''' 
	''' 
	''' This program and the accompanying materials are made available under the
	''' terms of the Apache License, Version 2.0 which is available at
	''' https://www.apache.org/licenses/LICENSE-2.0.
	''' 
	'''  See the NOTICE file distributed with this work for additional
	'''  information regarding copyright ownership.
	''' Unless required by applicable law or agreed to in writing, software
	''' distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	''' WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	''' License for the specific language governing permissions and limitations
	''' under the License.
	''' 
	''' SPDX-License-Identifier: Apache-2.0
	''' *****************************************************************************
	''' </summary>

	'
	'  @author raver119@gmail.com
	'

	' #ifndef ND4J_CONTEXT_PROTOTYPE_H
	' #define ND4J_CONTEXT_PROTOTYPE_H

	' #include <vector>
	' #include <system/Environment.h>
	' #include <array/DataType.h>
	' #include <system/dll.h>
	' #include <graph/RandomGenerator.h>
	' #include <ops/declarable/OpDescriptor.h>
	' #include <execution/Engine.h>
	' #include <execution/ExecutionMode.h>

	' #ifndef __STANDALONE_BUILD__
	' #include <config.h>
	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class ContextPrototype extends Pointer
			public static class ContextPrototype extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ContextPrototype(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ContextPrototype(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ContextPrototype position(Long position)
				If True Then
					Return CType(MyBase.position(position), ContextPrototype)
				End If
				public ContextPrototype getPointer(Long i)
				If True Then
					Return (New ContextPrototype(CType(Me, Pointer))).position(position + i)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ContextPrototype(OpDescriptor opDescriptor, int nodeId, @Cast("bool") boolean inPlace)
				public ContextPrototype(OpDescriptor opDescriptor, Integer nodeId, Boolean inPlace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(opDescriptor, nodeId, inPlace)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(OpDescriptor opDescriptor, int nodeId, @Cast("bool") boolean inPlace);
				private native void allocate(OpDescriptor opDescriptor, Integer nodeId, Boolean inPlace)
				public ContextPrototype()
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate()
				End If
				private native void allocate()

				public native Integer getNodeId()
				public native Integer nodeId()

				' this method returns true, if inputs are defined
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasVariablesFilled();
				public native Boolean hasVariablesFilled()

				public native void setOpDescriptor(OpDescriptor opDescriptor)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType();
				public native Integer dataType()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType(int index);
				public native Integer dataType(Integer index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setDataType(int index, @Cast("sd::DataType") int type);
				public native void setDataType(Integer index, Integer type)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInplace();
				public native Boolean isInplace()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void markInplace(@Cast("bool") boolean reallyInplace);
				public native void markInplace( Boolean reallyInplace)

				public native void pickInput(Integer input)
				public native void pickInput(Integer input, Integer index)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void pickInput(@ByRef IntIntPair p);
				public native void pickInput( IntIntPair p)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void fillInputs(@StdVector IntPointer inputs);
				public native void fillInputs( IntPointer inputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void fillInputs(@StdVector IntBuffer inputs);
				public native void fillInputs( IntBuffer inputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void fillInputs(@StdVector int[] inputs);
				public native void fillInputs( Integer() inputs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector IntIntPair inputs();
				public native IntIntPair inputs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector DoublePointer getTArguments();
				public native DoublePointer getTArguments()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector IntPointer getIArguments();
				public native IntPointer getIArguments()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool*") @StdVector BooleanPointer getBArguments();
				public native @StdVector BooleanPointer getBArguments()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType*") @StdVector IntPointer getDArguments();
				public native @StdVector IntPointer getDArguments()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector IntPointer getAxis();
				public native IntPointer getAxis()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("samediff::Engine") int engine();
				public native Integer engine()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long numT();
				public native Long numT()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long numI();
				public native Long numI()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long numB();
				public native Long numB()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("size_t") long numD();
				public native Long numD()

				public native IntIntPair input(Integer idx)

				public native Integer opNum()
				public native void setOpNum(Integer opNum)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isUseMKLDNN();
				public native Boolean isUseMKLDNN()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setUseMKLDNN(@Cast("bool") boolean useMKLDNN);
				public native void setUseMKLDNN( Boolean useMKLDNN)

				''' <summary>
				''' This method returns number of inputs available in this block
				''' @return
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("unsigned long") long width();
				public native Long width()

				' just a clone
				public native ContextPrototype MemberwiseClone()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef RandomGenerator randomGenerator();
				public native RandomGenerator randomGenerator()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Const @ByRef RandomGenerator getRng();
				public native @ByRef RandomGenerator getRng()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRng(@Const @ByRef RandomGenerator anotherRng);
				public native void setRng( RandomGenerator anotherRng)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRandomGenerator(@Const @ByRef RandomGenerator anotherRng);
				public native void setRandomGenerator( RandomGenerator anotherRng)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("uint64_t") long randomSeed();
				public native Long randomSeed()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setRandomSeed(@Cast("uint64_t") long seed);
				public native void setRandomSeed( Long seed)
			End If



	' #endif //ND4J_CONTEXT_PROTOTYPE_H


	' Parsed from graph/ResultWrapper.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 11/06/18.
	'

	' #ifndef LIBND4J_RESULTWRAPPER_H
	' #define LIBND4J_RESULTWRAPPER_H

	' #include <system/op_boilerplate.h>
	' #include <system/pointercast.h>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::graph") @NoOffset public static class ResultWrapper extends org.nd4j.nativeblas.ResultWrapperAbstraction
			public static class ResultWrapper extends org.nd4j.nativeblas.ResultWrapperAbstraction
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ResultWrapper(Pointer p)
				If True Then
					MyBase(p)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ResultWrapper(@Cast("Nd4jLong") long size, @Cast("Nd4jPointer") Pointer ptr)
				public ResultWrapper( Long size, Pointer ptr)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(size, ptr)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong") long size, @Cast("Nd4jPointer") Pointer ptr);
				private native void allocate( Long size, Pointer ptr)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long size();
				public native Long size()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jPointer") Pointer pointer();
				public native Pointer pointer()
			End If




	' #endif //LIBND4J_RESULTWRAPPER_H


	' Parsed from helpers/shape.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' * shape.h
	' *
	' *  Created on: Dec 28, 2015
	' *      Author: agibsonccc
	' 

	' #ifndef SHAPE_H_
	' #define SHAPE_H_

	' #include <cstring>
	' #include <cstdio>
	' #include "system/dll.h"
	' #include "system/nd4jmalloc.h"
	' #include "math/templatemath.h"
	' #include "../helpers/logger.h"
	' #include "system/pointercast.h"
	' #include "../cnpy/cnpy.h"
	' #include <system/op_boilerplate.h>

	public static final Integer MAX_DIMENSION = &H7fffffff
	public static final Integer MAX_NUM_THREADS = 1024
	public static final Integer MAX_RANK = 32
	public static final Integer MAX_SHAPEINFOLENGTH = 2*MAX_RANK+4
	public static final Integer MAX_COORD = 3
	public static final Integer PREALLOC_SIZE = 33554432
	' #ifdef __CUDACC__
	' #endif


	' #ifdef __CUDACC__
	' #else
	' #define INLINEDEF inline
	' #endif

	' #include "system/pairwise_util.h"
	' #include <stdint.h>
	' #include <array/ArrayOptions.h>

	''' <summary>
	''' Shape information approximating
	''' the information on an ndarray
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") @NoOffset public static class ShapeInformation extends Pointer
		public static class ShapeInformation extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ShapeInformation(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ShapeInformation(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ShapeInformation position(Long position)
			If True Then
				Return CType(MyBase.position(position), ShapeInformation)
			End If
			public ShapeInformation getPointer(Long i)
			If True Then
				Return (New ShapeInformation(CType(Me, Pointer))).position(position + i)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeInformation(@Cast("Nd4jLong*") LongPointer shape_, @Cast("Nd4jLong*") LongPointer stride_, char order_, int rank_, int offset_, int elementWiseStride_)
			public ShapeInformation( LongPointer shape_, LongPointer stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape_, stride_, order_, rank_, offset_, elementWiseStride_)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") LongPointer shape_, @Cast("Nd4jLong*") LongPointer stride_, char order_, int rank_, int offset_, int elementWiseStride_);
			private native void allocate( LongPointer shape_, LongPointer stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)
			public ShapeInformation()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeInformation(@Cast("Nd4jLong*") LongBuffer shape_, @Cast("Nd4jLong*") LongBuffer stride_, char order_, int rank_, int offset_, int elementWiseStride_)
			public ShapeInformation( LongBuffer shape_, LongBuffer stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape_, stride_, order_, rank_, offset_, elementWiseStride_)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") LongBuffer shape_, @Cast("Nd4jLong*") LongBuffer stride_, char order_, int rank_, int offset_, int elementWiseStride_);
			private native void allocate( LongBuffer shape_, LongBuffer stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeInformation(@Cast("Nd4jLong*") long[] shape_, @Cast("Nd4jLong*") long[] stride_, char order_, int rank_, int offset_, int elementWiseStride_)
			public ShapeInformation( Long() shape_, Long() stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape_, stride_, order_, rank_, offset_, elementWiseStride_)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jLong*") long[] shape_, @Cast("Nd4jLong*") long[] stride_, char order_, int rank_, int offset_, int elementWiseStride_);
			private native void allocate( Long() shape_, Long() stride_, Char order_, Integer rank_, Integer offset_, Integer elementWiseStride_)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer shape();
			public native LongPointer shape()
			public native ShapeInformation shape(LongPointer setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer stride();
			public native LongPointer stride()
			public native ShapeInformation stride(LongPointer setter)
			public native Char order()
			public native ShapeInformation order(Char setter)
			public native Integer rank()
			public native ShapeInformation rank(Integer setter)
			public native Integer offset()
			public native ShapeInformation offset(Integer setter)
			public native Integer elementWiseStride()
			public native ShapeInformation elementWiseStride(Integer setter)
		End If

	''' <summary>
	''' Indexing information
	''' for bounds checking
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public static class CurrentIndexing extends Pointer
		public static class CurrentIndexing extends Pointer
		If True Then
			''' <summary>
			''' Default native constructor. </summary>
			public CurrentIndexing()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public CurrentIndexing(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public CurrentIndexing(Pointer p)
			If True Then
				MyBase(p)
			End If
			private native void allocate()
			private native void allocateArray(Long size)
			public CurrentIndexing position(Long position)
			If True Then
				Return CType(MyBase.position(position), CurrentIndexing)
			End If
			public CurrentIndexing getPointer(Long i)
			If True Then
				Return (New CurrentIndexing(CType(Me, Pointer))).position(position + i)
			End If

			public native Integer numElementsPerThread()
			public native CurrentIndexing numElementsPerThread(Integer setter)
			public native Integer blockStartingIndex()
			public native CurrentIndexing blockStartingIndex(Integer setter)
			public native Integer startingThreadIndex()
			public native CurrentIndexing startingThreadIndex(Integer setter)
			public native Integer endingThreadIndex()
			public native CurrentIndexing endingThreadIndex(Integer setter)

		End If



'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(int shape1Rank, @Cast("const Nd4jLong*") LongPointer shape1, int shape2Rank, @Cast("const Nd4jLong*") LongPointer shape2);
		Boolean shapeEquals(Integer shape1Rank, LongPointer shape1, Integer shape2Rank, LongPointer shape2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(int shape1Rank, @Cast("const Nd4jLong*") LongBuffer shape1, int shape2Rank, @Cast("const Nd4jLong*") LongBuffer shape2);
		Boolean shapeEquals(Integer shape1Rank, LongBuffer shape1, Integer shape2Rank, LongBuffer shape2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(int shape1Rank, @Cast("const Nd4jLong*") long[] shape1, int shape2Rank, @Cast("const Nd4jLong*") long[] shape2);
		Boolean shapeEquals(Integer shape1Rank, Long() shape1, Integer shape2Rank, Long() shape2)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("const Nd4jLong*") LongPointer detachShape(@Cast("const Nd4jLong*") LongPointer originalShape);
		LongPointer detachShape( LongPointer originalShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("const Nd4jLong*") LongBuffer detachShape(@Cast("const Nd4jLong*") LongBuffer originalShape);
		LongBuffer detachShape( LongBuffer originalShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("const Nd4jLong*") long[] detachShape(@Cast("const Nd4jLong*") long[] originalShape);
		Long() detachShape( Long() originalShape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer copyShape(@Cast("const Nd4jLong*") LongPointer originalShape);
		LongPointer copyShape( LongPointer originalShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer copyShape(@Cast("const Nd4jLong*") LongBuffer originalShape);
		LongBuffer copyShape( LongBuffer originalShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] copyShape(@Cast("const Nd4jLong*") long[] originalShape);
		Long() copyShape( Long() originalShape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2);
		Boolean shapeEquals( LongPointer shapeInfo1, LongPointer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2);
		Boolean shapeEquals( LongBuffer shapeInfo1, LongBuffer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2);
		Boolean shapeEquals( Long() shapeInfo1, Long() shapeInfo2)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2, @Cast("const Nd4jLong*") LongPointer shapeInfo3);
		Boolean shapeEquals( LongPointer shapeInfo1, LongPointer shapeInfo2, LongPointer shapeInfo3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2, @Cast("const Nd4jLong*") LongBuffer shapeInfo3);
		Boolean shapeEquals( LongBuffer shapeInfo1, LongBuffer shapeInfo2, LongBuffer shapeInfo3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean shapeEquals(@Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2, @Cast("const Nd4jLong*") long[] shapeInfo3);
		Boolean shapeEquals( Long() shapeInfo1, Long() shapeInfo2, Long() shapeInfo3)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(int shape1Rank,@Cast("const Nd4jLong*") LongPointer shape1,int shape2Rank, @Cast("const Nd4jLong*") LongPointer shape2);
		Boolean strideEquals(Integer shape1Rank, LongPointer shape1,Integer shape2Rank, LongPointer shape2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(int shape1Rank,@Cast("const Nd4jLong*") LongBuffer shape1,int shape2Rank, @Cast("const Nd4jLong*") LongBuffer shape2);
		Boolean strideEquals(Integer shape1Rank, LongBuffer shape1,Integer shape2Rank, LongBuffer shape2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(int shape1Rank,@Cast("const Nd4jLong*") long[] shape1,int shape2Rank, @Cast("const Nd4jLong*") long[] shape2);
		Boolean strideEquals(Integer shape1Rank, Long() shape1,Integer shape2Rank, Long() shape2)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2);
		Boolean strideEquals( LongPointer shapeInfo1, LongPointer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2);
		Boolean strideEquals( LongBuffer shapeInfo1, LongBuffer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2);
		Boolean strideEquals( Long() shapeInfo1, Long() shapeInfo2)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") LongPointer stride1,int rank1, @Cast("const Nd4jLong*") LongPointer stride2, int rank2);
		Boolean strideEquals( LongPointer stride1,Integer rank1, LongPointer stride2, Integer rank2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") LongBuffer stride1,int rank1, @Cast("const Nd4jLong*") LongBuffer stride2, int rank2);
		Boolean strideEquals( LongBuffer stride1,Integer rank1, LongBuffer stride2, Integer rank2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideEquals(@Cast("const Nd4jLong*") long[] stride1,int rank1, @Cast("const Nd4jLong*") long[] stride2, int rank2);
		Boolean strideEquals( Long() stride1,Integer rank1, Long() stride2, Integer rank2)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsSoft(@Cast("const Nd4jLong*") LongPointer shapeA, @Cast("const Nd4jLong*") LongPointer shapeB);
		Boolean equalsSoft( LongPointer shapeA, LongPointer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsSoft(@Cast("const Nd4jLong*") LongBuffer shapeA, @Cast("const Nd4jLong*") LongBuffer shapeB);
		Boolean equalsSoft( LongBuffer shapeA, LongBuffer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsSoft(@Cast("const Nd4jLong*") long[] shapeA, @Cast("const Nd4jLong*") long[] shapeB);
		Boolean equalsSoft( Long() shapeA, Long() shapeB)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsTypesAndShapesSoft(@Cast("const Nd4jLong*") LongPointer shapeA, @Cast("const Nd4jLong*") LongPointer shapeB);
		Boolean equalsTypesAndShapesSoft( LongPointer shapeA, LongPointer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsTypesAndShapesSoft(@Cast("const Nd4jLong*") LongBuffer shapeA, @Cast("const Nd4jLong*") LongBuffer shapeB);
		Boolean equalsTypesAndShapesSoft( LongBuffer shapeA, LongBuffer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsTypesAndShapesSoft(@Cast("const Nd4jLong*") long[] shapeA, @Cast("const Nd4jLong*") long[] shapeB);
		Boolean equalsTypesAndShapesSoft( Long() shapeA, Long() shapeB)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsStrict(@Cast("const Nd4jLong*") LongPointer shapeA, @Cast("const Nd4jLong*") LongPointer shapeB);
		Boolean equalsStrict( LongPointer shapeA, LongPointer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsStrict(@Cast("const Nd4jLong*") LongBuffer shapeA, @Cast("const Nd4jLong*") LongBuffer shapeB);
		Boolean equalsStrict( LongBuffer shapeA, LongBuffer shapeB)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean equalsStrict(@Cast("const Nd4jLong*") long[] shapeA, @Cast("const Nd4jLong*") long[] shapeB);
		Boolean equalsStrict( Long() shapeA, Long() shapeB)

		' returns true if ranks, shapes and strides are the same
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2);
		Boolean haveSameShapeAndStrides( LongPointer shapeInfo1, LongPointer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2);
		Boolean haveSameShapeAndStrides( LongBuffer shapeInfo1, LongBuffer shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2);
		Boolean haveSameShapeAndStrides( Long() shapeInfo1, Long() shapeInfo2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2, @Cast("const Nd4jLong*") LongPointer shapeInfo3);
		Boolean haveSameShapeAndStrides( LongPointer shapeInfo1, LongPointer shapeInfo2, LongPointer shapeInfo3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2, @Cast("const Nd4jLong*") LongBuffer shapeInfo3);
		Boolean haveSameShapeAndStrides( LongBuffer shapeInfo1, LongBuffer shapeInfo2, LongBuffer shapeInfo3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean haveSameShapeAndStrides(@Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2, @Cast("const Nd4jLong*") long[] shapeInfo3);
		Boolean haveSameShapeAndStrides( Long() shapeInfo1, Long() shapeInfo2, Long() shapeInfo3)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int sizeAt(@Cast("const Nd4jLong*") LongPointer shapeInfo, int dim);
		public native Integer sizeAt( LongPointer shapeInfo, Integer [dim])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int sizeAt(@Cast("const Nd4jLong*") LongBuffer shapeInfo, int dim);
		public native Integer sizeAt( LongBuffer shapeInfo, Integer [dim])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int sizeAt(@Cast("const Nd4jLong*") long[] shapeInfo, int dim);
		public native Integer sizeAt( Long() shapeInfo, Integer [dim])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long strideAt(@Cast("const Nd4jLong*") LongPointer shapeInfo, int dim);
		Long strideAt( LongPointer shapeInfo, Integer [dim])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long strideAt(@Cast("const Nd4jLong*") LongBuffer shapeInfo, int dim);
		Long strideAt( LongBuffer shapeInfo, Integer [dim])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long strideAt(@Cast("const Nd4jLong*") long[] shapeInfo, int dim);
		Long strideAt( Long() shapeInfo, Integer [dim])

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void traceNew(int id);
		public native void traceNew(Integer id)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadIndexForLinear(int linearIndex, int tadLength);
		public native Integer tadIndexForLinear(Integer linearIndex, Integer tadLength)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tadLength(@Cast("const Nd4jLong*") LongPointer shapeInfo, IntPointer dimension, int dimensionLength);
		Long tadLength( LongPointer shapeInfo, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tadLength(@Cast("const Nd4jLong*") LongBuffer shapeInfo, IntBuffer dimension, int dimensionLength);
		Long tadLength( LongBuffer shapeInfo, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tadLength(@Cast("const Nd4jLong*") long[] shapeInfo, int[] dimension, int dimensionLength);
		Long tadLength( Long() shapeInfo, Integer() dimension, Integer dimensionLength)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean canReshape(int oldRank, @Cast("Nd4jLong*") LongPointer oldShape, int newRank, @Cast("Nd4jLong*") LongPointer newShape, @Cast("bool") boolean isFOrder);
		Boolean canReshape(Integer oldRank, LongPointer oldShape, Integer newRank, LongPointer newShape, Boolean isFOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean canReshape(int oldRank, @Cast("Nd4jLong*") LongBuffer oldShape, int newRank, @Cast("Nd4jLong*") LongBuffer newShape, @Cast("bool") boolean isFOrder);
		Boolean canReshape(Integer oldRank, LongBuffer oldShape, Integer newRank, LongBuffer newShape, Boolean isFOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean canReshape(int oldRank, @Cast("Nd4jLong*") long[] oldShape, int newRank, @Cast("Nd4jLong*") long[] newShape, @Cast("bool") boolean isFOrder);
		Boolean canReshape(Integer oldRank, Long() oldShape, Integer newRank, Long() newShape, Boolean isFOrder)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") LongPointer oldShapeInfo, byte newOrder, int newRank, @Cast("const Nd4jLong*") LongPointer newShape, @Cast("Nd4jLong*") LongPointer newShapeInfo);
		Boolean reshapeC( LongPointer oldShapeInfo, SByte newOrder, Integer newRank, LongPointer newShape, LongPointer newShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") LongBuffer oldShapeInfo, byte newOrder, int newRank, @Cast("const Nd4jLong*") LongBuffer newShape, @Cast("Nd4jLong*") LongBuffer newShapeInfo);
		Boolean reshapeC( LongBuffer oldShapeInfo, SByte newOrder, Integer newRank, LongBuffer newShape, LongBuffer newShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") long[] oldShapeInfo, byte newOrder, int newRank, @Cast("const Nd4jLong*") long[] newShape, @Cast("Nd4jLong*") long[] newShapeInfo);
		Boolean reshapeC( Long() oldShapeInfo, SByte newOrder, Integer newRank, Long() newShape, Long() newShapeInfo)
		''' <summary>
		''' newShapeInfo contains rank, shape and order only, no strides/ews/type
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") LongPointer oldShapeInfo, @Cast("Nd4jLong*") LongPointer newShapeInfo);
		Boolean reshapeC( LongPointer oldShapeInfo, LongPointer newShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") LongBuffer oldShapeInfo, @Cast("Nd4jLong*") LongBuffer newShapeInfo);
		Boolean reshapeC( LongBuffer oldShapeInfo, LongBuffer newShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean reshapeC(@Cast("const Nd4jLong*") long[] oldShapeInfo, @Cast("Nd4jLong*") long[] newShapeInfo);
		Boolean reshapeC( Long() oldShapeInfo, Long() newShapeInfo)

		''' <summary>
		''' Get the shape info buffer
		''' for the given rank and shape.
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongPointer shape);
		LongPointer shapeBuffer(Integer rank, Integer dtype, LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongBuffer shape);
		LongBuffer shapeBuffer(Integer rank, Integer dtype, LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") long[] shape);
		Long() shapeBuffer(Integer rank, Integer dtype, Long() shape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer buffer);
		LongPointer shapeBuffer(Integer rank, Integer dtype, LongPointer shape, LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer buffer);
		LongBuffer shapeBuffer(Integer rank, Integer dtype, LongBuffer shape, LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeBuffer(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] buffer);
		Long() shapeBuffer(Integer rank, Integer dtype, Long() shape, Long() buffer)

		''' <summary>
		''' Get the shape info buffer
		''' for the given rank and shape.
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongPointer shape);
		LongPointer shapeBufferFortran(Integer rank, Integer dtype, LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongBuffer shape);
		LongBuffer shapeBufferFortran(Integer rank, Integer dtype, LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") long[] shape);
		Long() shapeBufferFortran(Integer rank, Integer dtype, Long() shape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer output);
		LongPointer shapeBufferFortran(Integer rank, Integer dtype, LongPointer shape, LongPointer output)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer output);
		LongBuffer shapeBufferFortran(Integer rank, Integer dtype, LongBuffer shape, LongBuffer output)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeBufferFortran(int rank, @Cast("sd::DataType") int dtype, @Cast("const Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] output);
		Long() shapeBufferFortran(Integer rank, Integer dtype, Long() shape, Long() output)

	' #ifdef __CUDACC__
	' #endif



	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStridesFortran(@Cast("const Nd4jLong*") LongPointer shape, int rank);
		LongPointer calcStridesFortran( LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStridesFortran(@Cast("const Nd4jLong*") LongBuffer shape, int rank);
		LongBuffer calcStridesFortran( LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStridesFortran(@Cast("const Nd4jLong*") long[] shape, int rank);
		Long() calcStridesFortran( Long() shape, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStridesFortran(@Cast("const Nd4jLong*") LongPointer shape, int rank, @Cast("Nd4jLong*") LongPointer ret);
		LongPointer calcStridesFortran( LongPointer shape, Integer rank, LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStridesFortran(@Cast("const Nd4jLong*") LongBuffer shape, int rank, @Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer calcStridesFortran( LongBuffer shape, Integer rank, LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStridesFortran(@Cast("const Nd4jLong*") long[] shape, int rank, @Cast("Nd4jLong*") long[] ret);
		Long() calcStridesFortran( Long() shape, Integer rank, Long() ret)

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStrides(@Cast("const Nd4jLong*") LongPointer shape, int rank);
		LongPointer calcStrides( LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStrides(@Cast("const Nd4jLong*") LongBuffer shape, int rank);
		LongBuffer calcStrides( LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStrides(@Cast("const Nd4jLong*") long[] shape, int rank);
		Long() calcStrides( Long() shape, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStrides(@Cast("const Nd4jLong*") LongPointer shape, int rank, @Cast("Nd4jLong*") LongPointer ret);
		LongPointer calcStrides( LongPointer shape, Integer rank, LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStrides(@Cast("const Nd4jLong*") LongBuffer shape, int rank, @Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer calcStrides( LongBuffer shape, Integer rank, LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStrides(@Cast("const Nd4jLong*") long[] shape, int rank, @Cast("Nd4jLong*") long[] ret);
		Long() calcStrides( Long() shape, Integer rank, Long() ret)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(@Cast("Nd4jLong*") LongPointer shape, byte order);
		public native void updateStrides( LongPointer shape, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(@Cast("Nd4jLong*") LongBuffer shape, byte order);
		public native void updateStrides( LongBuffer shape, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(@Cast("Nd4jLong*") long[] shape, byte order);
		public native void updateStrides( Long() shape, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(int rank, @Cast("const Nd4jLong*") LongPointer shapeOnly, @Cast("Nd4jLong*") LongPointer stridesOnly, byte order);
		public native void updateStrides(Integer rank, LongPointer shapeOnly, LongPointer stridesOnly, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(int rank, @Cast("const Nd4jLong*") LongBuffer shapeOnly, @Cast("Nd4jLong*") LongBuffer stridesOnly, byte order);
		public native void updateStrides(Integer rank, LongBuffer shapeOnly, LongBuffer stridesOnly, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void updateStrides(int rank, @Cast("const Nd4jLong*") long[] shapeOnly, @Cast("Nd4jLong*") long[] stridesOnly, byte order);
		public native void updateStrides(Integer rank, Long() shapeOnly, Long() stridesOnly, SByte order)


	' check whether input dimensions are permuted, not permuted dimensions order have to be 0,....,rank-1

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStridesFortran(@Cast("const Nd4jLong*") LongPointer shape, int rank, int startNum);
		LongPointer calcStridesFortran( LongPointer shape, Integer rank, Integer startNum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStridesFortran(@Cast("const Nd4jLong*") LongBuffer shape, int rank, int startNum);
		LongBuffer calcStridesFortran( LongBuffer shape, Integer rank, Integer startNum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStridesFortran(@Cast("const Nd4jLong*") long[] shape, int rank, int startNum);
		Long() calcStridesFortran( Long() shape, Integer rank, Integer startNum)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStridesFortran(@Cast("const Nd4jLong*") LongPointer shape, int rank, int startNum, @Cast("Nd4jLong*") LongPointer ret);
		LongPointer calcStridesFortran( LongPointer shape, Integer rank, Integer startNum, LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStridesFortran(@Cast("const Nd4jLong*") LongBuffer shape, int rank, int startNum, @Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer calcStridesFortran( LongBuffer shape, Integer rank, Integer startNum, LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStridesFortran(@Cast("const Nd4jLong*") long[] shape, int rank, int startNum, @Cast("Nd4jLong*") long[] ret);
		Long() calcStridesFortran( Long() shape, Integer rank, Integer startNum, Long() ret)

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStrides(@Cast("const Nd4jLong*") LongPointer shape, int rank, int startNum);
		LongPointer calcStrides( LongPointer shape, Integer rank, Integer startNum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStrides(@Cast("const Nd4jLong*") LongBuffer shape, int rank, int startNum);
		LongBuffer calcStrides( LongBuffer shape, Integer rank, Integer startNum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStrides(@Cast("const Nd4jLong*") long[] shape, int rank, int startNum);
		Long() calcStrides( Long() shape, Integer rank, Integer startNum)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer calcStrides(@Cast("const Nd4jLong*") LongPointer shape, int rank, int startNum, @Cast("Nd4jLong*") LongPointer ret);
		LongPointer calcStrides( LongPointer shape, Integer rank, Integer startNum, LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer calcStrides(@Cast("const Nd4jLong*") LongBuffer shape, int rank, int startNum, @Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer calcStrides( LongBuffer shape, Integer rank, Integer startNum, LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] calcStrides(@Cast("const Nd4jLong*") long[] shape, int rank, int startNum, @Cast("Nd4jLong*") long[] ret);
		Long() calcStrides( Long() shape, Integer rank, Integer startNum, Long() ret)

	''' <param name="toCopy"> the shape to copy </param>
	''' <returns> a copy of the original struct </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native ShapeInformation shapeCopy(ShapeInformation toCopy);
		public native ShapeInformation shapeCopy(ShapeInformation toCopy)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideDescendingCAscendingF(@Cast("const Nd4jLong*") LongPointer shapeBuffer);
		Boolean strideDescendingCAscendingF( LongPointer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideDescendingCAscendingF(@Cast("const Nd4jLong*") LongBuffer shapeBuffer);
		Boolean strideDescendingCAscendingF( LongBuffer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean strideDescendingCAscendingF(@Cast("const Nd4jLong*") long[] shapeBuffer);
		Boolean strideDescendingCAscendingF( Long() shapeBuffer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isContiguous(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Boolean isContiguous( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isContiguous(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Boolean isContiguous( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isContiguous(@Cast("const Nd4jLong*") long[] shapeInfo);
		Boolean isContiguous( Long() shapeInfo)


	''' <summary>
	''' copy-past from java hasDefaultStridesForShape function
	''' check whether array is not permuted and has contiguous elements in memory
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean areStridesDefault(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Boolean areStridesDefault( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean areStridesDefault(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Boolean areStridesDefault( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean areStridesDefault(@Cast("const Nd4jLong*") long[] shapeInfo);
		Boolean areStridesDefault( Long() shapeInfo)


	''' <summary>
	''' Compute the element wise stride
	''' for a given shape/stride configuration </summary>
	''' <param name="rank"> the rank of the shape/stride </param>
	''' <param name="shape"> the shape </param>
	''' <param name="stride"> the stride </param>
	''' <param name="isFOrder"> 0 or 1 for whether the array is f
	''' ordered or not </param>
	''' <returns> 0 if there is no element wise stride the
	''' element wise stride of reshape(1,length) otherwise </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer stride, int isFOrder);
		public native Integer computeElementWiseStride(Integer rank, LongPointer shape, LongPointer stride, Integer isFOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer stride, int isFOrder);
		public native Integer computeElementWiseStride(Integer rank, LongBuffer shape, LongBuffer stride, Integer isFOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] stride, int isFOrder);
		public native Integer computeElementWiseStride(Integer rank, Long() shape, Long() stride, Integer isFOrder)

	''' <summary>
	''' Compute the element wise stride
	''' for a given shape/stride configuration </summary>
	''' <param name="rank"> the rank of the shape/stride </param>
	''' <param name="shape"> the shape </param>
	''' <param name="stride"> the stride </param>
	''' <param name="isFOrder"> 0 or 1 for whether the array is f
	''' ordered or not </param>
	''' <returns> 0 if there is no element wise stride the
	''' element wise stride of reshape(1,length) otherwise </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer stride, int isFOrder, @Cast("const Nd4jLong*") LongPointer dimension, int dimensionLength);
		public native Integer computeElementWiseStride(Integer rank, LongPointer shape, LongPointer stride, Integer isFOrder, LongPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer stride, int isFOrder, @Cast("const Nd4jLong*") LongBuffer dimension, int dimensionLength);
		public native Integer computeElementWiseStride(Integer rank, LongBuffer shape, LongBuffer stride, Integer isFOrder, LongBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int computeElementWiseStride(int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] stride, int isFOrder, @Cast("const Nd4jLong*") long[] dimension, int dimensionLength);
		public native Integer computeElementWiseStride(Integer rank, Long() shape, Long() stride, Integer isFOrder, Long() dimension, Integer dimensionLength)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride);
		LongPointer shapeInfoOnlyShapeAndStride( LongPointer shapeInfo, LongPointer dimension, Integer dimensionLength, Boolean reverseCopyStride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride);
		LongBuffer shapeInfoOnlyShapeAndStride( LongBuffer shapeInfo, LongBuffer dimension, Integer dimensionLength, Boolean reverseCopyStride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride);
		Long() shapeInfoOnlyShapeAndStride( Long() shapeInfo, Long() dimension, Integer dimensionLength, Boolean reverseCopyStride)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride, @Cast("Nd4jLong*") LongPointer buffer);
		LongPointer shapeInfoOnlyShapeAndStride( LongPointer shapeInfo, LongPointer dimension, Integer dimensionLength, Boolean reverseCopyStride, LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride, @Cast("Nd4jLong*") LongBuffer buffer);
		LongBuffer shapeInfoOnlyShapeAndStride( LongBuffer shapeInfo, LongBuffer dimension, Integer dimensionLength, Boolean reverseCopyStride, LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeInfoOnlyShapeAndStride(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] dimension, int dimensionLength,@Cast("bool") boolean reverseCopyStride, @Cast("Nd4jLong*") long[] buffer);
		Long() shapeInfoOnlyShapeAndStride( Long() shapeInfo, Long() dimension, Integer dimensionLength, Boolean reverseCopyStride, Long() buffer)
	''' 
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="rearrange">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer doPermuteSwap(int length, @Cast("Nd4jLong*") LongPointer shape, IntPointer rearrange);
		LongPointer doPermuteSwap(Integer length, LongPointer shape, IntPointer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer doPermuteSwap(int length, @Cast("Nd4jLong*") LongBuffer shape, IntBuffer rearrange);
		LongBuffer doPermuteSwap(Integer length, LongBuffer shape, IntBuffer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] doPermuteSwap(int length, @Cast("Nd4jLong*") long[] shape, int[] rearrange);
		Long() doPermuteSwap(Integer length, Long() shape, Integer() rearrange)



	''' <summary>
	''' In place permute swap </summary>
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="rearrange"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteSwap(int length, @Cast("Nd4jLong**") PointerPointer shape, IntPointer rearrange);
		public native void doPermuteSwap(Integer length, PointerPointer shape, IntPointer rearrange)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer permuteShapeBuffer(@Cast("const Nd4jLong*") LongPointer shapeBuffer, IntPointer rearrange);
		LongPointer permuteShapeBuffer( LongPointer shapeBuffer, IntPointer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer permuteShapeBuffer(@Cast("const Nd4jLong*") LongBuffer shapeBuffer, IntBuffer rearrange);
		LongBuffer permuteShapeBuffer( LongBuffer shapeBuffer, IntBuffer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] permuteShapeBuffer(@Cast("const Nd4jLong*") long[] shapeBuffer, int[] rearrange);
		Long() permuteShapeBuffer( Long() shapeBuffer, Integer() rearrange)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permuteShapeBufferInPlace(@Cast("Nd4jLong*") LongPointer shapeBuffer, IntPointer rearrange, @Cast("Nd4jLong*") LongPointer out);
		public native void permuteShapeBufferInPlace( LongPointer shapeBuffer, IntPointer rearrange, LongPointer [out])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permuteShapeBufferInPlace(@Cast("Nd4jLong*") LongBuffer shapeBuffer, IntBuffer rearrange, @Cast("Nd4jLong*") LongBuffer out);
		public native void permuteShapeBufferInPlace( LongBuffer shapeBuffer, IntBuffer rearrange, LongBuffer [out])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permuteShapeBufferInPlace(@Cast("Nd4jLong*") long[] shapeBuffer, int[] rearrange, @Cast("Nd4jLong*") long[] out);
		public native void permuteShapeBufferInPlace( Long() shapeBuffer, Integer() rearrange, Long() [out])

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") LongPointer shapeBuffer, @Const IntPointer rearrange, @Cast("Nd4jLong") long len);
		public native void doPermuteShapeInfo( LongPointer shapeBuffer, IntPointer rearrange, Long len)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") LongPointer shapeBuffer, @Const IntPointer rearrange);
		public native void doPermuteShapeInfo( LongPointer shapeBuffer, IntPointer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") LongBuffer shapeBuffer, @Const IntBuffer rearrange, @Cast("Nd4jLong") long len);
		public native void doPermuteShapeInfo( LongBuffer shapeBuffer, IntBuffer rearrange, Long len)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") LongBuffer shapeBuffer, @Const IntBuffer rearrange);
		public native void doPermuteShapeInfo( LongBuffer shapeBuffer, IntBuffer rearrange)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") long[] shapeBuffer, @Const int[] rearrange, @Cast("Nd4jLong") long len);
		public native void doPermuteShapeInfo( Long() shapeBuffer, Integer() rearrange, Long len)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void doPermuteShapeInfo(@Cast("Nd4jLong*") long[] shapeBuffer, @Const int[] rearrange);
		public native void doPermuteShapeInfo( Long() shapeBuffer, Integer() rearrange)

		''' <summary>
		''' Rearrange the permute indexes
		''' according to which  dimensions are specified.
		''' 
		''' For example, dimension is implicitly:
		''' 0,1,2
		''' 
		''' If you want to do a reduce along dimensions 0 and 1,
		''' you need to permute the indexes to be:
		''' 2,0,1
		''' 
		''' which will give us the ability to ierate along an element
		''' wise stride.
		''' </summary>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer createPermuteIndexes(int originalRank, IntPointer dimension,int dimensionLength);
		LongPointer createPermuteIndexes(Integer originalRank, IntPointer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer createPermuteIndexes(int originalRank, IntBuffer dimension,int dimensionLength);
		LongBuffer createPermuteIndexes(Integer originalRank, IntBuffer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] createPermuteIndexes(int originalRank, int[] dimension,int dimensionLength);
		Long() createPermuteIndexes(Integer originalRank, Integer() dimension,Integer dimensionLength)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer computeResultShape(@Cast("const Nd4jLong*") LongPointer originalShapeBuffer, IntPointer dimension,int dimensionLength);
		LongPointer computeResultShape( LongPointer originalShapeBuffer, IntPointer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer computeResultShape(@Cast("const Nd4jLong*") LongBuffer originalShapeBuffer, IntBuffer dimension,int dimensionLength);
		LongBuffer computeResultShape( LongBuffer originalShapeBuffer, IntBuffer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] computeResultShape(@Cast("const Nd4jLong*") long[] originalShapeBuffer, int[] dimension,int dimensionLength);
		Long() computeResultShape( Long() originalShapeBuffer, Integer() dimension,Integer dimensionLength)

		''' <summary>
		''' This method does inplace transpose of given shapeBuffer
		''' </summary>
		''' <param name="shapeBuffer"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void transposeInplace(@Cast("Nd4jLong*") LongPointer shapeBuffer);
		public native void transposeInplace( LongPointer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void transposeInplace(@Cast("Nd4jLong*") LongBuffer shapeBuffer);
		public native void transposeInplace( LongBuffer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void transposeInplace(@Cast("Nd4jLong*") long[] shapeBuffer);
		public native void transposeInplace( Long() shapeBuffer)


	''' <summary>
	''' Get the ordering for the device </summary>
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="stride"> </param>
	''' <param name="elementStride">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char getOrder(int length, @Cast("Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer stride, int elementStride);
		public native Char getOrder(Integer length, LongPointer shape, LongPointer stride, Integer elementStride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char getOrder(int length, @Cast("Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer stride, int elementStride);
		public native Char getOrder(Integer length, LongBuffer shape, LongBuffer stride, Integer elementStride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char getOrder(int length, @Cast("Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] stride, int elementStride);
		public native Char getOrder(Integer length, Long() shape, Long() stride, Integer elementStride)

	''' <summary>
	''' Ensure that every value in the re arrange
	''' array is unique </summary>
	''' <param name="arr"> </param>
	''' <param name="shape"> </param>
	''' <param name="arrLength"> </param>
	''' <param name="shapeLength">
	''' @return </param>

	''' <summary>
	''' Permute the shape information </summary>
	''' <param name="info"> the shape information to permute </param>
	''' <param name="rearrange"> the order to re arrange </param>
	''' <param name="rank"> the rank of the rearrange array </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permute(@Cast("shape::ShapeInformation**") PointerPointer info, IntPointer rearrange, int rank);
		public native void permute( PointerPointer info, IntPointer rearrange, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permute(@ByPtrPtr ShapeInformation info, IntPointer rearrange, int rank);
		public native void permute( ShapeInformation info, IntPointer rearrange, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permute(@ByPtrPtr ShapeInformation info, IntBuffer rearrange, int rank);
		public native void permute( ShapeInformation info, IntBuffer rearrange, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void permute(@ByPtrPtr ShapeInformation info, int[] rearrange, int rank);
		public native void permute( ShapeInformation info, Integer() rearrange, Integer rank)

	''' <summary>
	''' Returns whether the
	''' given shape is a vector or not </summary>
	''' <param name="shape"> the shape of the array </param>
	''' <param name="rank"> the rank of cthe shape </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") LongPointer shape, int rank);
		public native Integer isVector( LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") LongBuffer shape, int rank);
		public native Integer isVector( LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") long[] shape, int rank);
		public native Integer isVector( Long() shape, Integer rank)


		''' <summary>
		''' When 1 dimension is the whole length of the
		''' array
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") LongPointer shape, int rank);
		public native Integer oneDimEqualToLength( LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") LongBuffer shape, int rank);
		public native Integer oneDimEqualToLength( LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") long[] shape, int rank);
		public native Integer oneDimEqualToLength( Long() shape, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") LongPointer shapeInfo);
		public native Integer oneDimEqualToLength( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") LongBuffer shapeInfo);
		public native Integer oneDimEqualToLength( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int oneDimEqualToLength(@Cast("Nd4jLong*") long[] shapeInfo);
		public native Integer oneDimEqualToLength( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native Integer isVector( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native Integer isVector( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isVector(@Cast("const Nd4jLong*") long[] shapeInfo);
		public native Integer isVector( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isLikeVector(@Cast("const Nd4jLong*") LongPointer shapeInfo, @ByRef IntPointer posOfNonUnityDim);
		Boolean isLikeVector( LongPointer shapeInfo, IntPointer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isLikeVector(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @ByRef IntBuffer posOfNonUnityDim);
		Boolean isLikeVector( LongBuffer shapeInfo, IntBuffer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isLikeVector(@Cast("const Nd4jLong*") long[] shapeInfo, @ByRef int[] posOfNonUnityDim);
		Boolean isLikeVector( Long() shapeInfo, Integer() posOfNonUnityDim)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isCommonVector(@Cast("const Nd4jLong*") LongPointer shapeInfo, @ByRef IntPointer posOfNonUnityDim);
		Boolean isCommonVector( LongPointer shapeInfo, IntPointer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isCommonVector(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @ByRef IntBuffer posOfNonUnityDim);
		Boolean isCommonVector( LongBuffer shapeInfo, IntBuffer posOfNonUnityDim)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isCommonVector(@Cast("const Nd4jLong*") long[] shapeInfo, @ByRef int[] posOfNonUnityDim);
		Boolean isCommonVector( Long() shapeInfo, Integer() posOfNonUnityDim)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isRowVector(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Boolean isRowVector( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isRowVector(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Boolean isRowVector( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isRowVector(@Cast("const Nd4jLong*") long[] shapeInfo);
		Boolean isRowVector( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isColumnVector(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Boolean isColumnVector( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isColumnVector(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Boolean isColumnVector( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isColumnVector(@Cast("const Nd4jLong*") long[] shapeInfo);
		Boolean isColumnVector( Long() shapeInfo)

		''' <summary>
		''' shape - input inShape is shape only, not shapeInfo
		''' returns number of non-unity dimensions in inShape
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int numOfNonUnitDims(int rank, @Cast("const Nd4jLong*") LongPointer inShape);
		public native Integer numOfNonUnitDims(Integer rank, LongPointer inShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int numOfNonUnitDims(int rank, @Cast("const Nd4jLong*") LongBuffer inShape);
		public native Integer numOfNonUnitDims(Integer rank, LongBuffer inShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int numOfNonUnitDims(int rank, @Cast("const Nd4jLong*") long[] inShape);
		public native Integer numOfNonUnitDims(Integer rank, Long() inShape)

		''' <summary>
		''' Returns whether the
		''' given shape is a vector or not </summary>
		''' <param name="shape"> the shape of the array </param>
		''' <param name="rank"> the rank of the shape </param>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") LongPointer shape, int rank);
		public native Integer isMatrix( LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") LongBuffer shape, int rank);
		public native Integer isMatrix( LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") long[] shape, int rank);
		public native Integer isMatrix( Long() shape, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native Integer isMatrix( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native Integer isMatrix( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isMatrix(@Cast("const Nd4jLong*") long[] shapeInfo);
		public native Integer isMatrix( Long() shapeInfo)
	''' <summary>
	''' Returns the shape portion of an information
	''' buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeOf(@Cast("Nd4jLong*") LongPointer shapeInfo);
		LongPointer shapeOf( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeOf(@Cast("Nd4jLong*") LongBuffer shapeInfo);
		LongBuffer shapeOf( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeOf(@Cast("Nd4jLong*") long[] shapeInfo);
		Long() shapeOf( Long() shapeInfo)

	''' <summary>
	''' Return a copy of a buffer.
	''' This buffer allocates memory
	''' that must be freed elsewhere.
	''' </summary>

		''' <summary>
		''' Return a copy of a buffer.
		''' This buffer allocates memory
		''' that must be freed elsewhere.
		''' </summary>
		''' <summary>
		''' Return a copy of a buffer.
		''' This buffer allocates memory
		''' that must be freed elsewhere.
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void copyTo(int length, @Cast("const Nd4jLong*") LongPointer from, @Cast("Nd4jLong*") LongPointer to, @Cast("Nd4jLong*") LongPointer indexes);
		public native void copyTo(Integer length, LongPointer from, LongPointer [to], LongPointer indexes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void copyTo(int length, @Cast("const Nd4jLong*") LongBuffer from, @Cast("Nd4jLong*") LongBuffer to, @Cast("Nd4jLong*") LongBuffer indexes);
		public native void copyTo(Integer length, LongBuffer from, LongBuffer [to], LongBuffer indexes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void copyTo(int length, @Cast("const Nd4jLong*") long[] from, @Cast("Nd4jLong*") long[] to, @Cast("Nd4jLong*") long[] indexes);
		public native void copyTo(Integer length, Long() from, Long() [to], Long() indexes)

	''' <summary>
	''' Permute the given strides
	''' in the given rearrange order </summary>
	''' <param name="toPermute"> the buffer to permute </param>
	''' <param name="shapeRank"> the length of the buffer to permute </param>
	''' <param name="rearrange"> the rearrange order (must be 0 based indexes
	''' and all must be filled in) </param>
	''' <returns> the rearranged array </returns>
		'ND4J_EXPORT _CUDA_HD Nd4jLong *permutedStrides(Nd4jLong *toPermute, int shapeRank, Nd4jLong *rearrange);

	''' <summary>
	''' Return the slice (shape + 1 in pointer arithmetic) </summary>
	''' <param name="shape"> the shape to take the slice of </param>
	''' <returns> the shape array - the first entry </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer slice(@Cast("Nd4jLong*") LongPointer shape);
		LongPointer slice( LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer slice(@Cast("Nd4jLong*") LongBuffer shape);
		LongBuffer slice( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] slice(@Cast("Nd4jLong*") long[] shape);
		Long() slice( Long() shape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int slices(@Cast("Nd4jLong*") LongPointer shapeBuffer);
		public native Integer slices( LongPointer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int slices(@Cast("Nd4jLong*") LongBuffer shapeBuffer);
		public native Integer slices( LongBuffer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int slices(@Cast("Nd4jLong*") long[] shapeBuffer);
		public native Integer slices( Long() shapeBuffer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer sliceOfShapeBuffer(@Cast("Nd4jLong") long sliceIdx, @Cast("Nd4jLong*") LongPointer shapeBuffer);
		LongPointer sliceOfShapeBuffer( Long sliceIdx, LongPointer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer sliceOfShapeBuffer(@Cast("Nd4jLong") long sliceIdx, @Cast("Nd4jLong*") LongBuffer shapeBuffer);
		LongBuffer sliceOfShapeBuffer( Long sliceIdx, LongBuffer shapeBuffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] sliceOfShapeBuffer(@Cast("Nd4jLong") long sliceIdx, @Cast("Nd4jLong*") long[] shapeBuffer);
		Long() sliceOfShapeBuffer( Long sliceIdx, Long() shapeBuffer)
	''' <summary>
	''' Returns the length of the
	''' shape information buffer:
	''' rank * 2 + 3 </summary>
	''' <param name="rank"> the rank to get the shape
	''' info length for </param>
	''' <returns> rank * 2 + 4 </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int shapeInfoLength(int rank);
		public native Integer shapeInfoLength(Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int shapeInfoLength(@Cast("Nd4jLong*") LongPointer shapeInfo);
		public native Integer shapeInfoLength( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int shapeInfoLength(@Cast("Nd4jLong*") LongBuffer shapeInfo);
		public native Integer shapeInfoLength( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int shapeInfoLength(@Cast("Nd4jLong*") long[] shapeInfo);
		public native Integer shapeInfoLength( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("size_t") long shapeInfoByteLength(int rank);
		Long shapeInfoByteLength(Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("size_t") long shapeInfoByteLength(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Long shapeInfoByteLength( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("size_t") long shapeInfoByteLength(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Long shapeInfoByteLength( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("size_t") long shapeInfoByteLength(@Cast("const Nd4jLong*") long[] shapeInfo);
		Long shapeInfoByteLength( Long() shapeInfo)

	''' <summary>
	''' Returns the rank portion of
	''' an information buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native Integer rank( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native Integer rank( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Cast("const Nd4jLong*") long[] shapeInfo);
		public native Integer rank( Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Const IntPointer shapeInfo);
		public native Integer rank( IntPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Const IntBuffer shapeInfo);
		public native Integer rank( IntBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rank(@Const int[] shapeInfo);
		public native Integer rank( Integer() shapeInfo)

		''' <summary>
		'''  returns pointer on elementWiseStride
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer ews(@Cast("Nd4jLong*") LongPointer shapeInfo);
		LongPointer ews( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer ews(@Cast("Nd4jLong*") LongBuffer shapeInfo);
		LongBuffer ews( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] ews(@Cast("Nd4jLong*") long[] shapeInfo);
		Long() ews( Long() shapeInfo)

	''' <summary>
	''' Converts a raw int buffer of the layout:
	''' rank
	''' shape
	''' stride
	''' offset
	''' elementWiseStride
	''' 
	''' where shape and stride are both straight int pointers
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native ShapeInformation infoFromBuffer(@Cast("Nd4jLong*") LongPointer buffer);
		public native ShapeInformation infoFromBuffer( LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native ShapeInformation infoFromBuffer(@Cast("Nd4jLong*") LongBuffer buffer);
		public native ShapeInformation infoFromBuffer( LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native ShapeInformation infoFromBuffer(@Cast("Nd4jLong*") long[] buffer);
		public native ShapeInformation infoFromBuffer( Long() buffer)

	''' <summary>
	''' Returns the stride portion of an information
	''' buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer stride(@Cast("Nd4jLong*") LongPointer buffer);
		LongPointer stride( LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer stride(@Cast("Nd4jLong*") LongBuffer buffer);
		LongBuffer stride( LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] stride(@Cast("Nd4jLong*") long[] buffer);
		Long() stride( Long() buffer)

	''' <summary>
	''' Compute the length of the given shape
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isEmpty(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Boolean isEmpty( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isEmpty(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Boolean isEmpty( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("bool") boolean isEmpty(@Cast("const Nd4jLong*") long[] shapeInfo);
		Boolean isEmpty( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long length(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Long length( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long length(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Long length( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long length(@Cast("const Nd4jLong*") long[] shapeInfo);
		Long length( Long() shapeInfo)

	''' <summary>
	'''*
	''' Returns the offset portion of an information buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long offset(@Cast("Nd4jLong*") LongPointer buffer);
		Long offset( LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long offset(@Cast("Nd4jLong*") LongBuffer buffer);
		Long offset( LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long offset(@Cast("Nd4jLong*") long[] buffer);
		Long offset( Long() buffer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") @ByRef LongPointer extra(@Cast("Nd4jLong*") LongPointer buffer);
		LongPointer extra( LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") @ByRef LongBuffer extra(@Cast("Nd4jLong*") LongBuffer buffer);
		LongBuffer extra( LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") @ByRef long[] extra(@Cast("Nd4jLong*") long[] buffer);
		Long() extra( Long() buffer)

	''' <summary>
	''' Returns the ordering
	''' for this shape information buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char order(@Cast("const Nd4jLong*") LongPointer buffer);
		public native Char order( LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char order(@Cast("const Nd4jLong*") LongBuffer buffer);
		public native Char order( LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native char order(@Cast("const Nd4jLong*") long[] buffer);
		public native Char order( Long() buffer)

	''' <summary>
	''' Returns the type
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long type(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		Long type( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long type(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Long type( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long type(@Cast("const Nd4jLong*") long[] shapeInfo);
		Long type( Long() shapeInfo)

	''' <summary>
	''' Returns the element wise stride for this information
	''' buffer
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long elementWiseStride(@Cast("const Nd4jLong*") LongPointer shapeInfo);
	   Long elementWiseStride( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long elementWiseStride(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
	   Long elementWiseStride( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long elementWiseStride(@Cast("const Nd4jLong*") long[] shapeInfo);
	   Long elementWiseStride( Long() shapeInfo)


		''' <summary>
		''' Returns the element wise stride for this information
		''' buffer
		''' relative to a dimension and ordering for a reduction index
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long reductionIndexElementWiseStride(@Cast("Nd4jLong*") LongPointer buffer, IntPointer dimension, int dimensionLength);
		Long reductionIndexElementWiseStride( LongPointer buffer, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long reductionIndexElementWiseStride(@Cast("Nd4jLong*") LongBuffer buffer, IntBuffer dimension, int dimensionLength);
		Long reductionIndexElementWiseStride( LongBuffer buffer, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long reductionIndexElementWiseStride(@Cast("Nd4jLong*") long[] buffer, int[] dimension, int dimensionLength);
		Long reductionIndexElementWiseStride( Long() buffer, Integer() dimension, Integer dimensionLength)

	''' <summary>
	''' Returns whether
	''' the given shape info buffer
	''' represents a scalar shape
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isScalar(@Cast("const Nd4jLong*") LongPointer info);
		public native Integer isScalar( LongPointer info)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isScalar(@Cast("const Nd4jLong*") LongBuffer info);
		public native Integer isScalar( LongBuffer info)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isScalar(@Cast("const Nd4jLong*") long[] info);
		public native Integer isScalar( Long() info)

	''' <summary>
	''' Returns whether
	''' the given shape information
	''' represents a scalar
	''' shape or not
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int isScalar(ShapeInformation info);
		public native Integer isScalar(ShapeInformation info)

	''' <summary>
	''' Return a copy of this array with the
	''' given index omitted
	''' </summary>
	''' <param name="data">  the data to copy </param>
	''' <param name="indexes"> the index of the item to remove </param>
	''' <param name="dataLength"> the length of the data array </param>
	''' <param name="indexesLength"> the length of the data array </param>
	''' <returns> the new array with the omitted
	''' 
	''' item </returns>

		''' <summary>
		''' Return a copy of this array with the
		''' given index omitted
		''' </summary>
		''' <param name="data">  the data to copy </param>
		''' <param name="indexes"> the index of the item to remove </param>
		''' <param name="dataLength"> the length of the data array </param>
		''' <param name="indexesLength"> the length of the data array </param>
		''' <returns> the new array with the omitted
		''' 
		''' item </returns>

		''' <summary>
		''' Iterate over a given set of indexes
		''' the begin and end indexes are 0 based.
		''' 1 padding is automatically assumed for the ending.
		''' 
		''' For example if you want to iterate over 0 to 4
		''' it will go to 4 rather than 3.
		''' 
		''' indexes should be the indexes to exclude
		''' indexes length should be the length of indexes
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer everyIndexBut(@Cast("const Nd4jLong*") LongPointer indexes,int indexesLength,int begin,int end);
		LongPointer everyIndexBut( LongPointer indexes,Integer indexesLength,Integer begin,Integer [end])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer everyIndexBut(@Cast("const Nd4jLong*") LongBuffer indexes,int indexesLength,int begin,int end);
		LongBuffer everyIndexBut( LongBuffer indexes,Integer indexesLength,Integer begin,Integer [end])
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] everyIndexBut(@Cast("const Nd4jLong*") long[] indexes,int indexesLength,int begin,int end);
		Long() everyIndexBut( Long() indexes,Integer indexesLength,Integer begin,Integer [end])

	''' <summary>
	''' Computes the offset for accessing
	''' a global element given the shape information
	''' and the offset to be read.
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    ND4J_EXPORT int tadOffset(shape::ShapeInformation *xInfo, int offset);

	''' <summary>
	''' Returns a shape
	''' forces the given length to be 2. </summary>
	''' <param name="shape"> the shape to modify </param>
	''' <param name="dimension"> the dimension (row or column)
	''' for the shape to be returned as </param>
	''' <returns> the new shape </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer ensureVectorShape(@Cast("Nd4jLong*") LongPointer shape);
		LongPointer ensureVectorShape( LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer ensureVectorShape(@Cast("Nd4jLong*") LongBuffer shape);
		LongBuffer ensureVectorShape( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] ensureVectorShape(@Cast("Nd4jLong*") long[] shape);
		Long() ensureVectorShape( Long() shape)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer createScalarShapeInfo();
		LongPointer createScalarShapeInfo()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer createScalarShapeInfo(@Cast("Nd4jLong*") LongPointer ret);
		LongPointer createScalarShapeInfo( LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer createScalarShapeInfo(@Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer createScalarShapeInfo( LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] createScalarShapeInfo(@Cast("Nd4jLong*") long[] ret);
		Long() createScalarShapeInfo( Long() ret)

	''' <summary>
	''' Generate an int buffer
	''' up to the given length
	''' at the specified increment
	''' 
	''' </summary>

	''' <summary>
	''' Range between from and two with an
	''' increment of 1
	''' </summary>

	''' <summary>
	''' Keep the given indexes
	''' in the data
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer keep(@Cast("Nd4jLong*") LongPointer data, @Const IntPointer index, int indexLength, int dataLength);
		LongPointer keep( LongPointer data, IntPointer index, Integer indexLength, Integer dataLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer keep(@Cast("Nd4jLong*") LongBuffer data, @Const IntBuffer index, int indexLength, int dataLength);
		LongBuffer keep( LongBuffer data, IntBuffer index, Integer indexLength, Integer dataLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] keep(@Cast("Nd4jLong*") long[] data, @Const int[] index, int indexLength, int dataLength);
		Long() keep( Long() data, Integer() index, Integer indexLength, Integer dataLength)

	''' <summary>
	''' Generate reverse copy of the data </summary>
	''' <param name="data"> </param>
	''' <param name="length">
	''' @return </param>
	''' 
	''' <param name="arr1"> </param>
	''' <param name="arr1Length"> </param>
	''' <param name="arr2"> </param>
	''' <param name="arr2Length">
	''' @return </param>

	''' 
	''' <param name="numArrays"> </param>
	''' <param name="numTotalElements"> </param>
	''' <param name="arr"> </param>
	''' <param name="lengths">
	''' @return </param>

	''' <summary>
	''' Get the length per slice of the
	''' given shape and the dimension </summary>
	''' <param name="rank"> the rank of the shape </param>
	''' <param name="shape"> the shape of to get
	''' the length per slice for </param>
	''' <param name="dimension"> the dimension to
	''' get the length per slice for </param>
	''' <param name="dimensionLength"> the length of the dimension array </param>
	''' <returns> the length per slice of the given shape
	''' along the given dimension </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long lengthPerSlice(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Const IntPointer dimension, int dimensionLength);
		Long lengthPerSlice(Integer rank, LongPointer shape, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long lengthPerSlice(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Const IntBuffer dimension, int dimensionLength);
		Long lengthPerSlice(Integer rank, LongBuffer shape, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long lengthPerSlice(int rank, @Cast("const Nd4jLong*") long[] shape, @Const int[] dimension, int dimensionLength);
		Long lengthPerSlice(Integer rank, Long() shape, Integer() dimension, Integer dimensionLength)

	''' <summary>
	''' calculates the offset for a tensor </summary>
	''' <param name="index"> </param>
	''' <param name="arr"> </param>
	''' <param name="tensorShape">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long sliceOffsetForTensor(int rank, int index, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer tensorShape, int tensorShapeLength, @Const IntPointer dimension, int dimensionLength);
		Long sliceOffsetForTensor(Integer rank, Integer index, LongPointer shape, LongPointer tensorShape, Integer tensorShapeLength, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long sliceOffsetForTensor(int rank, int index, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer tensorShape, int tensorShapeLength, @Const IntBuffer dimension, int dimensionLength);
		Long sliceOffsetForTensor(Integer rank, Integer index, LongBuffer shape, LongBuffer tensorShape, Integer tensorShapeLength, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long sliceOffsetForTensor(int rank, int index, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] tensorShape, int tensorShapeLength, @Const int[] dimension, int dimensionLength);
		Long sliceOffsetForTensor(Integer rank, Integer index, Long() shape, Long() tensorShape, Integer tensorShapeLength, Integer() dimension, Integer dimensionLength)

	''' <summary>
	''' calculates the offset for a tensor </summary>
	''' <param name="index"> </param>
	''' <param name="arr"> </param>
	''' <param name="tensorShape">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long sliceOffsetForTensor(int index,int tensorLength,int lengthPerSlice2);
		Long sliceOffsetForTensor(Integer index,Integer tensorLength,Integer lengthPerSlice2)
	''' <summary>
	''' Computes the tensor along dimension
	''' offset </summary>
	''' <param name="index"> the index to get the offset for the tad for </param>
	''' <param name="rank"> the rank of the shapes and strides </param>
	''' <param name="info"> the shape information to use for tad </param>
	''' <param name="dimension"> the dimensions to use for computing the tensor along dimensions </param>
	'    ND4J_EXPORT _CUDA_HD int offset(int index,
	'                         int rank,
	'                         shape::ShapeInformation *info,
	'                         Nd4jLong *dimension,
	'                         int dimensionLength);


	''' <summary>
	''' Computes the number
	''' of tensors along
	''' a given dimension
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(int rank, int length, @Cast("Nd4jLong*") LongPointer shape, IntPointer dimension, int dimensionLength);
		Long tensorsAlongDimension(Integer rank, Integer length, LongPointer shape, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(int rank, int length, @Cast("Nd4jLong*") LongBuffer shape, IntBuffer dimension, int dimensionLength);
		Long tensorsAlongDimension(Integer rank, Integer length, LongBuffer shape, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(int rank, int length, @Cast("Nd4jLong*") long[] shape, int[] dimension, int dimensionLength);
		Long tensorsAlongDimension(Integer rank, Integer length, Long() shape, Integer() dimension, Integer dimensionLength)

	''' <summary>
	''' Computes the number
	''' of tensors along
	''' a given dimension
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(@Cast("Nd4jLong*") LongPointer shapeInfo, IntPointer dimension, int dimensionLength);
		Long tensorsAlongDimension( LongPointer shapeInfo, IntPointer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(@Cast("Nd4jLong*") LongBuffer shapeInfo, IntBuffer dimension, int dimensionLength);
		Long tensorsAlongDimension( LongBuffer shapeInfo, IntBuffer dimension, Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long tensorsAlongDimension(@Cast("Nd4jLong*") long[] shapeInfo, int[] dimension, int dimensionLength);
		Long tensorsAlongDimension( Long() shapeInfo, Integer() dimension, Integer dimensionLength)



	''' <summary>
	''' Returns the tensor along dimension
	''' for the given block index </summary>
	''' <param name="blockSize"> </param>
	''' <param name="blockIdx"> </param>
	''' <param name="i">
	''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadForBlockIndex(int blockSize, int blockIdx, int i);
		public native Integer tadForBlockIndex(Integer blockSize, Integer blockIdx, Integer i)

	''' <summary>
	''' Computes the number of tads per block
	''' 
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadsPerBlock(int blockSize, int tads);
		public native Integer tadsPerBlock(Integer blockSize, Integer tads)

	'    ND4J_EXPORT _CUDA_HD Nd4jLong *tadShapeInfo(int index, Nd4jLong *xShapeInfo, Nd4jLong *dimension,
	'                                int dimensionLength);

	''' <summary>
	''' Returns a shape buffer
	''' for the shape information metadata.
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer toShapeBuffer(ShapeInformation info);
		LongPointer toShapeBuffer(ShapeInformation info)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer toShapeBuffer(ShapeInformation info, @Cast("Nd4jLong*") LongPointer ret);
		LongPointer toShapeBuffer(ShapeInformation info, LongPointer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer toShapeBuffer(ShapeInformation info, @Cast("Nd4jLong*") LongBuffer ret);
		LongBuffer toShapeBuffer(ShapeInformation info, LongBuffer ret)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] toShapeBuffer(ShapeInformation info, @Cast("Nd4jLong*") long[] ret);
		Long() toShapeBuffer(ShapeInformation info, Long() ret)

	''' <summary>
	''' Returns the number of elements per thread
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    int numElementsPerThread(int N);

	''' <summary>
	''' Returns the block starting index
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    int blockStartingIndex(int N);

	''' <summary>
	''' Returns the thread starting index
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    int threadStartingIndex(int N, int stride, int offset);

	''' <summary>
	''' Returns the thread ending index
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    int threadEndingIndex(int N, int stride, int offset);

	''' <summary>
	''' Returns indexing information
	''' for the current kernel invocation
	''' </summary>
	'#ifdef __CUDACC__
	'    __device__
	'#endif
	'    CurrentIndexing *currentIndex(int N, int offset, int stride);

	''' <summary>
	''' Given an linear index, element wise stride
	''' and the length of each tad
	''' map a linear index to a tad </summary>
	''' <param name="i"> the index to map </param>
	''' <param name="the"> element wise stride for the tads </param>
	''' <param name="numElementsPerTad"> the number of elements
	''' per tad </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadIndex(int i, int elementWiseStride, int numElementsPerTad);
		public native Integer tadIndex(Integer i, Integer elementWiseStride, Integer numElementsPerTad)

	''' <summary>
	''' Map a tad to a
	''' reduction index. </summary>
	''' <param name="tadIndexForOriginal"> the original tad index for the
	''' split up problem (eg: split is dimension 3 mapping to a 2,3 problem) </param>
	''' <param name="tadsForReduced"> the number of tads for the shrunk down problem (eg: 2,3) </param>
	''' <param name="tadsForOriginal"> the number of tads for the smaller problem (eg: 3) </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int reductionIndexForTad(int tadIndexForOriginal, int tadsForReduced, int tadsForOriginal);
		public native Integer reductionIndexForTad(Integer tadIndexForOriginal, Integer tadsForReduced, Integer tadsForOriginal)

	''' <summary>
	''' Computes the number of tads
	''' per reduce index for the
	''' reduction tad.
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadsPerReduceIndex(int tadsForReduce, int tadsForOriginal);
		public native Integer tadsPerReduceIndex(Integer tadsForReduce, Integer tadsForOriginal)

	''' <summary>
	''' Maps a linear index to a reduction index </summary>
	''' <param name="i"> the linear index to map </param>
	''' <param name="elementWiseStride"> the element wise stride
	''' for the multiple problem </param>
	''' <param name="tadNum"> the number of tads for the shrunken problem </param>
	''' <param name="originalTadNum"> the tad number for the reduced version of the problem </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int reductionIndexForLinear(int i, int elementWiseStride, int numElementsPerTad, int tadNum, int originalTadNum);
		public native Integer reductionIndexForLinear(Integer i, Integer elementWiseStride, Integer numElementsPerTad, Integer tadNum, Integer originalTadNum)

	''' <summary>
	''' Returns the prod of the data
	''' up to the given length
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long prodLong(@Cast("const Nd4jLong*") LongPointer data, int length);
		Long prodLong( LongPointer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long prodLong(@Cast("const Nd4jLong*") LongBuffer data, int length);
		Long prodLong( LongBuffer data, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long prodLong(@Cast("const Nd4jLong*") long[] data, int length);
		Long prodLong( Long() data, Integer length)

		''' <summary>
		''' Returns the rear most left over item not present in
		''' the dimension array. This assumes that the dimension array is sorted.
		''' 
		''' For example, given a dimension array of:
		''' 0,2
		''' 
		''' and
		''' 
		''' 12,4,2,1 in data
		''' 
		''' You end up with 1 (data[3])
		''' since the first item won't match
		''' the last item of the dimension array
		''' </summary>

	'    ND4J_EXPORT _CUDA_HD int rearMostLeftOverItem(Nd4jLong *data,int length,Nd4jLong *dimension,int dimensionLength);

		''' <summary>
		''' Get an offset for retrieval
		''' from a data buffer
		''' based on the given
		''' shape stride and given indices </summary>
		''' <param name="baseOffset"> the offset to start from </param>
		''' <param name="shape"> the shape of the array </param>
		''' <param name="stride"> the stride of the array </param>
		''' <param name="indices"> the indices to iterate over </param>
		''' <returns> the double at the specified index </returns>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( LongPointer shapeInfo, LongPointer coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer coords);
		Long getOffset( LongPointer shapeInfo, LongPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( LongBuffer shapeInfo, LongBuffer coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer coords);
		Long getOffset( LongBuffer shapeInfo, LongBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( Long() shapeInfo, Long() coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] coords);
		Long getOffset( Long() shapeInfo, Long() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( LongPointer shapeInfo, IntPointer coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer coords);
		Long getOffset( LongPointer shapeInfo, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( LongBuffer shapeInfo, IntBuffer coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer coords);
		Long getOffset( LongBuffer shapeInfo, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] coords, @Cast("Nd4jLong") long baseOffset);
		Long getOffset( Long() shapeInfo, Integer() coords, Long baseOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] coords);
		Long getOffset( Long() shapeInfo, Integer() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer coords, @Const IntPointer dims);
		Long getOffset( LongPointer shapeInfo, IntPointer coords, IntPointer dims)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer coords, @Const IntBuffer dims);
		Long getOffset( LongBuffer shapeInfo, IntBuffer coords, IntBuffer dims)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getOffset(@Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] coords, @Const int[] dims);
		Long getOffset( Long() shapeInfo, Integer() coords, Integer() dims) ' length of dims is equal to rank of shapeInfo

		' all three arrays should have same rank
		' all three arrays should have same dimensions or some of them are 1 (that is satisfy broadcasting principle), strides may be different
		' shapeInfo1 - first array should have max length compared to rest of two arrays
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void getOffsetBroadcast(@Cast("const Nd4jLong") long startInd, @Cast("const Nd4jLong") long ind, @Cast("const Nd4jLong*") LongPointer shapeInfo1, @Cast("const Nd4jLong*") LongPointer shapeInfo2, @Cast("const Nd4jLong*") LongPointer shapeInfo3, @Cast("const bool") boolean sameOffsets12, @Cast("const bool") boolean sameOffsets13, IntPointer coords, @Cast("Nd4jLong*") @ByRef LongPointer offset1, @Cast("Nd4jLong*") @ByRef LongPointer offset2, @Cast("Nd4jLong*") @ByRef LongPointer offset3);
		public native void getOffsetBroadcast( Long startInd, Long ind, LongPointer shapeInfo1, LongPointer shapeInfo2, LongPointer shapeInfo3, Boolean sameOffsets12, Boolean sameOffsets13, IntPointer coords, @ByRef LongPointer offset1, @ByRef LongPointer offset2, @ByRef LongPointer offset3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void getOffsetBroadcast(@Cast("const Nd4jLong") long startInd, @Cast("const Nd4jLong") long ind, @Cast("const Nd4jLong*") LongBuffer shapeInfo1, @Cast("const Nd4jLong*") LongBuffer shapeInfo2, @Cast("const Nd4jLong*") LongBuffer shapeInfo3, @Cast("const bool") boolean sameOffsets12, @Cast("const bool") boolean sameOffsets13, IntBuffer coords, @Cast("Nd4jLong*") @ByRef LongBuffer offset1, @Cast("Nd4jLong*") @ByRef LongBuffer offset2, @Cast("Nd4jLong*") @ByRef LongBuffer offset3);
		public native void getOffsetBroadcast( Long startInd, Long ind, LongBuffer shapeInfo1, LongBuffer shapeInfo2, LongBuffer shapeInfo3, Boolean sameOffsets12, Boolean sameOffsets13, IntBuffer coords, @ByRef LongBuffer offset1, @ByRef LongBuffer offset2, @ByRef LongBuffer offset3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void getOffsetBroadcast(@Cast("const Nd4jLong") long startInd, @Cast("const Nd4jLong") long ind, @Cast("const Nd4jLong*") long[] shapeInfo1, @Cast("const Nd4jLong*") long[] shapeInfo2, @Cast("const Nd4jLong*") long[] shapeInfo3, @Cast("const bool") boolean sameOffsets12, @Cast("const bool") boolean sameOffsets13, int[] coords, @Cast("Nd4jLong*") @ByRef long[] offset1, @Cast("Nd4jLong*") @ByRef long[] offset2, @Cast("Nd4jLong*") @ByRef long[] offset3);
		public native void getOffsetBroadcast( Long startInd, Long ind, Long() shapeInfo1, Long() shapeInfo2, Long() shapeInfo3, Boolean sameOffsets12, Boolean sameOffsets13, Integer() coords, @ByRef Long() offset1, @ByRef Long() offset2, @ByRef Long() offset3)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer createShapeInfo(@Cast("Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer stride, int rank);
		LongPointer createShapeInfo( LongPointer shape, LongPointer stride, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer createShapeInfo(@Cast("Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer stride, int rank);
		LongBuffer createShapeInfo( LongBuffer shape, LongBuffer stride, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] createShapeInfo(@Cast("Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] stride, int rank);
		Long() createShapeInfo( Long() shape, Long() stride, Integer rank)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer createShapeInfo(@Cast("Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer stride, int rank, @Cast("Nd4jLong*") LongPointer buffer);
		LongPointer createShapeInfo( LongPointer shape, LongPointer stride, Integer rank, LongPointer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer createShapeInfo(@Cast("Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer stride, int rank, @Cast("Nd4jLong*") LongBuffer buffer);
		LongBuffer createShapeInfo( LongBuffer shape, LongBuffer stride, Integer rank, LongBuffer buffer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] createShapeInfo(@Cast("Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] stride, int rank, @Cast("Nd4jLong*") long[] buffer);
		Long() createShapeInfo( Long() shape, Long() stride, Integer rank, Long() buffer)

		''' <summary>
		''' Convert a linear index to the corresponding coordinates
		''' for example if shape is {2, 4}, then index 5 corresponds to coordinates [1, 1]
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer coords);
		public native void index2coords( Long index, LongPointer shapeInfo, LongPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer coords);
		public native void index2coords( Long index, LongBuffer shapeInfo, LongBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] coords);
		public native void index2coords( Long index, Long() shapeInfo, Long() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo, IntPointer coords);
		public native void index2coords( Long index, LongPointer shapeInfo, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo, IntBuffer coords);
		public native void index2coords( Long index, LongBuffer shapeInfo, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo, int[] coords);
		public native void index2coords( Long index, Long() shapeInfo, Integer() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("Nd4jLong*") LongPointer coords);
		public native void index2coords( Long index, Integer rank, LongPointer shape, LongPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("Nd4jLong*") LongBuffer coords);
		public native void index2coords( Long index, Integer rank, LongBuffer shape, LongBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("Nd4jLong*") long[] coords);
		public native void index2coords( Long index, Integer rank, Long() shape, Long() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") LongPointer shape, IntPointer coords);
		public native void index2coords( Long index, Integer rank, LongPointer shape, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") LongBuffer shape, IntBuffer coords);
		public native void index2coords( Long index, Integer rank, LongBuffer shape, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, int rank, @Cast("const Nd4jLong*") long[] shape, int[] coords);
		public native void index2coords( Long index, Integer rank, Long() shape, Integer() coords)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer coords);
		public native void index2coordsCPU( Long startIndex, Long index, LongPointer shapeInfo, LongPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer coords);
		public native void index2coordsCPU( Long startIndex, Long index, LongBuffer shapeInfo, LongBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] coords);
		public native void index2coordsCPU( Long startIndex, Long index, Long() shapeInfo, Long() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo, IntPointer coords);
		public native void index2coordsCPU( Long startIndex, Long index, LongPointer shapeInfo, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo, IntBuffer coords);
		public native void index2coordsCPU( Long startIndex, Long index, LongBuffer shapeInfo, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coordsCPU(@Cast("const Nd4jLong") long startIndex, @Cast("const Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo, int[] coords);
		public native void index2coordsCPU( Long startIndex, Long index, Long() shapeInfo, Integer() coords)
		' ND4J_EXPORT _CUDA_HD void index2coordsCPU(const Nd4jLong& startIndex, const Nd4jLong& index, const Nd4jLong *shapeInfo, const int* dims, Nd4jLong *coords);

		''' <summary>
		''' take into account only dimensions stored in tadDims, tadDims must be sorted in increasing order!
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer dims, int dimsLen, IntPointer coords);
		public native void index2coords( Long index, LongPointer shapeInfo, IntPointer dims, Integer dimsLen, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer dims, int dimsLen, IntBuffer coords);
		public native void index2coords( Long index, LongBuffer shapeInfo, IntBuffer dims, Integer dimsLen, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void index2coords(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] dims, int dimsLen, int[] coords);
		public native void index2coords( Long index, Long() shapeInfo, Integer() dims, Integer dimsLen, Integer() coords)

		''' <summary>
		''' Convert coordinates to the corresponding linear index (sequence number in other words)
		''' for example if shape is {2, 4} and coordinates [1, 1] then index 5 is returned
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer coords);
		Long coords2index( LongPointer shapeInfo, LongPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer coords);
		Long coords2index( LongBuffer shapeInfo, LongBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] coords);
		Long coords2index( Long() shapeInfo, Long() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer coords);
		Long coords2index( LongPointer shapeInfo, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer coords);
		Long coords2index( LongBuffer shapeInfo, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] coords);
		Long coords2index( Long() shapeInfo, Integer() coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Const IntPointer coords);
		Long coords2index(Integer rank, LongPointer shape, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Const IntBuffer coords);
		Long coords2index(Integer rank, LongBuffer shape, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(int rank, @Cast("const Nd4jLong*") long[] shape, @Const int[] coords);
		Long coords2index(Integer rank, Long() shape, Integer() coords)
		''' <summary>
		''' take into account only dimensions stored in tadDims, tadDims must be sorted in increasing order!
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Const IntPointer dims, int dimsSize, @Const IntPointer coords);
		Long coords2index( LongPointer shapeInfo, IntPointer dims, Integer dimsSize, IntPointer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Const IntBuffer dims, int dimsSize, @Const IntBuffer coords);
		Long coords2index( LongBuffer shapeInfo, IntBuffer dims, Integer dimsSize, IntBuffer coords)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long coords2index(@Cast("const Nd4jLong*") long[] shapeInfo, @Const int[] dims, int dimsSize, @Const int[] coords);
		Long coords2index( Long() shapeInfo, Integer() dims, Integer dimsSize, Integer() coords)

	   ''' <summary>
	   ''' increment n-dimensional array by one iteration by changing coord appropriately
	   ''' for example we have array with shape {2, 3}:
	   ''' - if input coord = {0,1}, then output coord = {0,2}
	   ''' - if input coord = {0,2}, then output coord = {1,0}
	   ''' so the aim is to produce following subsequence of coord: {0,0}, {0,1}, {0,2}, {1,0}, {1,1}, {1,2}
	   ''' </summary>

	'    calculates an array buffer offset for given "index" using following formula: offset = coord_0*stride_0 + coord_1*stride_1 + ... + coord_{rank-1}*stride_{rank-1}
	'   
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("uint") int getIndexOffset(@Cast("uint") int index, @Cast("const uint*") IntPointer shapeInfo);
		Integer getIndexOffset( Integer index, IntPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("uint") int getIndexOffset(@Cast("uint") int index, @Cast("const uint*") IntBuffer shapeInfo);
		Integer getIndexOffset( Integer index, IntBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("uint") int getIndexOffset(@Cast("uint") int index, @Cast("const uint*") int[] shapeInfo);
		Integer getIndexOffset( Integer index, Integer() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getIndexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer shapeInfo);
		Long getIndexOffset( Long index, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getIndexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer shapeInfo);
		Long getIndexOffset( Long index, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long getIndexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") long[] shapeInfo);
		Long getIndexOffset( Long index, Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long indexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongPointer lShapeInfo, @Cast("const uint*") IntPointer uShapeInfo, @Cast("const bool") boolean useUnsigned);
		Long indexOffset( Long index, LongPointer lShapeInfo, IntPointer uShapeInfo, Boolean useUnsigned)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long indexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") LongBuffer lShapeInfo, @Cast("const uint*") IntBuffer uShapeInfo, @Cast("const bool") boolean useUnsigned);
		Long indexOffset( Long index, LongBuffer lShapeInfo, IntBuffer uShapeInfo, Boolean useUnsigned)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long indexOffset(@Cast("Nd4jLong") long index, @Cast("const Nd4jLong*") long[] lShapeInfo, @Cast("const uint*") int[] uShapeInfo, @Cast("const bool") boolean useUnsigned);
		Long indexOffset( Long index, Long() lShapeInfo, Integer() uShapeInfo, Boolean useUnsigned)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfo(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native void printShapeInfo( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfo(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native void printShapeInfo( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfo(@Cast("const Nd4jLong*") long[] shapeInfo);
		public native void printShapeInfo( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native void printShapeInfoLinear( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native void printShapeInfoLinear( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("const Nd4jLong*") long[] shapeInfo);
		public native void printShapeInfoLinear( Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, @Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native void printShapeInfoLinear( String msg, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, @Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native void printShapeInfoLinear( BytePointer msg, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, @Cast("const Nd4jLong*") long[] shapeInfo);
		public native void printShapeInfoLinear( String msg, Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, @Cast("const Nd4jLong*") LongPointer shapeInfo);
		public native void printShapeInfoLinear( BytePointer msg, LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, @Cast("const Nd4jLong*") LongBuffer shapeInfo);
		public native void printShapeInfoLinear( String msg, LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, @Cast("const Nd4jLong*") long[] shapeInfo);
		public native void printShapeInfoLinear( BytePointer msg, Long() shapeInfo)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides);
		public native void printShapeInfoLinear( String msg, Integer rank, LongPointer shape, LongPointer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides);
		public native void printShapeInfoLinear( BytePointer msg, Integer rank, LongBuffer shape, LongBuffer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides);
		public native void printShapeInfoLinear( String msg, Integer rank, Long() shape, Long() strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides);
		public native void printShapeInfoLinear( BytePointer msg, Integer rank, LongPointer shape, LongPointer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") String msg, int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides);
		public native void printShapeInfoLinear( String msg, Integer rank, LongBuffer shape, LongBuffer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printShapeInfoLinear(@Cast("char*") BytePointer msg, int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides);
		public native void printShapeInfoLinear( BytePointer msg, Integer rank, Long() shape, Long() strides)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Cast("const Nd4jLong*") LongPointer arr, int length);
		public native void printIntArray( LongPointer arr, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Cast("const Nd4jLong*") LongBuffer arr, int length);
		public native void printIntArray( LongBuffer arr, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Cast("const Nd4jLong*") long[] arr, int length);
		public native void printIntArray( Long() arr, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Const IntPointer arr, int length);
		public native void printIntArray( IntPointer arr, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Const IntBuffer arr, int length);
		public native void printIntArray( IntBuffer arr, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printIntArray(@Const int[] arr, int length);
		public native void printIntArray( Integer() arr, Integer length)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printArray(FloatPointer arr,int length);
		public native void printArray(FloatPointer arr,Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printArray(FloatBuffer arr,int length);
		public native void printArray(FloatBuffer arr,Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void printArray(float[] arr,int length);
		public native void printArray(Single() arr,Integer length)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer shapeBufferOfNpy(int rank, @Cast("unsigned int*") IntPointer shape,@Cast("bool") boolean fortranOrder);
		LongPointer shapeBufferOfNpy(Integer rank, IntPointer shape, Boolean fortranOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer shapeBufferOfNpy(int rank, @Cast("unsigned int*") IntBuffer shape,@Cast("bool") boolean fortranOrder);
		LongBuffer shapeBufferOfNpy(Integer rank, IntBuffer shape, Boolean fortranOrder)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] shapeBufferOfNpy(int rank, @Cast("unsigned int*") int[] shape,@Cast("bool") boolean fortranOrder);
		Long() shapeBufferOfNpy(Integer rank, Integer() shape, Boolean fortranOrder)

	'    ND4J_EXPORT _CUDA_HD Nd4jLong *shapeBufferOfNpyBuffer(char *buffer);


	   ' this function checks the consistence of dimensions with array rank (negative dimensions, too large dimensions, too big number of dimensions)
		' also sort input array of dimensions, this operation is also necessary for creating TAD object
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkDimensions(int rank, @StdVector IntPointer dimensions);
		public native void checkDimensions(Integer rank, IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkDimensions(int rank, @StdVector IntBuffer dimensions);
		public native void checkDimensions(Integer rank, IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkDimensions(int rank, @StdVector int[] dimensions);
		public native void checkDimensions(Integer rank, Integer() dimensions)

		' function calculates linear index of array min, min is sub-array of max, index to be returned is min-array's index and corresponds to maxIdx of max array
		' dimsToExclude - should be sorted in increasing order
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, @Const IntPointer dimsToExclude, int dimsLen);
		Long subArrayIndex( Long maxIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo);
		Long subArrayIndex( Long maxIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, @Const IntBuffer dimsToExclude, int dimsLen);
		Long subArrayIndex( Long maxIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo);
		Long subArrayIndex( Long maxIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, @Const int[] dimsToExclude, int dimsLen);
		Long subArrayIndex( Long maxIdx, Long() maxShapeInfo, Long() minShapeInfo, Integer() dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayIndex(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo);
		Long subArrayIndex( Long maxIdx, Long() maxShapeInfo, Long() minShapeInfo)

		' function calculates absolute offset of min array, min is sub-array of max, offset to be returned corresponds to maxIdx of max array
		' dimsToExclude - should be sorted in increasing order
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, @Const IntPointer dimsToExclude, int dimsLen);
		Long subArrayOffset( Long maxIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo);
		Long subArrayOffset( Long maxIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, @Const IntBuffer dimsToExclude, int dimsLen);
		Long subArrayOffset( Long maxIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo);
		Long subArrayOffset( Long maxIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, @Const int[] dimsToExclude, int dimsLen);
		Long subArrayOffset( Long maxIdx, Long() maxShapeInfo, Long() minShapeInfo, Integer() dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong") long subArrayOffset(@Cast("const Nd4jLong") long maxIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo);
		Long subArrayOffset( Long maxIdx, Long() maxShapeInfo, Long() minShapeInfo)

		' max array is outer for min array, min array is sub-array of max array
		' function calculates the coordinates of min array (and saves them into minIdxs) given coordinates of max array (already stored in maxIdxs)
		' dimsToExclude - should be sorted in increasing order
		' dimsLen - length of dimsToExclude, if not set (= -1), then it is calculated as maxRank - minRank
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(IntPointer maxIdxs, IntPointer minIdxs, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, @Const IntPointer dimsToExclude, int dimsLen);
		public native void maxIndToMinInd(IntPointer maxIdxs, IntPointer minIdxs, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(IntPointer maxIdxs, IntPointer minIdxs, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo);
		public native void maxIndToMinInd(IntPointer maxIdxs, IntPointer minIdxs, LongPointer maxShapeInfo, LongPointer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(IntBuffer maxIdxs, IntBuffer minIdxs, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, @Const IntBuffer dimsToExclude, int dimsLen);
		public native void maxIndToMinInd(IntBuffer maxIdxs, IntBuffer minIdxs, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(IntBuffer maxIdxs, IntBuffer minIdxs, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo);
		public native void maxIndToMinInd(IntBuffer maxIdxs, IntBuffer minIdxs, LongBuffer maxShapeInfo, LongBuffer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(int[] maxIdxs, int[] minIdxs, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, @Const int[] dimsToExclude, int dimsLen);
		public native void maxIndToMinInd(Integer() maxIdxs, Integer() minIdxs, Long() maxShapeInfo, Long() minShapeInfo, Integer() dimsToExclude, Integer dimsLen)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void maxIndToMinInd(int[] maxIdxs, int[] minIdxs, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo);
		public native void maxIndToMinInd(Integer() maxIdxs, Integer() minIdxs, Long() maxShapeInfo, Long() minShapeInfo)

		' calculate indexes of max-array, these output indexes correspond to one minIdx index of min-array which is sub-array of max-array
		' dimsToExclude - should be sorted in increasing order
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(IntPointer maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, @Const IntPointer dimsToExclude);
		public native Integer outerArrayIndexes(IntPointer maxIdxs, Long minIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(IntPointer maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo);
		public native Integer outerArrayIndexes(IntPointer maxIdxs, Long minIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(IntBuffer maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, @Const IntBuffer dimsToExclude);
		public native Integer outerArrayIndexes(IntBuffer maxIdxs, Long minIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(IntBuffer maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo);
		public native Integer outerArrayIndexes(IntBuffer maxIdxs, Long minIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(int[] maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, @Const int[] dimsToExclude);
		public native Integer outerArrayIndexes(Integer() maxIdxs, Long minIdx, Long() maxShapeInfo, Long() minShapeInfo, Integer() dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayIndexes(int[] maxIdxs, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo);
		public native Integer outerArrayIndexes(Integer() maxIdxs, Long minIdx, Long() maxShapeInfo, Long() minShapeInfo)

		' calculate offsets of max-array, these offsets correspond to one minIdx index of min-array which is sub-array of max-array
		' maxOffsets - will contain calculated offsets of max-array, buffer for maxOffsets should be allocated beforehand
		' dimsToExclude - should be sorted in increasing order
		' memBuff - auxiliary memory buffer (size = 2 * max_rank) for coordinates and increments storing, should be allocated beforehand
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") LongPointer maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, IntPointer memBuff, @Const IntPointer dimsToExclude);
		public native Integer outerArrayOffsets( LongPointer maxOffsets, Long minIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer memBuff, IntPointer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") LongPointer maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("const Nd4jLong*") LongPointer minShapeInfo, IntPointer memBuff);
		public native Integer outerArrayOffsets( LongPointer maxOffsets, Long minIdx, LongPointer maxShapeInfo, LongPointer minShapeInfo, IntPointer memBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") LongBuffer maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, IntBuffer memBuff, @Const IntBuffer dimsToExclude);
		public native Integer outerArrayOffsets( LongBuffer maxOffsets, Long minIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer memBuff, IntBuffer dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") LongBuffer maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("const Nd4jLong*") LongBuffer minShapeInfo, IntBuffer memBuff);
		public native Integer outerArrayOffsets( LongBuffer maxOffsets, Long minIdx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, IntBuffer memBuff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") long[] maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, int[] memBuff, @Const int[] dimsToExclude);
		public native Integer outerArrayOffsets( Long() maxOffsets, Long minIdx, Long() maxShapeInfo, Long() minShapeInfo, Integer() memBuff, Integer() dimsToExclude)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int outerArrayOffsets(@Cast("Nd4jLong*") long[] maxOffsets, @Cast("const Nd4jLong") long minIdx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("const Nd4jLong*") long[] minShapeInfo, int[] memBuff);
		public native Integer outerArrayOffsets( Long() maxOffsets, Long minIdx, Long() maxShapeInfo, Long() minShapeInfo, Integer() memBuff)

		' calculates offsets for entities (elements or sub-arrays), shape in context of sub-array means dimensions excluded from outer array
		' rank is equal to size of shape
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides, @Cast("Nd4jLong*") LongPointer offsets, byte order);
		public native void calcOffsets(Integer rank, LongPointer shape, LongPointer strides, LongPointer offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides, @Cast("Nd4jLong*") LongPointer offsets);
		public native void calcOffsets(Integer rank, LongPointer shape, LongPointer strides, LongPointer offsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides, @Cast("Nd4jLong*") LongBuffer offsets, byte order);
		public native void calcOffsets(Integer rank, LongBuffer shape, LongBuffer strides, LongBuffer offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides, @Cast("Nd4jLong*") LongBuffer offsets);
		public native void calcOffsets(Integer rank, LongBuffer shape, LongBuffer strides, LongBuffer offsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides, @Cast("Nd4jLong*") long[] offsets, byte order);
		public native void calcOffsets(Integer rank, Long() shape, Long() strides, Long() offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(int rank, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides, @Cast("Nd4jLong*") long[] offsets);
		public native void calcOffsets(Integer rank, Long() shape, Long() strides, Long() offsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer offsets, byte order);
		public native void calcOffsets( LongPointer shapeInfo, LongPointer offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("Nd4jLong*") LongPointer offsets);
		public native void calcOffsets( LongPointer shapeInfo, LongPointer offsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer offsets, byte order);
		public native void calcOffsets( LongBuffer shapeInfo, LongBuffer offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("Nd4jLong*") LongBuffer offsets);
		public native void calcOffsets( LongBuffer shapeInfo, LongBuffer offsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] offsets, byte order);
		public native void calcOffsets( Long() shapeInfo, Long() offsets, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcOffsets(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("Nd4jLong*") long[] offsets);
		public native void calcOffsets( Long() shapeInfo, Long() offsets)
		' ND4J_EXPORT void calcOffsets(const Nd4jLong *xShapeInfo, Nd4jLong*& xOffsets, const Nd4jLong *yShapeInfo, Nd4jLong*& yOffsets, const char order = 'c');
		' ND4J_EXPORT void calcOffsets(const Nd4jLong *xShapeInfo, Nd4jLong*& xOffsets, const Nd4jLong *yShapeInfo, Nd4jLong*& yOffsets, const Nd4jLong* zShapeInfo, Nd4jLong*& zOffsets, const char order = 'c');
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void shapeOldScalar(@Cast("sd::DataType") int dtype, @Cast("Nd4jLong*const") LongPointer buffer, byte order);
		public native void shapeOldScalar( Integer dtype, LongPointer buffer, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void shapeOldScalar(@Cast("sd::DataType") int dtype, @Cast("Nd4jLong*const") LongBuffer buffer, byte order);
		public native void shapeOldScalar( Integer dtype, LongBuffer buffer, SByte order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void shapeOldScalar(@Cast("sd::DataType") int dtype, @Cast("Nd4jLong*const") long[] buffer, byte order);
		public native void shapeOldScalar( Integer dtype, Long() buffer, SByte order)

		' deduce order and element-wise stride
		' if array is scalar or unit length vector then ews = 1 and order is preserved
		' if array is common vector then ews = stride of non-unity dimension and order is preserved
		' if strides are normal/contiguous then ews = 1 and corresponding order is set, otherwise ews = 0 and order is preserved
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") LongPointer shapeInfo, byte proposedOrder, int numOfNonUnitDims, @Cast("const Nd4jLong*") LongPointer shapeNoUnities, @Cast("const Nd4jLong*") LongPointer stridesNoUnities);
		public native void checkStridesEwsAndOrder( LongPointer shapeInfo, SByte proposedOrder, Integer numOfNonUnitDims, LongPointer shapeNoUnities, LongPointer stridesNoUnities)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") LongBuffer shapeInfo, byte proposedOrder, int numOfNonUnitDims, @Cast("const Nd4jLong*") LongBuffer shapeNoUnities, @Cast("const Nd4jLong*") LongBuffer stridesNoUnities);
		public native void checkStridesEwsAndOrder( LongBuffer shapeInfo, SByte proposedOrder, Integer numOfNonUnitDims, LongBuffer shapeNoUnities, LongBuffer stridesNoUnities)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") long[] shapeInfo, byte proposedOrder, int numOfNonUnitDims, @Cast("const Nd4jLong*") long[] shapeNoUnities, @Cast("const Nd4jLong*") long[] stridesNoUnities);
		public native void checkStridesEwsAndOrder( Long() shapeInfo, SByte proposedOrder, Integer numOfNonUnitDims, Long() shapeNoUnities, Long() stridesNoUnities)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") LongPointer shapeInfo);
		public native void checkStridesEwsAndOrder( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") LongBuffer shapeInfo);
		public native void checkStridesEwsAndOrder( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void checkStridesEwsAndOrder(@Cast("Nd4jLong*") long[] shapeInfo);
		public native void checkStridesEwsAndOrder( Long() shapeInfo)

		''' <summary>
		''' processes whole set of sub-arrays
		''' evaluates shapeInfo of sub-arrays (all sub-arrays have the same shapeInfo) and their buffer offsets (each sub-array has its own unique offset from original this-buffer)
		''' arguments:
		''' wholeShapeInfo - original shapeInfo of whole array
		''' numOfSubArrs - number of sub-arrays, size of subArrOffsets is equal to numOfSubArrs
		''' dimsSize - size of dimsToExclude, if dimsSize = array rank or dimsSize = 0 it means sub-array is whole array, copy of wholeShapeInfo and one zero offset will be returned
		''' dimsToExclude - MUST BE SORTED, dimensions to evaluate sub-array along, i.e. when shape is [2,3,4,5] and dimsToExclude={0,2}, then there will be 8 sub-arrays with shape [3,5]
		''' subArrShapeInfo    - output argument, contains shapeInfo (same for all sub-arrays)
		''' subArrOffsets      - output argument, contains successive sub-arrays offsets from original this-buffer
		''' keepUnitiesInShape - if false then eliminate unities from sub-array shapeInfo, for example {1,a,1,b} -> {a,b}
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") LongPointer wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const IntPointer dimsToExclude, @Cast("Nd4jLong*") LongPointer subArrShapeInfo, @Cast("Nd4jLong*") LongPointer subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
		public native void calcSubArrsShapeInfoAndOffsets( LongPointer wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, IntPointer dimsToExclude, LongPointer subArrShapeInfo, LongPointer subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") LongPointer wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const IntPointer dimsToExclude, @Cast("Nd4jLong*") LongPointer subArrShapeInfo, @Cast("Nd4jLong*") LongPointer subArrOffsets);
		public native void calcSubArrsShapeInfoAndOffsets( LongPointer wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, IntPointer dimsToExclude, LongPointer subArrShapeInfo, LongPointer subArrOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") LongBuffer wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const IntBuffer dimsToExclude, @Cast("Nd4jLong*") LongBuffer subArrShapeInfo, @Cast("Nd4jLong*") LongBuffer subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
		public native void calcSubArrsShapeInfoAndOffsets( LongBuffer wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, IntBuffer dimsToExclude, LongBuffer subArrShapeInfo, LongBuffer subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") LongBuffer wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const IntBuffer dimsToExclude, @Cast("Nd4jLong*") LongBuffer subArrShapeInfo, @Cast("Nd4jLong*") LongBuffer subArrOffsets);
		public native void calcSubArrsShapeInfoAndOffsets( LongBuffer wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, IntBuffer dimsToExclude, LongBuffer subArrShapeInfo, LongBuffer subArrOffsets)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") long[] wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const int[] dimsToExclude, @Cast("Nd4jLong*") long[] subArrShapeInfo, @Cast("Nd4jLong*") long[] subArrOffsets, @Cast("bool") boolean keepUnitiesInShape);
		public native void calcSubArrsShapeInfoAndOffsets( Long() wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, Integer() dimsToExclude, Long() subArrShapeInfo, Long() subArrOffsets, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrsShapeInfoAndOffsets(@Cast("const Nd4jLong*") long[] wholeShapeInfo, @Cast("const Nd4jLong") long numOfSubArrs, int dimsSize, @Const int[] dimsToExclude, @Cast("Nd4jLong*") long[] subArrShapeInfo, @Cast("Nd4jLong*") long[] subArrOffsets);
		public native void calcSubArrsShapeInfoAndOffsets( Long() wholeShapeInfo, Long numOfSubArrs, Integer dimsSize, Integer() dimsToExclude, Long() subArrShapeInfo, Long() subArrOffsets)

		''' <summary>
		''' processes only one sub-array, evaluates shapeInfo of sub-array and its buffer offset from original array
		''' arguments:
		''' idx - input argument, intervals of indexes which define the sub-array to point on,
		'''        when isStrided = false then idx has form {dim0Start,dim0End,  dim1Start,dim1End, ....} and length (2 * maxRank)
		'''        when isStrided = true  then idx has form {dim0Start,dim0End,dim0Stride,  dim1Start,dim1End,dim1Stride, ....} and length (3 * maxRank)
		'''        when (dimStart == dimEnd) then whole range will be used for current dimension
		''' maxShapeInfo - input argument, shapeInfo of original array
		''' minShapeInfo - output argument, shapeInfo of sub-array to be deduced
		''' minOffset - output argument, offset of sub-array buffer offsets from original buffer
		''' keepUnitiesInShape - input argument, if false then eliminate unities from sub-array shapeInfo, for example {1,a,1,b} -> {a,b}
		''' isStrided - input argument, if true then idx has length (3 * this->rankOf()) and contains additional stride numbers which correspond to stride between dimStart and dimEnd,
		''' numOfUntiesInMinShape - input argument, number of occurrences in idx when (dimEnd - dimStart) = 1
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") LongPointer idx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("Nd4jLong*") LongPointer minShapeInfo, @Cast("Nd4jLong*") @ByRef LongPointer minOffset, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided, int numOfUntiesInMinShape);
		public native void calcSubArrShapeInfoAndOffset( LongPointer idx, LongPointer maxShapeInfo, LongPointer minShapeInfo, @ByRef LongPointer minOffset, Boolean keepUnitiesInShape, Boolean isStrided, Integer numOfUntiesInMinShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") LongPointer idx, @Cast("const Nd4jLong*") LongPointer maxShapeInfo, @Cast("Nd4jLong*") LongPointer minShapeInfo, @Cast("Nd4jLong*") @ByRef LongPointer minOffset);
		public native void calcSubArrShapeInfoAndOffset( LongPointer idx, LongPointer maxShapeInfo, LongPointer minShapeInfo, @ByRef LongPointer minOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") LongBuffer idx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("Nd4jLong*") LongBuffer minShapeInfo, @Cast("Nd4jLong*") @ByRef LongBuffer minOffset, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided, int numOfUntiesInMinShape);
		public native void calcSubArrShapeInfoAndOffset( LongBuffer idx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, @ByRef LongBuffer minOffset, Boolean keepUnitiesInShape, Boolean isStrided, Integer numOfUntiesInMinShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") LongBuffer idx, @Cast("const Nd4jLong*") LongBuffer maxShapeInfo, @Cast("Nd4jLong*") LongBuffer minShapeInfo, @Cast("Nd4jLong*") @ByRef LongBuffer minOffset);
		public native void calcSubArrShapeInfoAndOffset( LongBuffer idx, LongBuffer maxShapeInfo, LongBuffer minShapeInfo, @ByRef LongBuffer minOffset)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") long[] idx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("Nd4jLong*") long[] minShapeInfo, @Cast("Nd4jLong*") @ByRef long[] minOffset, @Cast("const bool") boolean keepUnitiesInShape, @Cast("const bool") boolean isStrided, int numOfUntiesInMinShape);
		public native void calcSubArrShapeInfoAndOffset( Long() idx, Long() maxShapeInfo, Long() minShapeInfo, @ByRef Long() minOffset, Boolean keepUnitiesInShape, Boolean isStrided, Integer numOfUntiesInMinShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void calcSubArrShapeInfoAndOffset(@Cast("const Nd4jLong*") long[] idx, @Cast("const Nd4jLong*") long[] maxShapeInfo, @Cast("Nd4jLong*") long[] minShapeInfo, @Cast("Nd4jLong*") @ByRef long[] minOffset);
		public native void calcSubArrShapeInfoAndOffset( Long() idx, Long() maxShapeInfo, Long() minShapeInfo, @ByRef Long() minOffset)

		''' <summary>
		''' for example inShapeInfo is {3, 2,1,4, 4,4,1, 16384,1,99}
		''' then output shapeNoUnities will contain {2,4, 4,1} - that is only shape and strides, no rank/type/ews/order
		''' stridesNoUnities will point on strides in shapeNoUnities that is on {4,1}
		''' returns number of non-unity dimensions in inShapeInfo
		''' if there is no unities in inShapeInfo, then no copy procedure will be performed and shapeNoUnities/stridesNoUnities will point on corresponding places in inShapeInfo
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") LongPointer inShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongPointer shapeNoUnities, @Cast("Nd4jLong*&") @ByPtrRef LongPointer stridesNoUnities);
		public native Integer excludeUnitiesFromShapeInfo( LongPointer inShapeInfo, @ByPtrRef LongPointer shapeNoUnities, @ByPtrRef LongPointer stridesNoUnities)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") LongBuffer inShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer shapeNoUnities, @Cast("Nd4jLong*&") @ByPtrRef LongBuffer stridesNoUnities);
		public native Integer excludeUnitiesFromShapeInfo( LongBuffer inShapeInfo, @ByPtrRef LongBuffer shapeNoUnities, @ByPtrRef LongBuffer stridesNoUnities)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") long[] inShapeInfo, @Cast("Nd4jLong*&") @ByPtrRef long[] shapeNoUnities, @Cast("Nd4jLong*&") @ByPtrRef long[] stridesNoUnities);
		public native Integer excludeUnitiesFromShapeInfo( Long() inShapeInfo, @ByPtrRef Long() shapeNoUnities, @ByPtrRef Long() stridesNoUnities)

		''' <summary>
		''' for example inShapeInfo is {3, 2,1,3,1,4,  12,12,4,4,1, 16384,1,99}, dimsToExclude(points on unity dimensions) = {1,3}, dimsSize = 2
		''' then outShapeInfo will contain {3, 2,3,4, 12,4,1, 16384,1,99}
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") LongPointer inShapeInfo, @Const IntPointer dimsToExclude, int dimsSize, @Cast("Nd4jLong*") LongPointer outShapeInfo);
		public native void excludeUnitiesFromShapeInfo( LongPointer inShapeInfo, IntPointer dimsToExclude, Integer dimsSize, LongPointer outShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") LongBuffer inShapeInfo, @Const IntBuffer dimsToExclude, int dimsSize, @Cast("Nd4jLong*") LongBuffer outShapeInfo);
		public native void excludeUnitiesFromShapeInfo( LongBuffer inShapeInfo, IntBuffer dimsToExclude, Integer dimsSize, LongBuffer outShapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native void excludeUnitiesFromShapeInfo(@Cast("const Nd4jLong*") long[] inShapeInfo, @Const int[] dimsToExclude, int dimsSize, @Cast("Nd4jLong*") long[] outShapeInfo);
		public native void excludeUnitiesFromShapeInfo( Long() inShapeInfo, Integer() dimsToExclude, Integer dimsSize, Long() outShapeInfo)

		''' <summary>
		''' get stride over contiguous axis (contiguous axis must have stride = 1)
		''' for example when inShapeInfo is {4, 2,5,4,3,  60,1,5,20, 16384,0,99} then output is 5 (that is smallest stride in inShapeInfo except those equal to 1)
		''' </summary>
		' INLINEDEF _CUDA_HD Nd4jLong strideOverContigAxis(const int axis, const Nd4jLong* inShapeInfo);






	'END HEADERS


		'BEGIN IMPLEMENTATIONS



	' #ifdef __CUDACC__
	' #endif

	''' <summary>
	''' Length of a tad given
	''' the shape information
	''' </summary>



	''' <summary>
	''' Tad element wise stride:
	''' given the inner most dimension (the sorted dimension of the last)
	''' the element wise stride of the tad (disregarding order) is the
	''' last dimension's stride.
	''' 
	''' For a given singular dimension this will just be the only entry.
	''' For example, given the following c order shape/stride:
	''' 2,2,3,2
	''' 12,6,2,1
	''' 
	''' The tad element wise stride for 3 will be 1.
	''' For zero it wil be 12
	''' 
	''' For 2,3 it's 1
	''' 
	''' Note here that the multi dimensional 2,3 case
	''' is equivalent to the singular 3 case.
	''' 
	''' 
	''' Note that this is for the dimension that ultimately
	''' ends up removed.
	''' 
	''' Again: this may not preserve ordering of the tad
	''' but maybe used for reductions.
	''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadElementWiseStride(@Cast("Nd4jLong*") LongPointer shapeInfo, IntPointer dimension,int dimensionLength);
		public native Integer tadElementWiseStride( LongPointer shapeInfo, IntPointer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadElementWiseStride(@Cast("Nd4jLong*") LongBuffer shapeInfo, IntBuffer dimension,int dimensionLength);
		public native Integer tadElementWiseStride( LongBuffer shapeInfo, IntBuffer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int tadElementWiseStride(@Cast("Nd4jLong*") long[] shapeInfo, int[] dimension,int dimensionLength);
		public native Integer tadElementWiseStride( Long() shapeInfo, Integer() dimension,Integer dimensionLength)

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>

	''' <summary>
	''' Computes the standard packed array strides for a given shape.
	''' </summary>
	''' <param name="shape">    the shape of a matrix: </param>
	''' <param name="startNum"> the start number for the strides </param>
	''' <returns> the strides for a matrix of n dimensions </returns>

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////


	' check whether input dimensions are permuted, not permuted dimensions order have to be 0,....,rank-1


	''' <param name="toCopy"> the shape to copy </param>
	''' <returns> a copy of the original struct </returns>

	''' <summary>
	''' Get the shape info buffer
	''' for the given rank and shape.
	''' </summary>

		''' <summary>
		''' This is special method, it returns ONLY 2D shapebuffer.
		''' 
		''' This method is used only for SoftMax
		''' </summary>

	''' <summary>
	''' Get the shape info buffer
	''' for the given rank and shape.
	''' </summary>

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////


	' //////////////////////////////////////////////////////////////////////
	'     INLINEDEF _CUDA_HD Nd4jLong getIndexOffset(Nd4jLong index, const Nd4jLong *shapeInfo, Nd4jLong arrLen) {

	'         const Nd4jLong ews = shapeInfo[shapeInfo[0] + shapeInfo[0] + 2];

	'         if(ews > 0 && order(shapeInfo) == 'c')
	'            if (ews == 1)
	'                return index;
	'            else
	'                return ews * index;

	'         Nd4jLong offset = 0;
	'         Nd4jLong rank = shapeInfo[0];
	'         for(int i = 1; i <= shapeInfo[0]; ++i) {
	'             arrLen /= shapeInfo[i];
	'             if(arrLen > 0 && shapeInfo[i] > 1) {
	'                 offset += (index / arrLen) * shapeInfo[i + rank];
	'                 index %= arrLen;
	'             }
	'         }
	'         return offset;
	'     }

	'     INLINEDEF _CUDA_HD uint getIndexOffset(uint index, const uint *shapeInfo, uint arrLen) {

	'         const uint rank = shapeInfo[0];
	'         const uint ews = shapeInfo[rank + rank + 2];

	'         if(ews > 0 && shapeInfo[rank + rank + 3] == 99)
	'            if (ews == 1)
	'                return index;
	'            else
	'                return ews * index;

	'         uint offset = 0;

	'         for(uint i = 1; i <= rank; ++i) {
	'             arrLen /= shapeInfo[i];
	'             if(arrLen > 0 && shapeInfo[i] > 1) {
	'                 offset += (index / arrLen) * shapeInfo[i + rank];
	'                 index %= arrLen;
	'             }
	'         }
	'         return offset;
	'     }

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////


	'////////////////////////////////////////////////////////////////////

	''' 
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="rearrange">
	''' @return </param>

	''' 
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="rearrange">
	''' @return </param>

	''' <summary>
	''' Get the ordering for the device </summary>
	''' <param name="length"> </param>
	''' <param name="shape"> </param>
	''' <param name="stride"> </param>
	''' <param name="elementStride">
	''' @return </param>





	''' <summary>
	''' Ensure that every value in the re arrange
	''' array is unique </summary>
	''' <param name="arr"> </param>
	''' <param name="shape"> </param>
	''' <param name="arrLength"> </param>
	''' <param name="shapeLength">
	''' @return </param>

	''' <summary>
	''' Permute the shape information </summary>
	''' <param name="info"> the shape information to permute </param>
	''' <param name="rearrange"> the order to re arrange </param>
	''' <param name="rank"> the rank of the rearrange array </param>

	''' <summary>
	''' Returns whether the
	''' given shape is a vector or not </summary>
	''' <param name="shape"> the shape of the array </param>
	''' <param name="rank"> the rank of the shape </param>

	'////////////////////////////////////////////////////////////////////

	''' <summary>
	''' Returns whether the
	''' given shape is a vector or not </summary>
	''' <param name="shape"> the shape of the array </param>
	''' <param name="rank"> the rank of the shape </param>

	''' <summary>
	''' Returns the shape portion of an information
	''' buffer
	''' </summary>

	''' <summary>
	''' Return a copy of a buffer.
	''' This buffer allocates memory
	''' that must be freed elsewhere.
	''' </summary>

	''' <summary>
	''' Return a copy of a buffer.
	''' This buffer allocates memory
	''' that must be freed elsewhere.
	''' </summary>

	''' <summary>
	''' Return a copy of a buffer.
	''' This buffer allocates memory
	''' that must be freed elsewhere.
	''' </summary>

	''' <summary>
	''' Permute the given strides
	''' in the given rearrange order </summary>
	''' <param name="toPermute"> the buffer to permute </param>
	''' <param name="shapeRank"> the length of the buffer to permute </param>
	''' <param name="rearrange"> the rearrange order (must be 0 based indexes
	''' and all must be filled in) </param>
	''' <returns> the rearranged array </returns>
	' 
	'    INLINEDEF _CUDA_HD Nd4jLong *permutedStrides(Nd4jLong *toPermute, int shapeRank, int *rearrange) {
	'        Nd4jLong *strideCopy = copyOf(shapeRank, toPermute);
	'        checkArrangeArray(rearrange, shapeRank, shapeRank);
	'        Nd4jLong *newStride = doPermuteSwap(shapeRank, strideCopy, rearrange);
	'        delete[] strideCopy;
	'        return newStride;
	'    }
	'    

	''' <summary>
	''' Return the slice (shape + 1 in pointer arithmetic) </summary>
	''' <param name="shape"> the shape to take the slice of </param>
	''' <returns> the shape array - the first entry </returns>

	''' <summary>
	''' Returns the length of the
	''' shape information buffer:
	''' rank * 2 + 3 </summary>
	''' <param name="rank"> the rank to get the shape
	''' info length for </param>
	''' <returns> rank * 2 + 4 </returns>

	''' <summary>
	''' Returns the rank portion of
	''' an information buffer
	''' </summary>

	''' <summary>
	''' Converts a raw int buffer of the layout:
	''' rank
	''' shape
	''' stride
	''' offset
	''' elementWiseStride
	''' 
	''' where shape and stride are both straight int pointers
	''' </summary>

	''' <summary>
	''' Returns the stride portion of an information
	''' buffer
	''' </summary>


	''' <summary>
	''' Compute the length of the given shape
	''' </summary>

	''' <summary>
	'''*
	''' Returns the offset
	''' portion of an information buffer
	''' </summary>


	''' <summary>
	''' Returns the ordering
	''' for this shape information buffer
	''' </summary>

	''' <summary>
	''' Returns type
	''' </summary>

	''' <summary>
	''' Returns the element wise stride for this information
	''' buffer
	''' </summary>

	''' <summary>
	''' Returns the element wise stride for this information
	''' buffer relative to a dimension and reduction index
	''' </summary>

	''' <summary>
	''' Returns whether
	''' the given shape info buffer
	''' represents a scalar shape
	''' </summary>

	''' <summary>
	''' Returns whether
	''' the given shape information
	''' represents a scalar
	''' shape or not
	''' </summary>

	''' <summary>
	''' Return a copy of this array with the
	''' given index omitted
	''' </summary>
	''' <param name="data">  the data to copy </param>
	''' <param name="indexes"> the index of the item to remove </param>
	''' <param name="dataLength"> the length of the data array </param>
	''' <param name="indexesLength"> the length of the data array </param>
	''' <returns> the new array with the omitted
	''' 
	''' item </returns>

		''' <summary>
		''' Return a copy of this array with the
		''' given index omitted
		''' </summary>
		''' <param name="data">  the data to copy </param>
		''' <param name="indexes"> the index of the item to remove </param>
		''' <param name="dataLength"> the length of the data array </param>
		''' <param name="indexesLength"> the length of the data array </param>
		''' <returns> the new array with the omitted
		''' 
		''' item </returns>

	''' <summary>
	''' Computes the offset for accessing
	''' a global element given the shape information
	''' and the offset to be read.
	''' </summary>
	' #ifdef __CUDACC__
	' #endif

	''' <summary>
	''' Returns a shape
	''' forces the given length to be 2. </summary>
	''' <param name="shape"> the shape to modify </param>
	''' <param name="dimension"> the dimension (row or column)
	''' for the shape to be returned as </param>
	''' <returns> the new shape </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongPointer ensureVectorShape(@Cast("Nd4jLong*") LongPointer shape, int dimension);
		LongPointer ensureVectorShape( LongPointer shape, Integer dimension)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") LongBuffer ensureVectorShape(@Cast("Nd4jLong*") LongBuffer shape, int dimension);
		LongBuffer ensureVectorShape( LongBuffer shape, Integer dimension)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native @Cast("Nd4jLong*") long[] ensureVectorShape(@Cast("Nd4jLong*") long[] shape, int dimension);
		Long() ensureVectorShape( Long() shape, Integer dimension)

	''' <summary>
	''' Returns a shape
	''' forces the given length to be 2. </summary>
	''' <param name="shape"> the shape to modify </param>
	''' <param name="dimension"> the dimension (row or column)
	''' for the shape to be returned as </param>
	''' <returns> the new shape </returns>

		''' <summary>
		''' This method does STRICT comparison for two shape buffers
		''' </summary>
		''' <param name="shape">
		''' @return </param>

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

		''' <summary>
		''' This method does SOFT comparison for two shape buffers, we compare only rank & shapes
		''' </summary>
		''' <param name="shape">
		''' @return </param>

	''' <summary>
	''' Generate an int buffer
	''' up to the given length
	''' at the specified increment
	''' 
	''' </summary>

	''' <summary>
	''' Generate a range
	''' beginning at from and ending at to
	''' incrementing by 1 </summary>
	''' <param name="from"> the start </param>
	''' <param name="to"> the end </param>
	''' <returns> the int array starting at from and ending at to </returns>

	''' <summary>
	''' Keep the given indexes in the data </summary>
	''' <param name="data"> </param>
	''' <param name="index"> </param>
	''' <param name="indexLength"> </param>
	''' <param name="dataLength">
	''' @return </param>

	''' <summary>
	''' Generate a reverse
	''' copy of the data
	''' </summary>

	''' 
	''' <param name="arr1"> </param>
	''' <param name="arr1Length"> </param>
	''' <param name="arr2"> </param>
	''' <param name="arr2Length">
	''' @return </param>

	''' 
	''' <param name="numArrays"> </param>
	''' <param name="numTotalElements"> </param>
	''' <param name="arr"> </param>
	''' <param name="lengths">
	''' @return </param>

	''' <summary>
	''' Get the length per slice of the
	''' given shape and the dimension </summary>
	''' <param name="rank"> the rank of the shape </param>
	''' <param name="shape"> the shape of to get
	''' the length per slice for </param>
	''' <param name="dimension"> the dimension to
	''' get the length per slice for </param>
	''' <param name="dimensionLength"> the length of the dimension array </param>
	''' <returns> the length per slice of the given shape
	''' along the given dimension </returns>

	''' <summary>
	''' calculates the offset for a tensor </summary>
	''' <param name="index"> </param>
	''' <param name="arr"> </param>
	''' <param name="tensorShape">
	''' @return </param>

		''' <summary>
		''' calculates the offset for a tensor </summary>
		''' <param name="index"> </param>
		''' <param name="arr"> </param>
		''' <param name="tensorShape">
		''' @return </param>


	' #ifdef __CUDACC__
	' #endif





	''' <summary>
	''' Computes the number
	''' of tensors along
	''' a given dimension
	''' </summary>

	''' <summary>
	''' Computes the number
	''' of tensors along
	''' a given dimension
	''' </summary>




	''' <summary>
	''' Get an offset for retrieval
	''' from a data buffer
	''' based on the given
	''' shape stride and given indices </summary>
	''' <param name="baseOffset"> the offset to start from </param>
	''' <param name="shape"> the shape of the array </param>
	''' <param name="stride"> the stride of the array </param>
	''' <param name="indices"> the indices to iterate over </param>
	''' <returns> the double at the specified index </returns>

	'////////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	''' <summary>
	''' Returns the tensor along dimension
	''' for the given block index </summary>
	''' <param name="blockSize"> </param>
	''' <param name="blockIdx"> </param>
	''' <param name="i">
	''' @return </param>

	''' <summary>
	''' Computes the number of tads per block
	''' 
	''' </summary>

	''' <summary>
	''' Returns a shape buffer
	''' for the shape information metadata.
	''' </summary>
	''' <summary>
	''' Given an linear index, element wise stride
	''' and the length of each tad
	''' map a linear index to a tad </summary>
	''' <param name="i"> the index to map </param>
	''' <param name="the"> element wise stride for the tads </param>
	''' <param name="numElementsPerTad"> the number of elements
	''' per tad </param>

	''' <summary>
	''' Map a tad to a
	''' reduction index. </summary>
	''' <param name="tadIndexForOriginal"> the original tad index for the
	''' split up problem (eg: split is dimension 3 mapping to a 2,3 problem) </param>
	''' <param name="tadsForReduced"> the number of tads for the shrunk down problem (eg: 2,3) </param>
	''' <param name="tadsForOriginal"> the number of tads for the smaller problem (eg: 3) </param>

	''' <summary>
	''' Tad index for linear </summary>
	''' <param name="linearIndex"> </param>
	''' <param name="tadLength">
	''' @return </param>

	''' <summary>
	''' Computes the number of tads
	''' per reduce index for the
	''' reduction tad.
	''' </summary>

	''' <summary>
	''' Maps a linear index to a reduction index </summary>
	''' <param name="i"> the linear index to map </param>
	''' <param name="elementWiseStride"> the element wise stride
	''' for the multiple problem </param>
	''' <param name="tadNum"> the number of tads for the shrunken problem </param>
	''' <param name="originalTadNum"> the tad number for the reduced version of the problem </param>


	''' <summary>
	''' Returns the prod of the data
	''' up to the given length
	''' </summary>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rearMostLeftOverItem(@Cast("Nd4jLong*") LongPointer data, @Cast("Nd4jLong*") LongPointer dimension,int dimensionLength);
		public native Integer rearMostLeftOverItem( LongPointer data, LongPointer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rearMostLeftOverItem(@Cast("Nd4jLong*") LongBuffer data, @Cast("Nd4jLong*") LongBuffer dimension,int dimensionLength);
		public native Integer rearMostLeftOverItem( LongBuffer data, LongBuffer dimension,Integer dimensionLength)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("shape") public native int rearMostLeftOverItem(@Cast("Nd4jLong*") long[] data, @Cast("Nd4jLong*") long[] dimension,int dimensionLength);
		public native Integer rearMostLeftOverItem( Long() data, Long() dimension,Integer dimensionLength)

	' #ifdef __CUDACC__
	' #endif






	'    INLINEDEF _CUDA_HD Nd4jLong *shapeBufferOfNpyBuffer(char *buffer) {
	'        unsigned Nd4jLong *shape;
	'        unsigned int ndims, wordSize;
	'        bool fortranOrder;
	'        cnpy::parseNpyHeaderStr(std::string(buffer),wordSize,shape,ndims,fortranOrder);
	'        Nd4jLong * ret =  shape::shapeBufferOfNpy(ndims,shape,fortranOrder);
	'        delete[] shape;
	'        return ret;
	'    }

	'////////////////////////////////////////////////////////////////////////
	' copy-past from java hasDefaultStridesForShape function

	' INLINEDEF _CUDA_H bool reshapeC(const int oldRank, Nd4jLong* oldShape, const int newRank, Nd4jLong* newShapeOf, bool isFOrder, Nd4jLong* target) {
	'         int oldnd;
	'         Nd4jLong* olddims = shape::copyOf(oldRank, shape::shapeOf(oldShape));
	'         Nd4jLong* oldstrides = shape::copyOf(oldRank, shape::stride(oldShape));
	'         int np, op, last_stride;
	'         int oi, oj, ok, ni, nj, nk;
	'         Nd4jLong* newStrides = new Nd4jLong[newRank];
	'         oldnd = 0;

	'         /*
	'          * Remove axes with dimension 1 from the old array. They have no effect
	'          * but would need special cases since their strides do not matter.
	'          */
	'         for (oi = 0; oi < oldRank; oi++) {
	'             if (shape::shapeOf(oldShape)[oi] != 1) {
	'                 olddims[oldnd] = shape::shapeOf(oldShape)[oi];
	'                 oldstrides[oldnd] = shape::stride(oldShape)[oi];
	'                 oldnd++;
	'             }
	'         }

	'         np = 1;
	'         for (ni = 0; ni < newRank; ni++) {
	'             np *= newShapeOf[ni];
	'         }
	'         op = 1;
	'         for (oi = 0; oi < oldnd; oi++) {
	'             op *= olddims[oi];
	'         }
	'         if (np != op) {
	'             /* different total sizes; no hope */
	'             delete[] olddims;
	'             delete[] oldstrides;
	'             delete[] newStrides;

	'             return false;
	'         }

	'         if (np == 0) {
	'             /* the current code does not handle 0-sized arrays, so give up */
	'             delete[] olddims;
	'             delete[] oldstrides;
	'             delete[] newStrides;

	'             return false;
	'         }

	'         /* oi to oj and ni to nj give the axis ranges currently worked with */
	'         oi = 0;
	'         oj = 1;
	'         ni = 0;
	'         nj = 1;

	'         while (ni < newRank && oi < oldnd) {
	'             np = newShapeOf[ni];
	'             op = olddims[oi];

	'             while (np != op) {
	'                 if (np < op) {
	'                     /* Misses trailing 1s, these are handled later */
	'                     np *= newShapeOf[nj++];
	'                 } else {
	'                     op *= olddims[oj++];
	'                 }
	'             }

	'             /* Check whether the original axes can be combined */
	'             for (ok = oi; ok < oj - 1; ok++) {
	'                 if (isFOrder) {
	'                     if (oldstrides[ok + 1] != olddims[ok] * oldstrides[ok]) {
	'                         /* not contiguous enough */
	'                         delete[] olddims;
	'                         delete[] oldstrides;
	'                         delete[] newStrides;

	'                         return false;
	'                     }
	'                 } else {
	'                     /* C order */
	'                     if (oldstrides[ok] != olddims[ok + 1] * oldstrides[ok + 1]) {
	'                         /* not contiguous enough */
	'                         delete[] olddims;
	'                         delete[] oldstrides;
	'                         delete[] newStrides;

	'                         return false;
	'                     }
	'                 }
	'             }

	'             /* Calculate new strides for all axes currently worked with */
	'             if (isFOrder) {
	'                 newStrides[ni] = oldstrides[oi];
	'                 for (nk = ni + 1; nk < nj; nk++) {
	'                     newStrides[nk] = newStrides[nk - 1] * newShapeOf[nk - 1];
	'                 }
	'             } else {
	'                 /* C order */
	'                 newStrides[nj - 1] = oldstrides[oj - 1];
	'                 for (nk = nj - 1; nk > ni; nk--) {
	'                     newStrides[nk - 1] = newStrides[nk] * newShapeOf[nk];
	'                 }
	'             }
	'             ni = nj++;
	'             oi = oj++;
	'         }

	'         if (ni >= 1) {
	'             last_stride = newStrides[ni - 1];
	'         } else {
	'             last_stride = shape::elementWiseStride(oldShape);
	'         }
	'         if (isFOrder && ni >= 1) {
	'             last_stride *= newShapeOf[ni - 1];
	'         }
	'         for (nk = ni; nk < newRank; nk++) {
	'             newStrides[nk] = last_stride;
	'         }

	'         target[0] = newRank;
	'         int cnt = 1;
	'         for (int e = 0; e < newRank; e++)
	'             target[cnt++] = newShapeOf[e];

	'         for (int e = 0; e < newRank; e++)
	'             target[cnt++] = newStrides[e];

	'         target[shape::shapeInfoLength(newRank) - 3] = 0;
	'         target[shape::shapeInfoLength(newRank) - 2] = 0;
	'         target[shape::shapeInfoLength(newRank) - 1] = isFOrder ? 102 : 99;
	'         sd::ArrayOptions::setDataType(target, sd::ArrayOptions::dataType(oldShape));

	'         delete[] olddims;
	'         delete[] oldstrides;
	'         delete[] newStrides;

	'         return true;
	'     }

	'////////////////////////////////////////////////////////////////////
	' INLINEDEF _CUDA_H bool reshapeC(const int oldRank, const Nd4jLong* oldShapeInfo, const int newRank, const Nd4jLong* newShape, Nd4jLong* newShapeInfo) {

	'         // PLEASE NOTE !: reshaping not-permuted (ews=1) array in f order (except insertion/elimination of unities) will definitely cause allocation of new buffer for array elements
	'         // also this function takes into account identical shapes automatically, namely in that case oldShapeInfo is completely copied to newShapeInfo

	'         newShapeInfo[0] = newRank;
	'         memcpy(newShapeInfo + 1, newShape, newRank * sizeof(Nd4jLong));

	'         Nd4jLong* newStrides       = shape::stride(newShapeInfo);
	'         const Nd4jLong* oldShape   = shape::shapeOf(const_cast<Nd4jLong*>(oldShapeInfo));
	'         const Nd4jLong* oldStrides = shape::stride(const_cast<Nd4jLong*>(oldShapeInfo));
	'         Nd4jLong oldStart(0), oldStop(1), newStart(0), newStop(1), newDim, oldDim;

	'         while (newStart < newRank && oldStart < oldRank) {

	'             newDim = newShape[newStart];
	'             oldDim = oldShape[oldStart];

	'             while (newDim != oldDim && newDim > 0 && oldDim > 0)
	'                 if (newDim < oldDim) newDim *= newShape[newStop++];
	'                 else                 oldDim *= oldShape[oldStop++];

	'             // ------ Check whether the original axes can be combined ------ //
	'             for (int step = 1, i = oldStart; i < oldStop - 1; ++i) {
	'                 if(oldShape[i] == 1)                // skip unity-dimension and its stride
	'                     continue;
	'                 while((i + step) < oldRank && oldShape[i + step] == 1)
	'                     ++step;                         // skip following unity-dimensions and its strides if such are present
	'                 if((i + step) < oldRank && oldStrides[i] != oldShape[i + step] * oldStrides[i + step])
	'                     return false;                   // not contiguous enough
	'             }

	'             newStrides[newStop - 1] = oldStrides[oldStop - 1];
	'             for (int i = newStop - 1; i > newStart; --i)
	'                 newStrides[i - 1] = newStrides[i] * newShape[i];

	'             newStart = newStop++;
	'             oldStart = oldStop++;
	'         }

	'         // rest of strides should be unities (if there is remainder in strides space, that is newStart < newRank)
	'         for (int i = newStart; i < newRank; ++i)
	'             newStrides[i] = 1;

	'         newShapeInfo[2 * newRank + 3] = shape::order(oldShapeInfo);                 // order
	'         newShapeInfo[2 * newRank + 2] = shape::elementWiseStride(oldShapeInfo);     // ews
	'         newShapeInfo[2 * newRank + 1] = shape::type(oldShapeInfo);                  // type

	'         return true;
	'     }

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

		' this function checks the consistence of dimensions with array rank (negative dimensions, too large dimensions, too big number of dimensions)
		' also it sorts input array of dimensions, this operation is also necessary for creating TAD object


	' max array is outer for min array, min array is sub-array of max array
	' function calculates the coordinates of min array (and saves them into minIdxs) given coordinates of max array (already stored in maxIdxs)

		'////////////////////////////////////////////////////////////////////

		'////////////////////////////////////////////////////////////////////

		'////////////////////////////////////////////////////////////////////

		'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////

	'////////////////////////////////////////////////////////////////////
	' INLINEDEF _CUDA_HD void index2coordsCPU(const Nd4jLong& startIndex, const Nd4jLong& index, const Nd4jLong *shapeInfo, const int* dims, const int dimsLen, int *coords) {

	'     if(startIndex == index) {
	'         shape::index2coords(index, shapeInfo, dims, dimsLen, coords);
	'     }
	'     else {
	'         int i = dimsLen - 1;
	'         while(coords[dims[i]] == shape::sizeAt(shapeInfo, dims[i]) - 1)
	'             coords[dims[i--]] = 0;
	'         ++coords[dims[i]];
	'     }
	' }

	'////////////////////////////////////////////////////////////////////
	' INLINEDEF _CUDA_HD void calcOffsets(const Nd4jLong *xShapeInfo, Nd4jLong*& xOffsets, const Nd4jLong *yShapeInfo, Nd4jLong*& yOffsets, const Nd4jLong* zShapeInfo, Nd4jLong*& zOffsets, const char order) {

	'     // we assume all array have same length
	'     const Nd4jLong len = shape::length(xShapeInfo);

	'     const Nd4jLong xEws = shape::elementWiseStride(xShapeInfo);
	'     const Nd4jLong yEws = shape::elementWiseStride(yShapeInfo);
	'     const Nd4jLong zEws = shape::elementWiseStride(zShapeInfo);

	'     const char xOrder = shape::order(xShapeInfo);
	'     const char yOrder = shape::order(yShapeInfo);
	'     const char zOrder = shape::order(zShapeInfo);

	'     const bool shapesSame = shape::shapeEquals(xShapeInfo, yShapeInfo, zShapeInfo);

	'     if (xEws == 1 && yEws == 1 && zEws == 1 && xOrder == yOrder && xOrder == zOrder && (xOrder == 'c' || shapesSame)) {
	'         xOffsets = yOffsets = zOffsets = nullptr;
	'     }
	'     else if(xEws == 1 && yEws == 1 && xOrder == yOrder && (xOrder == 'c' || shape::shapeEquals(xShapeInfo, yShapeInfo))) {
	'         xOffsets = yOffsets = nullptr;
	'         zOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(zShapeInfo, zOffsets, xOrder);
	'     }
	'     else if(xEws == 1 && zEws == 1 && xOrder == zOrder && (xOrder == 'c' || shape::shapeEquals(xShapeInfo, zShapeInfo))) {
	'         xOffsets = zOffsets = nullptr;
	'         yOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(yShapeInfo, yOffsets, xOrder);
	'     }
	'     else if(yEws == 1 && zEws == 1 && yOrder == zOrder && (yOrder == 'c' || shape::shapeEquals(yShapeInfo, zShapeInfo))) {
	'         yOffsets = zOffsets = nullptr;
	'         xOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(xShapeInfo, xOffsets, yOrder);
	'     }
	'     else if(xEws == 1) {
	'         xOffsets = nullptr;
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 yOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(yShapeInfo, yOffsets, xOrder);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 zOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(zShapeInfo, zOffsets, xOrder);
	'             }
	'         }
	'     }
	'     else if(yEws == 1) {
	'         yOffsets = nullptr;
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets, yOrder);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 zOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(zShapeInfo, zOffsets, yOrder);
	'             }
	'         }
	'     }
	'     else if(zEws == 1) {
	'         zOffsets = nullptr;
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets, zOrder);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 yOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(yShapeInfo, yOffsets, zOrder);
	'             }
	'         }
	'     }
	'     else if(shape::haveSameShapeAndStrides(xShapeInfo, yShapeInfo, zShapeInfo)) {
	'         xOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(xShapeInfo, xOffsets);
	'         yOffsets = zOffsets = xOffsets;
	'     }
	'     else if(shape::haveSameShapeAndStrides(xShapeInfo, yShapeInfo)) {
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 zOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(zShapeInfo, zOffsets);
	'             }
	'         }
	'         yOffsets = xOffsets;
	'     }
	'     else if(shape::haveSameShapeAndStrides(xShapeInfo, zShapeInfo)) {
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 yOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(yShapeInfo, yOffsets);
	'             }
	'         }
	'         zOffsets = xOffsets;
	'     }
	'     else {
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 yOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(yShapeInfo, yOffsets);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 zOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(zShapeInfo, zOffsets);
	'             }
	'         }
	'     }
	' }

	'////////////////////////////////////////////////////////////////////
	' INLINEDEF _CUDA_HD void calcOffsets(const Nd4jLong *xShapeInfo, Nd4jLong*& xOffsets, const Nd4jLong *yShapeInfo, Nd4jLong*& yOffsets, const char order) {

	'     // we assume all array have same length
	'     const Nd4jLong len = shape::length(xShapeInfo);

	'     const Nd4jLong xEws = shape::elementWiseStride(xShapeInfo);
	'     const Nd4jLong yEws = shape::elementWiseStride(yShapeInfo);

	'     const char xOrder = shape::order(xShapeInfo);
	'     const char yOrder = shape::order(yShapeInfo);

	'     const bool shapesSame = shape::shapeEquals(xShapeInfo, yShapeInfo);

	'     if (xEws == 1 && yEws == 1 && xOrder == yOrder && (xOrder == 'c' || shapesSame)) {
	'         xOffsets = yOffsets = nullptr;
	'     }
	'     else if(xEws == 1) {
	'         xOffsets = nullptr;
	'         yOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(yShapeInfo, yOffsets, xOrder);
	'     }
	'     else if(yEws == 1) {
	'         yOffsets = nullptr;
	'         xOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(xShapeInfo, xOffsets, yOrder);
	'     }
	'     else if(shape::haveSameShapeAndStrides(xShapeInfo, yShapeInfo)) {
	'         xOffsets = new Nd4jLong[len];
	'         shape::calcOffsets(xShapeInfo, xOffsets);
	'         yOffsets = xOffsets;
	'     }
	'     else {
	'         PRAGMA_OMP_PARALLEL_SECTIONS
	'         {
	'             PRAGMA_OMP_SECTION
	'             {
	'                 xOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(xShapeInfo, xOffsets);
	'             }
	'             PRAGMA_OMP_SECTION
	'             {
	'                 yOffsets = new Nd4jLong[len];
	'                 shape::calcOffsets(yShapeInfo, yOffsets);
	'             }
	'         }
	'     }
	' }


	'////////////////////////////////////////////////////////////////////
	' INLINEDEF _CUDA_HD Nd4jLong strideOverContigAxis(const int axis, const Nd4jLong* inShapeInfo) {

	'     Nd4jLong result = 9223372036854775807LL;

	'     for(uint i = 0; i < shape::rank(inShapeInfo); ++i) {

	'         const auto currentStride = shape::stride(inShapeInfo)[i];

	'         if(i == axis || shape::shapeOf(inShapeInfo)[i] == 1)
	'             continue;

	'         if(result > currentStride)
	'             result = currentStride;
	'     }

	'     return result == 9223372036854775807LL ? 1 : result;
	' }





	' #endif /* SHAPE_H_ */


	' Parsed from helpers/OpArgsHolder.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author Yurii Shyrma (iuriish@yahoo.com), created on 15.07.2018
	'

	' #ifndef LIBND4J_OPARGSHOLDER_H
	' #define LIBND4J_OPARGSHOLDER_H


	' #include <array/NDArray.h>
	' #include <system/dll.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class OpArgsHolder extends Pointer
	public static class OpArgsHolder extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public OpArgsHolder(Pointer p)
		If True Then
			MyBase(p)
		End If
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public OpArgsHolder(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public OpArgsHolder position(Long position)
		If True Then
			Return CType(MyBase.position(position), OpArgsHolder)
		End If
		public OpArgsHolder getPointer(Long i)
		If True Then
			Return (New OpArgsHolder(CType(Me, Pointer))).position(position + i)
		End If


		' default constructor
		public OpArgsHolder()
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate()
		End If
		private native void allocate()

		' copy constructor
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef OpArgsHolder other)
		public OpArgsHolder( OpArgsHolder other)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(other)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef OpArgsHolder other);
		private native void allocate( OpArgsHolder other)

		' constructor
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs)
		public OpArgsHolder( NDArrayVector inArrs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
		private native void allocate( NDArrayVector inArrs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs)
		public OpArgsHolder( NDArrayVector inArrs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs);
		private native void allocate( NDArrayVector inArrs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs)
		public OpArgsHolder( NDArrayVector inArrs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
		private native void allocate( NDArrayVector inArrs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs)
		public OpArgsHolder( NDArrayVector inArrs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
		private native void allocate( NDArrayVector inArrs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs)
		public OpArgsHolder( NDArrayVector inArrs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
		private native void allocate( NDArrayVector inArrs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs)
		public OpArgsHolder( NDArrayVector inArrs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
		private native void allocate( NDArrayVector inArrs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpArgsHolder(@Const @ByRef NDArrayVector inArrs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs)
		public OpArgsHolder( NDArrayVector inArrs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocate(inArrs, tArgs, iArgs, bArgs)
		End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef NDArrayVector inArrs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
		private native void allocate( NDArrayVector inArrs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs)

		' move constructor

		' assignment operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") OpArgsHolder put(@Const @ByRef OpArgsHolder other);
		public native @Name("operator =") OpArgsHolder put( OpArgsHolder other)

		' move assignment operator

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Const @ByRef NDArrayVector getInArrs();
		public native @ByRef NDArrayVector getInArrs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector DoublePointer getTArgs();
		public native DoublePointer getTArgs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer getIArgs();
		public native @StdVector LongPointer getIArgs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool*") @StdVector BooleanPointer getBArgs();
		public native @StdVector BooleanPointer getBArgs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool*") @StdVector BooleanPointer getAllocInfo();
		public native @StdVector BooleanPointer getAllocInfo()

		public native Integer getNumInArrs()

		public native Integer getNumTArgs()

		public native Integer getNumIArgs()

		public native Integer getNumBArgs()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal OpArgsHolder createArgsHolderForBP(@Const @ByRef NDArrayVector inGradArrs, @Cast("const bool") boolean isInPlace);
		public native OpArgsHolder createArgsHolderForBP( NDArrayVector inGradArrs, Boolean isInPlace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal OpArgsHolder createArgsHolderForBP(@Const @ByRef NDArrayVector inGradArrs);
		public native OpArgsHolder createArgsHolderForBP( NDArrayVector inGradArrs)

	End If







	' #endif //LIBND4J_OPARGSHOLDER_H


	' Parsed from array/ShapeList.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_SHAPELIST_H
	' #define LIBND4J_SHAPELIST_H

	' #include <vector>
	' #include <helpers/shape.h>
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ShapeList extends Pointer
		public static class ShapeList extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ShapeList(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ShapeList(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ShapeList position(Long position)
			If True Then
				Return CType(MyBase.position(position), ShapeList)
			End If
			public ShapeList getPointer(Long i)
			If True Then
				Return (New ShapeList(CType(Me, Pointer))).position(position + i)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong*") LongPointer shape)
			public ShapeList( LongPointer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shape);
			private native void allocate( LongPointer shape)
			public ShapeList()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong*") LongBuffer shape)
			public ShapeList( LongBuffer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shape);
			private native void allocate( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong*") long[] shape)
			public ShapeList( Long() shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shape);
			private native void allocate( Long() shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong**") @StdVector PointerPointer shapes, @Cast("bool") boolean isWorkspace)
			public ShapeList( PointerPointer shapes, Boolean isWorkspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes, isWorkspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong**") @StdVector PointerPointer shapes, @Cast("bool") boolean isWorkspace);
			private native void allocate( PointerPointer shapes, Boolean isWorkspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr LongPointer shapes, @Cast("bool") boolean isWorkspace)
			public ShapeList( @ByPtrPtr LongPointer shapes, Boolean isWorkspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes, isWorkspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr LongPointer shapes, @Cast("bool") boolean isWorkspace);
			private native void allocate( @ByPtrPtr LongPointer shapes, Boolean isWorkspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr LongBuffer shapes, @Cast("bool") boolean isWorkspace)
			public ShapeList( @ByPtrPtr LongBuffer shapes, Boolean isWorkspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes, isWorkspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr LongBuffer shapes, @Cast("bool") boolean isWorkspace);
			private native void allocate( @ByPtrPtr LongBuffer shapes, Boolean isWorkspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr long[] shapes, @Cast("bool") boolean isWorkspace)
			public ShapeList( @ByPtrPtr Long() shapes, Boolean isWorkspace)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes, isWorkspace)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong**") @StdVector @ByPtrPtr long[] shapes, @Cast("bool") boolean isWorkspace);
			private native void allocate( @ByPtrPtr Long() shapes, Boolean isWorkspace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeList(@Cast("const Nd4jLong**") @StdVector PointerPointer shapes)
			public ShapeList( PointerPointer shapes)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapes)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong**") @StdVector PointerPointer shapes);
			private native void allocate( PointerPointer shapes)
			'ShapeList(bool autoRemovable);

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong**") @StdVector PointerPointer asVector();
			public native @StdVector PointerPointer asVector()
			public native void destroy()
			public native Integer size()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("const Nd4jLong*") LongPointer at(int idx);
			public native LongPointer at(Integer idx)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void push_back(@Cast("const Nd4jLong*") LongPointer shape);
			public native void push_back( LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void push_back(@Cast("const Nd4jLong*") LongBuffer shape);
			public native void push_back( LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void push_back(@Cast("const Nd4jLong*") long[] shape);
			public native void push_back( Long() shape)

			''' <summary>
			''' PLEASE NOTE: This method should be called ONLY if shapes were generated at workspaces. Otherwise you'll get memory leak
			''' </summary>
			public native void detach()
		End If



	' #endif //LIBND4J_SHAPELIST_H


	' Parsed from system/type_boilerplate.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver on 6/12/2018.
	'

	' #ifndef LIBND4J_TYPE_BOILERPLATE_H
	' #define LIBND4J_TYPE_BOILERPLATE_H

	' #define EXPAND(...) __VA_ARGS__
	' #define EXPAND2(...) __VA_ARGS__
	' #define EXPAND3(...) __VA_ARGS__
	' #define EXTRACT(...) EXTRACT __VA_ARGS__
	' #define NOTHING_EXTRACT
	' #define PASTE(x, ...) x ## __VA_ARGS__
	' #define PASTE2(x, ...) x ## __VA_ARGS__
	' #define PASTE3(x, ...) x ## __VA_ARGS__
	' #define EVALUATING_PASTE(x, ...) PASTE(x, __VA_ARGS__)
	' #define EVALUATING_PASTE2(x, ...) PASTE2(x, __VA_ARGS__)
	' #define EVALUATING_PASTE3(x, ...) PASTE3(x, __VA_ARGS__)
	' #define UNPAREN(x) EVALUATING_PASTE(NOTHING_, EXTRACT x)
	' #define UNPAREN2(x) EVALUATING_PASTE2(NOTHING_, EXTRACT x)
	' #define UNPAREN3(x) EVALUATING_PASTE3(NOTHING_, EXTRACT x)
	' #define EVAL( x ) x
	' #define EVALX( x ) x
	' #define EVAL0(...)  EVAL1(EVAL1(EVAL1(__VA_ARGS__)))
	' #define EVAL1(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))
	' #define EVAL2(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))
	' #define EVAL3(...) EVAL4(EVAL4(EVAL4(__VA_ARGS__)))
	' #define EVAL4(...) EVAL5(EVAL5(EVAL5(__VA_ARGS__)))
	' #define EVAL5(...) __VA_ARGS__


	' #define SEL_T_1(WHAT, NAME, SIGNATURE, TYPE_A) WHAT(NAME, SIGNATURE, TYPE_A)
	' #define SEL_T_2(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_1(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_3(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_2(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_4(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_3(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_5(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_4(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_6(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_5(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_7(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_6(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_8(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_7(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_9(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_8(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_10(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_9(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_11(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_10(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_12(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_11(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_13(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_12(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_14(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_13(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_15(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_14(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_16(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_15(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_17(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_16(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_18(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_17(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_19(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_18(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define SEL_T_20(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(SEL_T_19(WHAT, NAME, SIGNATURE, __VA_ARGS__))


	' #define SEL_TT1_1(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define SEL_TT1_2(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_1(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_3(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_2(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_4(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_3(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_5(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_4(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_6(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_5(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_7(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_6(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_8(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_7(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_9(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_8(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_10(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_9(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_11(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_10(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_12(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_11(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_13(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_12(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_14(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_13(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_15(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_14(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_16(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_15(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_17(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_16(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_18(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_17(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_19(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_18(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT1_20(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(YTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT1_19(WHAT, YTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))


	' #define SEL_P1_1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define SEL_P1_2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_3(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_4(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_3(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_5(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_4(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_6(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_5(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_7(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_6(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_8(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_7(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_9(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_8(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_10(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_9(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_11(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_10(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_12(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_11(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_13(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_12(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_14(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_13(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_15(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_14(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_16(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_15(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_17(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_16(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_18(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_17(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_19(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_18(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P1_20(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P1_19(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))

	' #define SEL_P2_1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define SEL_P2_2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_3(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_4(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_3(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_5(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_4(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_6(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_5(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_7(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_6(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_8(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_7(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_9(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_8(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_10(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_9(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_11(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_10(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_12(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_11(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_13(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_12(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_14(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_13(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_15(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_14(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_16(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_15(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_17(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_16(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_18(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_17(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_19(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_18(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_P2_20(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_P2_19(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))




	' #define SEL_TT2_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define SEL_TT2_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_1(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_2(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_3(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_4(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_5(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_6(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_7(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_8(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_9(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_10(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_11(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_12(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_13(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_14(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_15(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_16(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_17(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_18(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define SEL_TT2_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(SEL_TT2_19(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))


	' #define DS_1(WHAT, NAME, SIGNATURE, TYPE_A) WHAT(NAME, SIGNATURE, TYPE_A)
	' #define DS_2(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_1(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_3(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_2(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_4(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_3(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_5(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_4(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_6(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_5(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_7(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_6(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_8(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_7(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_9(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_8(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_10(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_9(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_11(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_10(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_12(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_11(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_13(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_12(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_14(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_13(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_15(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_14(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_16(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_15(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_17(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_16(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_18(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_17(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_19(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_18(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DS_20(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DS_19(WHAT, NAME, SIGNATURE, __VA_ARGS__))


	' #define DP_1(WHAT, NAME, SIGNATURE, TYPE_A) WHAT(NAME, SIGNATURE, TYPE_A)
	' #define DP_2(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_1(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_3(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_2(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_4(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_3(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_5(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_4(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_6(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_5(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_7(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_6(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_8(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_7(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_9(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_8(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_10(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_9(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_11(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_10(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_12(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_11(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_13(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_12(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_14(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_13(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_15(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_14(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_16(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_15(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_17(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_16(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_18(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_17(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_19(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_18(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_20(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_19(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_21(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_20(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_22(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_21(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_23(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_22(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_24(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_23(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_25(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_24(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_26(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_25(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_27(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_26(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_28(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_27(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_29(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_28(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_30(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_29(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_31(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_30(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_32(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_31(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_33(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_32(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_34(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_33(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_35(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_34(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_36(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_35(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_37(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_36(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_38(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_37(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_39(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_38(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_40(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_39(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_41(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_40(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_42(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_41(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_43(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_42(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_44(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_43(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_45(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_44(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_46(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_45(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_47(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_46(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_48(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_47(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_49(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_48(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_50(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_49(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_51(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_50(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_52(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_51(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_53(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_52(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_54(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_53(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_55(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_54(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_56(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_55(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_57(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_56(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_58(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_57(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_59(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_58(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_60(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_59(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_61(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_60(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_62(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_61(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_63(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_62(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_64(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_63(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_65(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_64(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_66(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_65(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_67(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_66(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_68(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_67(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_69(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_68(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_70(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_69(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_71(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_70(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_72(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_71(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_73(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_72(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_74(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_73(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_75(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_74(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_76(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_75(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_77(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_76(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_78(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_77(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_79(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_78(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_80(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_79(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_81(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_80(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_82(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_81(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_83(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_82(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_84(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_83(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_85(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_84(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_86(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_85(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_87(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_86(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_88(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_87(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_89(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_88(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_90(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_89(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_91(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_90(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_92(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_91(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_93(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_92(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_94(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_93(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_95(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_94(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_96(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_95(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_97(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_96(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_98(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_97(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_99(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_98(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_100(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_99(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_101(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_100(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_102(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_101(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_103(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_102(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_104(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_103(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_105(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_104(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_106(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_105(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_107(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_106(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_108(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_107(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_109(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_108(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_110(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_109(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_111(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_110(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_112(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_111(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_113(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_112(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_114(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_113(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_115(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_114(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_116(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_115(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_117(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_116(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_118(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_117(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_119(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_118(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_120(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_119(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_121(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_120(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_122(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_121(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_123(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_122(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_124(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_123(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define DP_125(WHAT, NAME, SIGNATURE, TYPE_A, ...) WHAT(NAME, SIGNATURE, TYPE_A)EVAL(DP_124(WHAT, NAME, SIGNATURE, __VA_ARGS__))


	' #define DT_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define DT_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_1(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_2(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_3(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_4(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_5(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_6(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_7(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_8(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_9(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_10(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_11(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_12(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_13(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_14(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_15(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_16(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_17(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_18(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT_19(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))

	' #define DT2_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)
	' #define DT2_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_1(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_2(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_3(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_4(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_5(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_6(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_7(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_8(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_9(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_10(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_11(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_12(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_13(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_14(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_15(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_16(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_17(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_18(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define DT2_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B)EVAL(DT2_19(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))

	' #define TTT1_1(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TTT1_2(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_1(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_3(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_2(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_4(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_3(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_5(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_4(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_6(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_5(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_7(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_6(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_8(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_7(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_9(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_8(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_10(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_9(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_11(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_10(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_12(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_11(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_13(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_12(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_14(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_13(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_15(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_14(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_16(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_15(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_17(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_16(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_18(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_17(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_19(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_18(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT1_20(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT1_19(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))

	' #define TTT2_1(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TTT2_2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_1(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_4(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_5(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_4(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_6(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_5(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_7(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_6(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_8(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_7(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_9(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_8(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_10(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_9(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_11(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_10(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_12(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_11(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_13(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_12(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_14(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_13(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_15(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_14(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_16(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_15(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_17(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_16(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_18(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_17(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_19(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_18(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT2_20(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT2_19(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))


	' #define TTT3_1(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TTT3_2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_1(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_4(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_5(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_4(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_6(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_5(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_7(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_6(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_8(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_7(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_9(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_8(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_10(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_9(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_11(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_10(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_12(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_11(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_13(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_12(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_14(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_13(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_15(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_14(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_16(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_15(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_17(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_16(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_18(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_17(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_19(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_18(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TTT3_20(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TTT3_19(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))



	' #define TT1_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TT1_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT1_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT1_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))

	' #define TT2_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TT2_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT2_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT2_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))

	' #define TT3_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)
	' #define TT3_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_1(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_2(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_3(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_4(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_5(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_6(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_7(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_8(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_9(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_10(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_11(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_12(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_13(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_14(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_15(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_16(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_17(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_18(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))
	' #define TT3_20(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C, ...) WHAT(NAME, SIGNATURE, TYPE_A, TYPE_B, TYPE_C)EVAL(TT3_19(WHAT, NAME, SIGNATURE, TYPE_A, TYPE_B, __VA_ARGS__))


	' #define GET_MACRO_SEL_T(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_SEL_P1(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_SEL_P2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_SEL_TT1(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_SEL_TT2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_DS(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_DT(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_DP(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _100, _101, _102, _103, _104, _105, _106, _107, _108, _109, _110, _111, _112, _113, _114, _115, _116, _117, _118, _119, _120, _121, _122, _123, _124, _125, NAME,...) NAME
	' #define GET_MACRO_DT2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME


	' #define GET_MACRO_TT1(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_TT2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_TT3(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME

	' #define GET_MACRO_TTT1(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_TTT2(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define GET_MACRO_TTT3(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME

	' #define FOR_EACH_S1(WHAT, NAME, SIGNATURE, ...) EXPAND(GET_MACRO_SEL_T(__VA_ARGS__, SEL_T_20, SEL_T_19, SEL_T_18, SEL_T_17, SEL_T_16, SEL_T_15, SEL_T_14, SEL_T_13, SEL_T_12, SEL_T_11, SEL_T_10, SEL_T_9, SEL_T_8, SEL_T_7, SEL_T_6, SEL_T_5, SEL_T_4, SEL_T_3, SEL_T_2, SEL_T_1)(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define FOR_EACH_S2(WHAT, YTYPE, NAME, SIGNATURE, TYPES_A, ...) EXPAND(GET_MACRO_SEL_TT1(__VA_ARGS__, SEL_TT1_20, SEL_TT1_19, SEL_TT1_18, SEL_TT1_17, SEL_TT1_16, SEL_TT1_15, SEL_TT1_14, SEL_TT1_13, SEL_TT1_12, SEL_TT1_11, SEL_TT1_10, SEL_TT1_9, SEL_TT1_8, SEL_TT1_7, SEL_TT1_6, SEL_TT1_5, SEL_TT1_4, SEL_TT1_3, SEL_TT1_2, SEL_TT1_1)(WHAT, YTYPE, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define FOR_EACH_P1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, ...) EXPAND(GET_MACRO_SEL_P1(__VA_ARGS__, SEL_P1_20, SEL_P1_19, SEL_P1_18, SEL_P1_17, SEL_P1_16, SEL_P1_15, SEL_P1_14, SEL_P1_13, SEL_P1_12, SEL_P1_11, SEL_P1_10, SEL_P1_9, SEL_P1_8, SEL_P1_7, SEL_P1_6, SEL_P1_5, SEL_P1_4, SEL_P1_3, SEL_P1_2, SEL_P1_1)(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define FOR_EACH_P2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, ...) EXPAND2(GET_MACRO_SEL_P2(__VA_ARGS__, SEL_P2_20, SEL_P2_19, SEL_P2_18, SEL_P2_17, SEL_P2_16, SEL_P2_15, SEL_P2_14, SEL_P2_13, SEL_P2_12, SEL_P2_11, SEL_P2_10, SEL_P2_9, SEL_P2_8, SEL_P2_7, SEL_P2_6, SEL_P2_5, SEL_P2_4, SEL_P2_3, SEL_P2_2, SEL_P2_1)(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define FOR_EACH_S3(WHAT, NAME, SIGNATURE, TYPE_A, ...) EXPAND(GET_MACRO_SEL_TT2(__VA_ARGS__, SEL_TT2_20, SEL_TT2_19, SEL_TT2_18, SEL_TT2_17, SEL_TT2_16, SEL_TT2_15, SEL_TT2_14, SEL_TT2_13, SEL_TT2_12, SEL_TT2_11, SEL_TT2_10, SEL_TT2_9, SEL_TT2_8, SEL_TT2_7, SEL_TT2_6, SEL_TT2_5, SEL_TT2_4, SEL_TT2_3, SEL_TT2_2, SEL_TT2_1)(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define FOR_EACH_DS(WHAT, NAME, SIGNATURE, ...) EXPAND(GET_MACRO_DS(__VA_ARGS__, DS_20, DS_19, DS_18, DS_17, DS_16, DS_15, DS_14, DS_13, DS_12, DS_11, DS_10, DS_9, DS_8, DS_7, DS_6, DS_5, DS_4, DS_3, DS_2, DS_1)(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define FOR_EACH_DT(WHAT, NAME, SIGNATURE, TYPES_A, ...) EXPAND(GET_MACRO_DT(__VA_ARGS__, DT_20, DT_19, DT_18, DT_17, DT_16, DT_15, DT_14, DT_13, DT_12, DT_11, DT_10, DT_9, DT_8, DT_7, DT_6, DT_5, DT_4, DT_3, DT_2, DT_1)(WHAT, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define FOR_EACH_DT2(WHAT, NAME, SIGNATURE, TYPE_A, ...) EXPAND(GET_MACRO_DT2(__VA_ARGS__, DT2_20, DT2_19, DT2_18, DT2_17, DT2_16, DT2_15, DT2_14, DT2_13, DT2_12, DT2_11, DT2_10, DT2_9, DT2_8, DT2_7, DT2_6, DT2_5, DT2_4, DT2_3, DT2_2, DT2_1)(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define FOR_EACH_DP(WHAT, NAME, SIGNATURE, ...) EXPAND(GET_MACRO_DP(__VA_ARGS__, DP_125, DP_124, DP_123, DP_122, DP_121, DP_120, DP_119, DP_118, DP_117, DP_116, DP_115, DP_114, DP_113, DP_112, DP_111, DP_110, DP_109, DP_108, DP_107, DP_106, DP_105, DP_104, DP_103, DP_102, DP_101, DP_100, DP_99, DP_98, DP_97, DP_96, DP_95, DP_94, DP_93, DP_92, DP_91, DP_90, DP_89, DP_88, DP_87, DP_86, DP_85, DP_84, DP_83, DP_82, DP_81, DP_80, DP_79, DP_78, DP_77, DP_76, DP_75, DP_74, DP_73, DP_72, DP_71, DP_70, DP_69, DP_68, DP_67, DP_66, DP_65, DP_64, DP_63, DP_62, DP_61, DP_60, DP_59, DP_58, DP_57, DP_56, DP_55, DP_54, DP_53, DP_52, DP_51, DP_50, DP_49, DP_48, DP_47, DP_46, DP_45, DP_44, DP_43, DP_42, DP_41, DP_40, DP_39, DP_38, DP_37, DP_36, DP_35, DP_34, DP_33, DP_32, DP_31, DP_30, DP_29, DP_28, DP_27, DP_26, DP_25, DP_24, DP_23, DP_22, DP_21, DP_20, DP_19, DP_18, DP_17, DP_16, DP_15, DP_14, DP_13, DP_12, DP_11, DP_10, DP_9, DP_8, DP_7, DP_6, DP_5, DP_4, DP_3, DP_2, DP_1)(WHAT, NAME, SIGNATURE, __VA_ARGS__))


	' #define FOR_EACH_TT1(WHAT, NAME, SIGNATURE, TYPES_X, TYPES_Y, ...) EXPAND(GET_MACRO_TT1(__VA_ARGS__, TT1_20, TT1_19, TT1_18, TT1_17, TT1_16, TT1_15, TT1_14, TT1_13, TT1_12, TT1_11, TT1_10, TT1_9, TT1_8, TT1_7, TT1_6, TT1_5, TT1_4, TT1_3, TT1_2, TT1_1)(WHAT, NAME, SIGNATURE, TYPES_X, TYPES_Y, __VA_ARGS__))
	' #define FOR_EACH_TT2(WHAT, NAME, SIGNATURE, TYPE_Z, TYPES_X,  ...) EXPAND(GET_MACRO_TT2(__VA_ARGS__, TT2_20, TT2_19, TT2_18, TT2_17, TT2_16, TT2_15, TT2_14, TT2_13, TT2_12, TT2_11, TT2_10, TT2_9, TT2_8, TT2_7, TT2_6, TT2_5, TT2_4, TT2_3, TT2_2, TT2_1)(WHAT, NAME, SIGNATURE, TYPE_Z, TYPES_X, __VA_ARGS__))
	' #define FOR_EACH_TT3(WHAT, NAME, SIGNATURE, TYPE_Z, TYPE_Y, ...) EXPAND(GET_MACRO_TT3(__VA_ARGS__, TT3_20, TT3_19, TT3_18, TT3_17, TT3_16, TT3_15, TT3_14, TT3_13, TT3_12, TT3_11, TT3_10, TT3_9, TT3_8, TT3_7, TT3_6, TT3_5, TT3_4, TT3_3, TT3_2, TT3_1)(WHAT, NAME, SIGNATURE, TYPE_Z, TYPE_Y, __VA_ARGS__))

	' #define FOR_EACH_TTT1(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_Z, TYPES_Y, ...) EXPAND(GET_MACRO_TTT1(__VA_ARGS__, TTT1_20, TTT1_19, TTT1_18, TTT1_17, TTT1_16, TTT1_15, TTT1_14, TTT1_13, TTT1_12, TTT1_11, TTT1_10, TTT1_9, TTT1_8, TTT1_7, TTT1_6, TTT1_5, TTT1_4, TTT1_3, TTT1_2, TTT1_1)(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_Z, TYPES_Y, __VA_ARGS__))
	' #define FOR_EACH_TTT2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, ...) EXPAND(GET_MACRO_TTT2(__VA_ARGS__, TTT2_20, TTT2_19, TTT2_18, TTT2_17, TTT2_16, TTT2_15, TTT2_14, TTT2_13, TTT2_12, TTT2_11, TTT2_10, TTT2_9, TTT2_8, TTT2_7, TTT2_6, TTT2_5, TTT2_4, TTT2_3, TTT2_2, TTT2_1)(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, __VA_ARGS__))
	' #define FOR_EACH_TTT3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, ...) EXPAND(GET_MACRO_TTT3(__VA_ARGS__, TTT3_20, TTT3_19, TTT3_18, TTT3_17, TTT3_16, TTT3_15, TTT3_14, TTT3_13, TTT3_12, TTT3_11, TTT3_10, TTT3_9, TTT3_8, TTT3_7, TTT3_6, TTT3_5, TTT3_4, TTT3_3, TTT3_2, TTT3_1)(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, __VA_ARGS__))

	' #define _EXEC_SELECTOR_T(WHAT, NAME, SIGNATURE, ...) EVAL(FOR_EACH_S1(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define _EXEC_SELECTOR_P_1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, ...) EVAL(FOR_EACH_P1(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define _EXEC_SELECTOR_P_2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, ...) EVAL(FOR_EACH_P2(WHAT, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define _EXEC_SELECTOR_TT_1(WHAT, YTYPE, NAME, SIGNATURE, TYPES_A, ...) EVAL(FOR_EACH_S2(WHAT, YTYPE, NAME, SIGNATURE, TYPES_A, __VA_ARGS__))
	' #define _EXEC_SELECTOR_TT_2(WHAT, NAME, SIGNATURE, TYPE_A, ...) EVAL(FOR_EACH_S3(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define _EXEC_SINGLE_T(WHAT, NAME, SIGNATURE, ...) EVAL(FOR_EACH_DS(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define _EXEC_DOUBLE_T(WHAT, NAME, SIGNATURE, TYPES_A, ...) EVAL(FOR_EACH_DT(WHAT, NAME, SIGNATURE, LIST(TYPES_A), __VA_ARGS__))
	' #define _EXEC_DOUBLE_T2(WHAT, NAME, SIGNATURE, TYPE_A, ...) EVAL(FOR_EACH_DT2(WHAT, NAME, SIGNATURE, TYPE_A, __VA_ARGS__))
	' #define _EXEC_DOUBLE_P(WHAT, NAME, SIGNATURE, ...) EVAL(FOR_EACH_DP(WHAT, NAME, SIGNATURE, __VA_ARGS__))

	' #define _EXEC_SELECTOR_TTT_1(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_Z, TYPES_Y, ...) EVAL(FOR_EACH_TTT1(WHAT, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_Z, TYPES_Y, __VA_ARGS__))
	' #define _EXEC_SELECTOR_TTT_2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, ...) EVAL(FOR_EACH_TTT2(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, __VA_ARGS__))
	' #define _EXEC_SELECTOR_TTT_3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, ...) EVAL(FOR_EACH_TTT3(WHAT, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, __VA_ARGS__))

	' #define _EXEC_TRIPLE_T3(WHAT, NAME, SIGNATURE, TYPE_Z, TYPE_Y, ...) EVAL(FOR_EACH_TT3(WHAT, NAME, SIGNATURE, TYPE_Z, TYPE_Y, __VA_ARGS__))
	' #define _EXEC_TRIPLE_T2(WHAT, NAME, SIGNATURE, TYPE_Z, TYPES_X, ...) EVAL(FOR_EACH_TT2(WHAT, NAME, SIGNATURE, TYPE_Z, LIST(TYPES_X), __VA_ARGS__))
	' #define _EXEC_TRIPLE_T1(WHAT, NAME, SIGNATURE, TYPES_X, TYPES_Y, ...) EVAL(FOR_EACH_TT1(WHAT, NAME, SIGNATURE, LIST(TYPES_X), LIST(TYPES_Y), __VA_ARGS__))

	' #define DISPATCH_PAIRWISE(NAME, SIGNATURE, TYPE, TYPES_B) EVAL(_EXEC_DOUBLE_T2(RANDOMPAIRWISE2, NAME, SIGNATURE, TYPE, TYPES_B))
	' #define DISPATCH_PAIRWISE2(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE, ...) EVAL(_EXEC_SELECTOR_P_2(SELECTOR_PAIRWISE_2, XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE, __VA_ARGS__))

	' #define DISPATCH_DTYPES(NAME, SIGNATURE, TYPE, TYPES_B) EVAL(_EXEC_DOUBLE_T2(RANDOMDOUBLE2, NAME, SIGNATURE, TYPE, TYPES_B))
	' #define DISPATCH_DTYPES2(NAME, SIGNATURE, TYPE, ...) EVAL(_EXEC_SELECTOR_TT_2(SELECTOR_DOUBLE_2, NAME, SIGNATURE, TYPE, __VA_ARGS__))

	' #define DISPATCH_TTYPES2(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, ...) EVAL(_EXEC_SELECTOR_TTT_2(SELECTOR_TRIPLE_2, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, __VA_ARGS__))
	' #define DISPATCH_TTYPES3(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, ...) EVAL(_EXEC_SELECTOR_TTT_3(SELECTOR_TRIPLE_3, ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, __VA_ARGS__))


	' #ifndef __CLION_IDE__
	' #define BUILD_SINGLE_UNCHAINED_TEMPLATE(NAME, SIGNATURE, TYPES) EVAL(_EXEC_SINGLE_T(RANDOMSINGLEU, NAME, (SIGNATURE), TYPES))
	' #define BUILD_SINGLE_TEMPLATE(NAME, SIGNATURE, TYPES) EVAL(_EXEC_SINGLE_T(RANDOMSINGLE, NAME, (SIGNATURE), TYPES))
	' #define BUILD_SINGLE_TEMPLATE_TWICE(NAME, SIGNATURE, TYPES) EVAL(_EXEC_SELECTOR_T(TEMPLATE_SINGLE_TWICE, NAME, SIGNATURE, TYPES))
	' #define BUILD_DOUBLE_TEMPLATE(NAME, SIGNATURE, TYPES_A, TYPES_B) EVAL(_EXEC_DOUBLE_T(RANDOMDOUBLE, NAME, (SIGNATURE), (TYPES_A), TYPES_B))
	' #define BUILD_SINGLE_SELECTOR(XTYPE, NAME, SIGNATURE, TYPES) switch(XTYPE) { EVAL(_EXEC_SELECTOR_T(SELECTOR_SINGLE, NAME, SIGNATURE, TYPES)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type");}}
	' #define BUILD_SINGLE_SELECTOR_TWICE(XTYPE, NAME, SIGNATURE, TYPES) switch(XTYPE) { EVAL(_EXEC_SELECTOR_T(SELECTOR_SINGLE_TWICE, NAME, SIGNATURE, TYPES)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type");}}
	' #define BUILD_SINGLE_SELECTOR_THRICE(XTYPE, NAME, SIGNATURE, TYPES) switch(XTYPE) { EVAL(_EXEC_SELECTOR_T(SELECTOR_SINGLE_THRICE, NAME, SIGNATURE, TYPES)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type");}}


	' #define BUILD_SINGLE_PARTIAL_SELECTOR(XTYPE, NAME, SIGNATURE, TYPES) switch(XTYPE) { EVAL(_EXEC_SELECTOR_T(SELECTOR_PARTIAL_SINGLE, NAME, SIGNATURE, TYPES)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type"); }}
	' #define BUILD_DOUBLE_SELECTOR(XTYPE, YTYPE, NAME, SIGNATURE, TYPES_A, TYPES_B) switch(XTYPE) { EVAL(_EXEC_SELECTOR_TT_1(SELECTOR_DOUBLE, YTYPE, NAME, (SIGNATURE), (TYPES_B), TYPES_A)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__); fflush(stdout); throw std::runtime_error("bad data type");}}
	' #define BUILD_TRIPLE_SELECTOR(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_X, TYPES_Y, TYPES_Z) switch(XTYPE) { EVAL(_EXEC_SELECTOR_TTT_1(SELECTOR_TRIPLE, YTYPE, ZTYPE, NAME, SIGNATURE, (TYPES_Z), (TYPES_Y), TYPES_X)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type"); } }
	' #define BUILD_TRIPLE_TEMPLATE(NAME, SIGNATURE, TYPES_X, TYPES_Y, TYPES_Z) EVAL(_EXEC_TRIPLE_T1(RANDOMTRIPLE, NAME, (SIGNATURE), (TYPES_X), (TYPES_Y), TYPES_Z))
	' #define BUILD_PAIRWISE_TEMPLATE(NAME, SIGNATURE, TYPES_A) EVAL(_EXEC_DOUBLE_P(RANDOMPAIRWISE, NAME, (SIGNATURE), TYPES_A))
	' #define BUILD_PAIRWISE_SELECTOR(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, TYPES_B) switch(XTYPE) { EVAL(_EXEC_SELECTOR_P_1(SELECTOR_PAIRWISE, XTYPE, YTYPE, ZTYPE, NAME, (SIGNATURE), (TYPES_B), TYPES_A)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d", XTYPE, __FILE__, __LINE__);  fflush(stdout); throw std::runtime_error("bad data type"); }}
	' #else
	' #define BUILD_SINGLE_UNCHAINED_TEMPLATE(NAME, SIGNATURE, TYPES)
	' #define BUILD_SINGLE_TEMPLATE(NAME, SIGNATURE, TYPES)
	' #define BUILD_SINGLE_TEMPLATE_TWICE(NAME, SIGNATURE, TYPES)
	' #define BUILD_DOUBLE_TEMPLATE(NAME, SIGNATURE, TYPES_A, TYPES_B)
	' #define BUILD_SINGLE_SELECTOR(XTYPE, NAME, SIGNATURE, TYPES)
	' #define BUILD_SINGLE_SELECTOR_TWICE(XTYPE, NAME, SIGNATURE, TYPES)
	' #define BUILD_SINGLE_SELECTOR_THRICE(XTYPE, NAME, SIGNATURE, TYPES)
	' #define BUILD_SINGLE_PARTIAL_SELECTOR(XTYPE, NAME, SIGNATURE, TYPES)
	' #define BUILD_DOUBLE_SELECTOR(XTYPE, YTYPE, NAME, SIGNATURE, TYPES_A, TYPES_B)
	' #define BUILD_TRIPLE_SELECTOR(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_X, TYPES_Y, TYPES_Z)
	' #define BUILD_TRIPLE_TEMPLATE(NAME, SIGNATURE, TYPES_X, TYPES_Y, TYPES_Z)
	' #define BUILD_PAIRWISE_TEMPLATE(NAME, SIGNATURE, TYPES_A)
	' #define BUILD_PAIRWISE_SELECTOR(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_A, TYPES_B)
	' #endif

	' #define LIST(...) __VA_ARGS__

	' #define _SELECTOR_DOUBLE_2(NAME, SIGNATURE, TYPE_A, ENUM, TYPE_B) case ENUM: { NAME<TYPE_A, TYPE_B> SIGNATURE; break; };
	' #define SELECTOR_DOUBLE_2(NAME, SIGNATURE, TYPE_A, TYPE_B) EVALUATING_PASTE2(_SELECT, OR_DOUBLE_2(NAME, UNPAREN3(SIGNATURE), TYPE_A, UNPAREN3(TYPE_B)))

	' #define _SELECTOR_DOUBLE(YTYPE, NAME, SIGNATURE, ENUM, TYPE_A, ...) case ENUM: { switch(YTYPE) { EXPAND(DISPATCH_DTYPES2(NAME, SIGNATURE, TYPE_A, __VA_ARGS__)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d\n", YTYPE, __FILE__, __LINE__); fflush(stdout);}}; break; };
	' #define SELECTOR_DOUBLE(YTYPE, NAME, SIGNATURE, TYPES_B, TYPE_A)  EVALUATING_PASTE(_SELECTOR, _DOUBLE(YTYPE, NAME, SIGNATURE, UNPAREN(TYPE_A), UNPAREN(TYPES_B)))

	' #define _SELECTOR_PAIRWISE_2(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, ENUM, TYPE_B) case ENUM: { if (ZTYPE == YTYPE) {NAME<TYPE_A, TYPE_B, TYPE_B> SIGNATURE;} else if (XTYPE == ZTYPE ){NAME<TYPE_A, TYPE_B, TYPE_A> SIGNATURE;} else {printf("[ERROR] Unknown dtypeX=%d on %s:%d\n", YTYPE, __FILE__, __LINE__); fflush(stdout); throw std::runtime_error("Unknown Z operand");}; break; };
	' #define SELECTOR_PAIRWISE_2(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, TYPE_B) EVALUATING_PASTE2(_SELECT, OR_PAIRWISE_2(XTYPE, YTYPE, ZTYPE, NAME, UNPAREN3(SIGNATURE), TYPE_A, UNPAREN3(TYPE_B)))
	' #define _SELECTOR_PAIRWISE(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, ENUM, TYPE_A, ...) case ENUM: { switch(YTYPE) { EXPAND(DISPATCH_PAIRWISE2(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPE_A, __VA_ARGS__)); default: {printf("[ERROR] Unknown dtypeX=%d on %s:%d\n", YTYPE, __FILE__, __LINE__); fflush(stdout);}}; break; };
	' #define SELECTOR_PAIRWISE(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_B, TYPE_A)  EVALUATING_PASTE(_SELECTOR, _PAIRWISE(XTYPE, YTYPE, ZTYPE, NAME, SIGNATURE, UNPAREN(TYPE_A), UNPAREN(TYPES_B)))

	' #define _SELECTOR_TRIPLE_3(NAME, SIGNATURE, TYPE_X, TYPE_Y, ENUM_Z, TYPE_Z) case ENUM_Z: { NAME<TYPE_X, TYPE_Y, TYPE_Z>SIGNATURE;}; break;
	' #define SELECTOR_TRIPLE_3(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, TYPE_Z) EVALUATING_PASTE3(_SELECTOR, _TRIPLE_3(NAME, SIGNATURE, TYPE_X, TYPE_Y, UNPAREN3(TYPE_Z)))
	' #define _SELECTOR_TRIPLE_2(ZTYPE, NAME, SIGNATURE, TYPE_X, ENUM_Y, TYPE_Y, TYPES_Z) case ENUM_Y: { switch (ZTYPE) { EXPAND2(DISPATCH_TTYPES3(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPE_Y, UNPAREN3(TYPES_Z))); default: {printf("[ERROR] Unknown dtypeZ=%d on %s:%d\n", ZTYPE, __FILE__, __LINE__); ; fflush(stdout);} } break; };
	' #define SELECTOR_TRIPLE_2(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, TYPE_Y) EVALUATING_PASTE2(_SELECTOR, _TRIPLE_2(ZTYPE, NAME, SIGNATURE, TYPE_X, UNPAREN2(TYPE_Y), TYPES_Z))
	' #define _SELECTOR_TRIPLE(YTYPE, ZTYPE, NAME, SIGNATURE, ENUM_X, TYPE_X, TYPES_Z, ...) case ENUM_X: { switch (YTYPE) { EXPAND(DISPATCH_TTYPES2(ZTYPE, NAME, SIGNATURE, TYPE_X, TYPES_Z, __VA_ARGS__ )); default: {printf("[ERROR] Unknown dtypeY=%d on %s:%d\n", YTYPE, __FILE__, __LINE__); ; fflush(stdout);} } break; };
	' #define SELECTOR_TRIPLE(YTYPE, ZTYPE, NAME, SIGNATURE, TYPES_Z, TYPES_Y, TYPE_X) EVALUATING_PASTE(_SELECTOR, _TRIPLE(YTYPE, ZTYPE, NAME, SIGNATURE, UNPAREN(TYPE_X), TYPES_Z, UNPAREN(TYPES_Y)))

	' #define _SELECTOR_SINGLE(A, B, C, D) case C: {A<D>B; break;};
	' #define SELECTOR_SINGLE(A, B, C) EVALUATING_PASTE(_SEL, ECTOR_SINGLE(A, B, UNPAREN(C)))

	' #define _SELECTOR_SINGLE_THRICE(A, B, C, D) case C: {A<D, D, D>B; break;};
	' #define SELECTOR_SINGLE_THRICE(A, B, C) EVALUATING_PASTE(_SEL, ECTOR_SINGLE_THRICE(A, B, UNPAREN(C)))

	' #define _SELECTOR_SINGLE_TWICE(A, B, C, D) case C: {A<D, D>B; break;};
	' #define SELECTOR_SINGLE_TWICE(A, B, C) EVALUATING_PASTE(_SEL, ECTOR_SINGLE_TWICE(A, B, UNPAREN(C)))

	' #define _TEMPLATE_SINGLE_TWICE(A, B, C, D) A<D, D>B;
	' #define TEMPLATE_SINGLE_TWICE(A, B, C) EVALUATING_PASTE(_TEM, PLATE_SINGLE_TWICE(A, B, UNPAREN(C)))

	' #define _SELECTOR_PARTIAL_SINGLE(A, B, C, D) case C: {A D, UNPAREN2(B); break;};
	' #define SELECTOR_PARTIAL_SINGLE(A, B, C) EVALUATING_PASTE(_SEL, ECTOR_PARTIAL_SINGLE(A, B, UNPAREN(C)))

	' #define _RANDOMSINGLE(A, B, C, D) A<D>B;
	' #define _RANDOMSINGLEU(A, B, C, D) A D B;
	' #define RANDOMSINGLE(A, B, C) EVALUATING_PASTE(_RAND, OMSINGLE(A, UNPAREN(B), UNPAREN(C)))
	' #define RANDOMSINGLEU(A, B, C) EVALUATING_PASTE(_RAND, OMSINGLEU(A, UNPAREN(B), UNPAREN(C)))
	' #define RANDOMDOUBLE(A, B, C, D) EXPAND(DISPATCH_DTYPES(A, UNPAREN(B), D, UNPAREN(C)))

	' #define _RANDOMDOUBLE2(A, B, C, D, E, F) A<F,D>B;
	' #define RANDOMDOUBLE2(A, B, C, D) EVALUATING_PASTE(_RAND, OMDOUBLE2(A, B, UNPAREN(C), UNPAREN(D)))

	' #define _RANDOMPAIRWISE2(A, B, C, D, E) A<B,C,D>E;
	' #define RANDOMPAIRWISE(A, B, C) EVALUATING_PASTE(_RANDOM, PAIRWISE2(A, UNPAREN(C), UNPAREN(B)))

	' #define _RANDOMTRIPLE3(A, B, ZN, ZT, YN, YT, XN, XT) A<XT, YT, ZT>B;
	' #define RANDOMTRIPLE3(A, B, Z, Y, X) EVALUATING_PASTE(_RANDOM, TRIPLE3(A, UNPAREN(B), UNPAREN(Z), UNPAREN(Y), UNPAREN(X)))

	' #define _RANDOMTRIPLE2(NAME, SIGNATURE, TYPE_Z, TYPE_Y, TYPES_X)  EVALX(_EXEC_TRIPLE_T3(RANDOMTRIPLE3, NAME, SIGNATURE, TYPE_Z, TYPE_Y, UNPAREN(TYPES_X)))
	' #define RANDOMTRIPLE2(NAME, SIGNATURE, TYPE_Z, TYPES_X, TYPE_Y) _RANDOMTRIPLE2(NAME, SIGNATURE, TYPE_Z, TYPE_Y, TYPES_X)
	' #define _RANDOMTRIPLE(NAME, SIGNATURE, TYPE_Z, TYPES_X, TYPES_Y) EVAL(_EXEC_TRIPLE_T2(RANDOMTRIPLE2, NAME, SIGNATURE, TYPE_Z, TYPES_X, UNPAREN(TYPES_Y)))
	' #define RANDOMTRIPLE(NAME, SIGNATURE, TYPES_X, TYPES_Y, TYPE_Z)  _RANDOMTRIPLE(NAME, SIGNATURE, TYPE_Z, TYPES_X, TYPES_Y)


	' #define BROADCAST(NAME) sd::BroadcastOpsTuple::custom(sd::scalar::NAME, sd::pairwise::NAME, sd::broadcast::NAME)
	' #define BROADCAST_BOOL(NAME) sd::BroadcastBoolOpsTuple::custom(sd::scalar::NAME, sd::pairwise::NAME, sd::broadcast::NAME)

	public static final Integer ALL_STRINGS =UTF32
	public static final Integer ALL_INDICES =INT64
	public static final Integer ALL_INTS =UINT64
	public static final Integer ALL_FLOATS =BFLOAT16

	' #endif //TESTS_CPU_TYPE_BOILERPLATE_H


	' Parsed from system/op_boilerplate.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' * This set of macros is used to generate kernel calls/method calls/cuda kernels on the fly, during precompile phase.
	' *
	' * Entry macros start with DISPATCH_* name.
	' * Basically they are rolling through *_OPS list, building list of kernels.
	' * And DISPATCH_KERNEL_META rolls through any two *_OPS list, building meta kernels and their host counterparts
	' *
	' *
	' * Those scary FE_*, FX_*, FZ_*, FM_* etc macro walls are used to give preprocessor ability to loop over list of argument,
	' * which emulates forEach() pattern.
	' *
	' * I.e. here's macro call which generates CUDA kernels for RANDOM_OPS:
	' *
	' * DISPATCH_KERNEL_SIMPLE(randomSingle_, randomSingleGeneric, float, INPUT(Nd4jPointer state, float *z, int *zShapeBuffer, float *extraArguments), PARAMS(state, z, zShapeBuffer, extraArguments), OPS_A(RANDOM_OPS))
	' *
	' * we provide arguments:
	' *      output method template
	' *      target generic kernel
	' *      dataType
	' *      signature
	' *      parameters to be passed into generic kernel
	' *      list of operations
	' *
	' *
	' * List of operations used are defined in the same *.h file, i.e. for RandomOps it's defined as:
	' * #define RANDOM_OPS \
	' *       (0, randomOps::UniformDistribution) ,\
	' *       (1, randomOps::DropOut) ,\
	' *       (2, randomOps::DropOutInverted) ,\
	' *       (3, randomOps::ProbablisticMerge) ,\
	' *       (4, randomOps::Linspace) ,\
	' *       (5, randomOps::Choice) ,\
	' *       (6, randomOps::GaussianDistribution) ,\
	' *       (7, randomOps::BernoulliDistribution) ,\
	' *       (8, randomOps::BinomialDistribution)
	' *
	' *
	' * So, DISPATCH_KERNEL_SIMPLE call will generate one kernel for each of ops.
	' * This allows us easy addition of new operations. Basically one should just add new Op to the list, and recompile libnd4j
	' *
	' * HINT: To debug macro you might want to use simple trick: open console and run "watch -n 1 gcc -e file.h"
	' * This will give you real-time result of macro preprocessing, which will greatly simplify invention process.
	' *
	' *
	' * @author Paul Dubs (@treo)
	' * @author raver119@gmail.com
	' 
	' #pragma once
	' #ifndef OP_BOILERPLATE_HH
	' #define OP_BOILERPLATE_HH

	' #include <system/openmp_pragmas.h>
	' #include <system/type_boilerplate.h>
	' #include <exceptions/allocation_exception.h>
	' #include <memory/MemoryTracker.h>

	' #ifdef __CUDACC__

	' #elif __JAVACPP_HACK__

	' #define meta_def
	' #define op_def
	' #define op_def_special
	' #define linkage

	' #elif _MSC_VER

	' #elif __clang__

	' #define op_def inline
	' #define op_def_special inline
	' #define meta_def inline
	' #define linkage

	' #elif __GNUC__

	' #define linkage
	' #define meta_def _Pragma("omp declare simd") inline __attribute__((always_inline))
	' #define op_def _Pragma("omp declare simd") inline __attribute__((always_inline))
	' #define op_def_special _Pragma("omp declare simd") inline __attribute__((always_inline))

	' #endif


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public static native @MemberGetter double ELEMENT_THRESHOLD();
	public static native Double ELEMENT_THRESHOLD()
	public static final Double ELEMENT_THRESHOLD = ELEMENT_THRESHOLD()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public static native @MemberGetter double TAD_THRESHOLD();
	public static native Double TAD_THRESHOLD()
	public static final Double TAD_THRESHOLD = TAD_THRESHOLD()

	' #define SHAPELIST(...)  new ShapeList({__VA_ARGS__}, block.workspace() != nullptr)

	' #ifdef __CUDA_ARCH__
	' #define PRINT_FIRST(...)    if (threadIdx.x == 0 && blockIdx.x == 0) {printf(__VA_ARGS__); }
	' #else
	' #define PRINT_FIRST(...)    printf(__VA_ARGS__); fflush(stdout)
	' #endif

	' #define DEBUG_CALL(STREAM)      if (sd::Environment::getInstance().isDebug()) { cudaError_t tRes = cudaStreamSynchronize(*STREAM); checkCudaErrors(tRes); if (tRes != 0) { throw std::runtime_error(); }; }
	' #define DEBUG_KERNEL(STREAM, OP_NUM)       if (sd::Environment::getInstance().isDebug()) { cudaError_t tRes = cudaStreamSynchronize(*STREAM); checkCudaErrors(tRes); if (tRes != 0) {std::string tFile(__FILE__); std::string tOp = "Kernel OpNum failed: [" + sd::StringUtils::valueToString<int>(OP_NUM) + std::string("]; File: ") + tFile + std::string(":") + sd::StringUtils::valueToString<int>(__LINE__); throw std::runtime_error(tOp.c_str()); }; }


	' #define LAUNCH(A, B, C, D) <<<A, B, C, D>>>


	' #define CONCAT2(A,B) A ## B
	' #define CONCAT3(A,B,C) A ## B ## C

	' #define ARGMIX3(A,B,C) A ## B ## _## C
	' #define ARGMIX4(A,B,C,D) A ## B ## _## C ## _ ## D

	' #define MIX2(A,B) A ## _ ## B
	' #define MIX3(A,B,C) A ## _ ## B ## _## C
	' #define MIX4(A,B,C,D) A ## _ ## B ## _## C ## _ ## D


	' #define EMPTY()
	' #define DEFER(id) id EMPTY()
	' #define OBSTRUCT(...) __VA_ARGS__ DEFER(EMPTY)()


	' #define _EXPAND_OP_CALL(FN, SIG, NUM, TYPE) case NUM: { FN<TYPE<X>>SIG; break; };
	' #define _EXPAND_OP_CALL_TT(FN, SIG, NUM, TYPE) case NUM: { FN<TYPE<X,Y>>SIG; break; };
	' #define _EXPAND_OP_CALL_TTT(FN, SIG, NUM, TYPE) case NUM: { FN<TYPE<X,Y,Z>>SIG; break; };
	' #define _EXPAND_RETURNING_OP_CALL(FN, SIG, NUM, TYPE) else if(opNum == NUM){ return FN<TYPE<X>>SIG; }
	' #define _EXPAND_RETURNING_OP_CALL_TT(FN, SIG, NUM, TYPE) else if(opNum == NUM){ return FN<TYPE<X, Y>>SIG; }
	' #define _EXPAND_PACKED_OP_CALL(FN, SIG, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_CALL (FN, SIG, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_OP_CALL_TT(FN, SIG, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_CALL_TT (FN, SIG, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_OP_CALL_TTT(FN, SIG, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_CALL_TTT (FN, SIG, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_RETURNING_PACKED_OP_CALL(FN, SIG, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _RETURNING_OP_CALL (FN, SIG, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_RETURNING_PACKED_OP_CALL_TT(FN, SIG, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _RETURNING_OP_CALL_TT (FN, SIG, UNPAREN(OPNUM_PAIR)))

	' #define FE_1(WHAT, FN, SIG, OPNUM_PAIR) WHAT(FN, SIG, OPNUM_PAIR)
	' #define FE_2(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_1(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_3(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_2(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_4(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_3(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_5(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_4(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_6(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_5(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_7(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_6(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_8(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_7(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_9(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_8(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_10(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_9(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_11(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_10(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_12(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_11(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_13(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_12(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_14(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_13(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_15(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_14(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_16(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_15(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_17(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_16(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_18(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_17(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_19(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_18(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_20(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_19(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_21(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_20(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_22(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_21(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_23(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_22(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_24(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_23(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_25(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_24(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_26(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_25(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_27(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_26(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_28(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_27(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_29(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_28(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_30(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_29(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_31(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_30(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_32(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_31(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_33(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_32(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_34(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_33(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_35(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_34(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_36(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_35(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_37(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_36(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_38(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_37(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_39(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_38(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_40(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_39(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_41(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_40(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_42(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_41(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_43(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_42(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_44(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_43(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_45(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_44(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_46(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_45(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_47(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_46(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_48(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_47(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_49(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_48(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_50(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_49(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_51(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_50(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_52(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_51(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_53(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_52(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_54(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_53(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_55(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_54(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_56(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_55(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_57(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_56(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_58(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_57(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_59(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_58(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_60(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_59(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_61(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_60(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_62(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_61(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_63(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_62(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_64(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_63(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_65(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_64(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_66(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_65(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_67(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_66(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_68(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_67(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_69(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_68(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_70(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_69(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_71(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_70(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_72(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_71(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_73(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_72(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_74(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_73(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_75(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_74(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_76(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_75(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_77(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_76(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_78(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_77(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_79(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_78(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_80(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_79(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_81(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_80(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_82(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_81(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_83(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_82(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_84(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_83(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_85(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_84(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_86(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_85(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_87(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_86(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_88(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_87(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_89(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_88(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_90(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_89(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_91(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_90(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_92(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_91(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_93(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_92(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_94(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_93(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_95(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_94(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_96(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_95(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_97(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_96(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_98(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_97(WHAT, FN, SIG, __VA_ARGS__))
	' #define FE_99(WHAT, FN, SIG, OPNUM_PAIR, ...) WHAT(FN, SIG, OPNUM_PAIR)EVAL(FE_98(WHAT, FN, SIG, __VA_ARGS__))


	' #define CL1_1(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)
	' #define CL1_2(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_1(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_3(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_2(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_4(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_3(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_5(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_4(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_6(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_5(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_7(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_6(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_8(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_7(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_9(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_8(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_10(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_9(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_11(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_10(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_12(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_11(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_13(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_12(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_14(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_13(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_15(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_14(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_16(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_15(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_17(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_16(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_18(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_17(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_19(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_18(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_20(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_19(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_21(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_20(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_22(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_21(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_23(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_22(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_24(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_23(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_25(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_24(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_26(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_25(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_27(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_26(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_28(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_27(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_29(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_28(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_30(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_29(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_31(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_30(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_32(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_31(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_33(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_32(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_34(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_33(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_35(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_34(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_36(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_35(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_37(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_36(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_38(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_37(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_39(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_38(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_40(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_39(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_41(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_40(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_42(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_41(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_43(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_42(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_44(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_43(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_45(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_44(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_46(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_45(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_47(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_46(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_48(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_47(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_49(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_48(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_50(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_49(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_51(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_50(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_52(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_51(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_53(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_52(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_54(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_53(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_55(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_54(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_56(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_55(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_57(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_56(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_58(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_57(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_59(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_58(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_60(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_59(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_61(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_60(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_62(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_61(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_63(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_62(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_64(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_63(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_65(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_64(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_66(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_65(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_67(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_66(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_68(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_67(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_69(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_68(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_70(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_69(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_71(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_70(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_72(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_71(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_73(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_72(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_74(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_73(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_75(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_74(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_76(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_75(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_77(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_76(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_78(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_77(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_79(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_78(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_80(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_79(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_81(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_80(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_82(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_81(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_83(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_82(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_84(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_83(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_85(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_84(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_86(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_85(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_87(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_86(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_88(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_87(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_89(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_88(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_90(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_89(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_91(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_90(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_92(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_91(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_93(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_92(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_94(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_93(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_95(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_94(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_96(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_95(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_97(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_96(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_98(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_97(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define CL1_99(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(CL1_98(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))


	' #define TR_1(WHAT, TYPE, OPNUM_PAIR) WHAT(TYPE, OPNUM_PAIR)
	' #define TR_2(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_1(WHAT, TYPE, __VA_ARGS__))
	' #define TR_3(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_2(WHAT, TYPE, __VA_ARGS__))
	' #define TR_4(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_3(WHAT, TYPE, __VA_ARGS__))
	' #define TR_5(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_4(WHAT, TYPE, __VA_ARGS__))
	' #define TR_6(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_5(WHAT, TYPE, __VA_ARGS__))
	' #define TR_7(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_6(WHAT, TYPE, __VA_ARGS__))
	' #define TR_8(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_7(WHAT, TYPE, __VA_ARGS__))
	' #define TR_9(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_8(WHAT, TYPE, __VA_ARGS__))
	' #define TR_10(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_9(WHAT, TYPE, __VA_ARGS__))
	' #define TR_11(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_10(WHAT, TYPE, __VA_ARGS__))
	' #define TR_12(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_11(WHAT, TYPE, __VA_ARGS__))
	' #define TR_13(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_12(WHAT, TYPE, __VA_ARGS__))
	' #define TR_14(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_13(WHAT, TYPE, __VA_ARGS__))
	' #define TR_15(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_14(WHAT, TYPE, __VA_ARGS__))
	' #define TR_16(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_15(WHAT, TYPE, __VA_ARGS__))
	' #define TR_17(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_16(WHAT, TYPE, __VA_ARGS__))
	' #define TR_18(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_17(WHAT, TYPE, __VA_ARGS__))
	' #define TR_19(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_18(WHAT, TYPE, __VA_ARGS__))
	' #define TR_20(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_19(WHAT, TYPE, __VA_ARGS__))
	' #define TR_21(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_20(WHAT, TYPE, __VA_ARGS__))
	' #define TR_22(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_21(WHAT, TYPE, __VA_ARGS__))
	' #define TR_23(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_22(WHAT, TYPE, __VA_ARGS__))
	' #define TR_24(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_23(WHAT, TYPE, __VA_ARGS__))
	' #define TR_25(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_24(WHAT, TYPE, __VA_ARGS__))
	' #define TR_26(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_25(WHAT, TYPE, __VA_ARGS__))
	' #define TR_27(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_26(WHAT, TYPE, __VA_ARGS__))
	' #define TR_28(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_27(WHAT, TYPE, __VA_ARGS__))
	' #define TR_29(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_28(WHAT, TYPE, __VA_ARGS__))
	' #define TR_30(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_29(WHAT, TYPE, __VA_ARGS__))
	' #define TR_31(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_30(WHAT, TYPE, __VA_ARGS__))
	' #define TR_32(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_31(WHAT, TYPE, __VA_ARGS__))
	' #define TR_33(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_32(WHAT, TYPE, __VA_ARGS__))
	' #define TR_34(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_33(WHAT, TYPE, __VA_ARGS__))
	' #define TR_35(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_34(WHAT, TYPE, __VA_ARGS__))
	' #define TR_36(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_35(WHAT, TYPE, __VA_ARGS__))
	' #define TR_37(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_36(WHAT, TYPE, __VA_ARGS__))
	' #define TR_38(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_37(WHAT, TYPE, __VA_ARGS__))
	' #define TR_39(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_38(WHAT, TYPE, __VA_ARGS__))
	' #define TR_40(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_39(WHAT, TYPE, __VA_ARGS__))
	' #define TR_41(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_40(WHAT, TYPE, __VA_ARGS__))
	' #define TR_42(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_41(WHAT, TYPE, __VA_ARGS__))
	' #define TR_43(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_42(WHAT, TYPE, __VA_ARGS__))
	' #define TR_44(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_43(WHAT, TYPE, __VA_ARGS__))
	' #define TR_45(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_44(WHAT, TYPE, __VA_ARGS__))
	' #define TR_46(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_45(WHAT, TYPE, __VA_ARGS__))
	' #define TR_47(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_46(WHAT, TYPE, __VA_ARGS__))
	' #define TR_48(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_47(WHAT, TYPE, __VA_ARGS__))
	' #define TR_49(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_48(WHAT, TYPE, __VA_ARGS__))
	' #define TR_50(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_49(WHAT, TYPE, __VA_ARGS__))
	' #define TR_51(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_50(WHAT, TYPE, __VA_ARGS__))
	' #define TR_52(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_51(WHAT, TYPE, __VA_ARGS__))
	' #define TR_53(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_52(WHAT, TYPE, __VA_ARGS__))
	' #define TR_54(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_53(WHAT, TYPE, __VA_ARGS__))
	' #define TR_55(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_54(WHAT, TYPE, __VA_ARGS__))
	' #define TR_56(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_55(WHAT, TYPE, __VA_ARGS__))
	' #define TR_57(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_56(WHAT, TYPE, __VA_ARGS__))
	' #define TR_58(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_57(WHAT, TYPE, __VA_ARGS__))
	' #define TR_59(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_58(WHAT, TYPE, __VA_ARGS__))
	' #define TR_60(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_59(WHAT, TYPE, __VA_ARGS__))
	' #define TR_61(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_60(WHAT, TYPE, __VA_ARGS__))
	' #define TR_62(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_61(WHAT, TYPE, __VA_ARGS__))
	' #define TR_63(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_62(WHAT, TYPE, __VA_ARGS__))
	' #define TR_64(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_63(WHAT, TYPE, __VA_ARGS__))
	' #define TR_65(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_64(WHAT, TYPE, __VA_ARGS__))
	' #define TR_66(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_65(WHAT, TYPE, __VA_ARGS__))
	' #define TR_67(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_66(WHAT, TYPE, __VA_ARGS__))
	' #define TR_68(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_67(WHAT, TYPE, __VA_ARGS__))
	' #define TR_69(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_68(WHAT, TYPE, __VA_ARGS__))
	' #define TR_70(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_69(WHAT, TYPE, __VA_ARGS__))
	' #define TR_71(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_70(WHAT, TYPE, __VA_ARGS__))
	' #define TR_72(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_71(WHAT, TYPE, __VA_ARGS__))
	' #define TR_73(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_72(WHAT, TYPE, __VA_ARGS__))
	' #define TR_74(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_73(WHAT, TYPE, __VA_ARGS__))
	' #define TR_75(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_74(WHAT, TYPE, __VA_ARGS__))
	' #define TR_76(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_75(WHAT, TYPE, __VA_ARGS__))
	' #define TR_77(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_76(WHAT, TYPE, __VA_ARGS__))
	' #define TR_78(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_77(WHAT, TYPE, __VA_ARGS__))
	' #define TR_79(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_78(WHAT, TYPE, __VA_ARGS__))
	' #define TR_80(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_79(WHAT, TYPE, __VA_ARGS__))
	' #define TR_81(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_80(WHAT, TYPE, __VA_ARGS__))
	' #define TR_82(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_81(WHAT, TYPE, __VA_ARGS__))
	' #define TR_83(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_82(WHAT, TYPE, __VA_ARGS__))
	' #define TR_84(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_83(WHAT, TYPE, __VA_ARGS__))
	' #define TR_85(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_84(WHAT, TYPE, __VA_ARGS__))
	' #define TR_86(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_85(WHAT, TYPE, __VA_ARGS__))
	' #define TR_87(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_86(WHAT, TYPE, __VA_ARGS__))
	' #define TR_88(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_87(WHAT, TYPE, __VA_ARGS__))
	' #define TR_89(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_88(WHAT, TYPE, __VA_ARGS__))
	' #define TR_90(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_89(WHAT, TYPE, __VA_ARGS__))
	' #define TR_91(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_90(WHAT, TYPE, __VA_ARGS__))
	' #define TR_92(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_91(WHAT, TYPE, __VA_ARGS__))
	' #define TR_93(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_92(WHAT, TYPE, __VA_ARGS__))
	' #define TR_94(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_93(WHAT, TYPE, __VA_ARGS__))
	' #define TR_95(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_94(WHAT, TYPE, __VA_ARGS__))
	' #define TR_96(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_95(WHAT, TYPE, __VA_ARGS__))
	' #define TR_97(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_96(WHAT, TYPE, __VA_ARGS__))
	' #define TR_98(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_97(WHAT, TYPE, __VA_ARGS__))
	' #define TR_99(WHAT, TYPE, OPNUM_PAIR, ...) WHAT(TYPE, OPNUM_PAIR)EVAL(TR_98(WHAT, TYPE, __VA_ARGS__))

	' #define DIR_1(WHAT, PARAMS, OPNUM_PAIR) WHAT(PARAMS, OPNUM_PAIR)
	' #define DIR_2(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_1(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_3(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_2(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_4(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_3(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_5(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_4(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_6(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_5(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_7(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_6(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_8(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_7(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_9(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_8(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_10(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_9(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_11(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_10(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_12(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_11(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_13(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_12(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_14(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_13(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_15(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_14(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_16(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_15(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_17(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_16(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_18(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_17(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_19(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_18(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_20(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_19(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_21(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_20(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_22(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_21(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_23(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_22(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_24(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_23(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_25(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_24(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_26(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_25(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_27(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_26(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_28(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_27(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_29(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_28(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_30(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_29(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_31(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_30(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_32(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_31(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_33(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_32(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_34(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_33(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_35(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_34(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_36(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_35(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_37(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_36(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_38(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_37(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_39(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_38(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_40(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_39(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_41(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_40(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_42(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_41(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_43(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_42(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_44(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_43(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_45(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_44(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_46(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_45(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_47(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_46(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_48(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_47(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_49(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_48(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_50(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_49(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_51(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_50(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_52(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_51(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_53(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_52(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_54(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_53(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_55(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_54(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_56(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_55(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_57(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_56(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_58(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_57(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_59(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_58(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_60(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_59(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_61(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_60(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_62(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_61(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_63(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_62(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_64(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_63(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_65(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_64(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_66(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_65(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_67(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_66(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_68(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_67(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_69(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_68(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_70(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_69(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_71(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_70(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_72(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_71(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_73(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_72(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_74(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_73(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_75(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_74(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_76(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_75(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_77(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_76(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_78(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_77(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_79(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_78(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_80(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_79(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_81(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_80(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_82(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_81(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_83(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_82(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_84(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_83(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_85(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_84(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_86(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_85(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_87(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_86(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_88(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_87(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_89(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_88(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_90(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_89(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_91(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_90(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_92(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_91(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_93(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_92(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_94(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_93(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_95(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_94(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_96(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_95(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_97(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_96(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_98(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_97(WHAT, PARAMS, __VA_ARGS__))
	' #define DIR_99(WHAT, PARAMS, OPNUM_PAIR, ...) WHAT(PARAMS, OPNUM_PAIR)EVAL(DIR_98(WHAT, PARAMS, __VA_ARGS__))


	' #define FZ_1(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)
	' #define FZ_2(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_1(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_3(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_2(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_4(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_3(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_5(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_4(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_6(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_5(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_7(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_6(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_8(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_7(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_9(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_8(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_10(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_9(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_11(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_10(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_12(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_11(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_13(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_12(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_14(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_13(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_15(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_14(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_16(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_15(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_17(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_16(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_18(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_17(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_19(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_18(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_20(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_19(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_21(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_20(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_22(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_21(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_23(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_22(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_24(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_23(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_25(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_24(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_26(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_25(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_27(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_26(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_28(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_27(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_29(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_28(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_30(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_29(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_31(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_30(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_32(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_31(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_33(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_32(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_34(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_33(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_35(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_34(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_36(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_35(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_37(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_36(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_38(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_37(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_39(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_38(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_40(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_39(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_41(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_40(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_42(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_41(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_43(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_42(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_44(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_43(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_45(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_44(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_46(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_45(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_47(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_46(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_48(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_47(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_49(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_48(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_50(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_49(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_51(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_50(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_52(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_51(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_53(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_52(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_54(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_53(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_55(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_54(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_56(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_55(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_57(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_56(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_58(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_57(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_59(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_58(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_60(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_59(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_61(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_60(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_62(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_61(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_63(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_62(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_64(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_63(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_65(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_64(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_66(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_65(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_67(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_66(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_68(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_67(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_69(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_68(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_70(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_69(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_71(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_70(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_72(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_71(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_73(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_72(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_74(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_73(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_75(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_74(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_76(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_75(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_77(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_76(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_78(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_77(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_79(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_78(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_80(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_79(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_81(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_80(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_82(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_81(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_83(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_82(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_84(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_83(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_85(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_84(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_86(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_85(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_87(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_86(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_88(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_87(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_89(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_88(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_90(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_89(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_91(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_90(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_92(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_91(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_93(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_92(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_94(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_93(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_95(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_94(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_96(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_95(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_97(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_96(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_98(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_97(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define FZ_99(WHAT, NAME, TYPE, SIGNATURE, OPNUM_PAIR, ...) WHAT(NAME, TYPE, SIGNATURE, OPNUM_PAIR)EVAL(FZ_98(WHAT, NAME, TYPE, SIGNATURE, __VA_ARGS__))

	' #define FF_1(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FF_2(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_1(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_3(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_2(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_4(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_3(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_5(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_4(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_6(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_5(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_7(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_6(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_8(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_7(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_9(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_8(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_10(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_9(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_11(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_10(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_12(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_11(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_13(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_12(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_14(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_13(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_15(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_14(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_16(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_15(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_17(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_16(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_18(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_17(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_19(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_18(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FF_20(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FF_19(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))


	' #define FFI_1(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FFI_2(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_1(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_3(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_2(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_4(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_3(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_5(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_4(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_6(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_5(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_7(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_6(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_8(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_7(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_9(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_8(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_10(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_9(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_11(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_10(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_12(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_11(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_13(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_12(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_14(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_13(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_15(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_14(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_16(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_15(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_17(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_16(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_18(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_17(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_19(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_18(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FFI_20(WHAT, TYPE, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(TYPE, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FFI_19(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))

	' #define FM_1(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FM_2(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_1(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_3(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_2(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_4(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_3(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_5(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_4(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_6(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_5(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_7(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_6(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_8(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_7(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_9(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_8(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_10(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_9(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_11(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_10(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_12(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_11(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_13(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_12(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_14(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_13(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_15(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_14(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_16(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_15(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_17(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_16(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR,__VA_ARGS__))
	' #define FM_18(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_17(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_19(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_18(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_20(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_19(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_21(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_20(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_22(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_21(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_23(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_22(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_24(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_23(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_25(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_24(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_26(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_25(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_27(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_26(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_28(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_27(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_29(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_28(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_30(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_29(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_31(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_30(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_32(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_31(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_33(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_32(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_34(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_33(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_35(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_34(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_36(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_35(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_37(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_36(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_38(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_37(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_39(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_38(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_40(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_39(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_41(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_40(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_42(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_41(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_43(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_42(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_44(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_43(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_45(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_44(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_46(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_45(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_47(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_46(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_48(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_47(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_49(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_48(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_50(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_49(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_51(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_50(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_52(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_51(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_53(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_52(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_54(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_53(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_55(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_54(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_56(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_55(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_57(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_56(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_58(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_57(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_59(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_58(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_60(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_59(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_61(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_60(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_62(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_61(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_63(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_62(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_64(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_63(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_65(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_64(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_66(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_65(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_67(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_66(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_68(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_67(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_69(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_68(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FM_70(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FM_69(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))


	' #define FX_1(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FX_2(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_1(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_3(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_2(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_4(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_3(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_5(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_4(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_6(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_5(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_7(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_6(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_8(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_7(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_9(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_8(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_10(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_9(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_11(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_10(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_12(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_11(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_13(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_12(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_14(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_13(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_15(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_14(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_16(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_15(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_17(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_16(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_18(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_17(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_19(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_18(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_20(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_19(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_21(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_20(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_22(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_21(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_23(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_22(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_24(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_23(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_25(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_24(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_26(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_25(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_27(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_26(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_28(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_27(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_29(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_28(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_30(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_29(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_31(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_30(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_32(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_31(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_33(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_32(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_34(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_33(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_35(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_34(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_36(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_35(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_37(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_36(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_38(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_37(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_39(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_38(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_40(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_39(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_41(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_40(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_42(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_41(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_43(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_42(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_44(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_43(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_45(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_44(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_46(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_45(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_47(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_46(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_48(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_47(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_49(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_48(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_50(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_49(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_51(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_50(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_52(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_51(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_53(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_52(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_54(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_53(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_55(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_54(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_56(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_55(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_57(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_56(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_58(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_57(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_59(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_58(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_60(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_59(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_61(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_60(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_62(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_61(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_63(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_62(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_64(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_63(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_65(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_64(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_66(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_65(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_67(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_66(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_68(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_67(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_69(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_68(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FX_70(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, SIG, OPCLASS, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FX_69(WHAT, FN, SIG, OPCLASS, OPNUM_PAIR, __VA_ARGS__))


	' #define FK_1(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FK_2(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_1(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_3(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_2(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_4(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_3(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_5(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_4(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_6(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_5(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_7(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_6(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_8(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_7(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_9(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_8(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_10(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_9(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_11(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_10(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_12(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_11(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_13(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_12(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_14(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_13(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_15(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_14(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_16(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_15(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_17(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_16(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_18(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_17(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_19(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_18(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_20(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_19(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_21(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_20(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_22(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_21(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_23(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_22(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_24(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_23(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_25(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_24(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_26(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_25(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_27(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_26(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_28(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_27(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_29(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_28(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_30(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_29(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_31(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_30(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_32(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_31(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_33(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_32(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_34(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_33(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_35(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_34(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_36(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_35(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_37(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_36(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_38(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_37(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_39(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_38(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_40(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_39(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_41(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_40(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_42(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_41(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_43(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_42(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_44(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_43(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_45(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_44(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_46(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_45(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_47(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_46(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_48(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_47(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_49(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_48(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_50(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_49(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_51(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_50(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_52(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_51(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_53(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_52(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_54(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_53(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_55(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_54(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_56(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_55(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_57(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_56(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_58(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_57(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_59(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_58(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_60(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_59(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_61(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_60(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_62(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_61(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_63(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_62(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_64(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_63(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_65(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_64(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_66(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_65(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_67(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_66(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_68(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_67(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_69(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_68(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FK_70(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FK_69(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))



	' #define FI_1(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)
	' #define FI_2(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_1(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_3(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_2(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_4(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_3(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_5(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_4(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_6(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_5(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_7(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_6(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_8(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_7(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_9(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_8(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_10(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_9(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_11(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_10(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_12(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_11(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_13(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_12(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_14(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_13(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_15(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_14(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_16(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_15(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_17(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_16(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_18(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_17(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_19(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_18(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_20(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_19(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_21(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_20(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_22(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_21(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_23(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_22(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_24(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_23(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_25(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_24(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_26(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_25(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_27(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_26(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_28(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_27(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_29(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_28(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_30(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_29(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_31(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_30(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_32(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_31(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_33(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_32(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_34(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_33(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_35(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_34(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_36(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_35(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_37(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_36(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_38(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_37(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_39(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_38(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_40(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_39(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_41(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_40(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_42(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_41(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_43(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_42(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_44(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_43(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_45(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_44(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_46(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_45(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_47(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_46(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_48(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_47(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_49(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_48(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_50(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_49(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_51(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_50(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_52(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_51(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_53(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_52(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_54(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_53(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_55(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_54(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_56(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_55(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_57(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_56(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_58(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_57(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_59(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_58(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_60(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_59(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_61(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_60(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_62(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_61(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_63(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_62(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_64(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_63(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_65(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_64(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_66(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_65(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_67(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_66(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_68(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_67(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_69(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_68(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FI_70(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B, ...) WHAT(FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, OPNUM_PAIR_B)EVAL(FI_69(WHAT, FN, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))


	' #define FS_1(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)
	' #define FS_2(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_1(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_3(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_2(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_4(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_3(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_5(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_4(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_6(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_5(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_7(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_6(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_8(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_7(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_9(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_8(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_10(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_9(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_11(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_10(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_12(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_11(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_13(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_12(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_14(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_13(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_15(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_14(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_16(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_15(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_17(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_16(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_18(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_17(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_19(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_18(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_20(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_19(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_21(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_20(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_22(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_21(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_23(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_22(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_24(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_23(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_25(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_24(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_26(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_25(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_27(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_26(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_28(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_27(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_29(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_28(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_30(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_29(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_31(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_30(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_32(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_31(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_33(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_32(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_34(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_33(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_35(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_34(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_36(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_35(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_37(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_36(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_38(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_37(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_39(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_38(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_40(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_39(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_41(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_40(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_42(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_41(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_43(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_42(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_44(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_43(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_45(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_44(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_46(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_45(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_47(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_46(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_48(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_47(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_49(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_48(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_50(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_49(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_51(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_50(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_52(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_51(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_53(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_52(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_54(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_53(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_55(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_54(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_56(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_55(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_57(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_56(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_58(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_57(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_59(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_58(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_60(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_59(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_61(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_60(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_62(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_61(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_63(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_62(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_64(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_63(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_65(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_64(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_66(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_65(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_67(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_66(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_68(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_67(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_69(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_68(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_70(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_69(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_71(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_70(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_72(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_71(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_73(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_72(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_74(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_73(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_75(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_74(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_76(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_75(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_77(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_76(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_78(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_77(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_79(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_78(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_80(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_79(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_81(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_80(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_82(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_81(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_83(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_82(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_84(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_83(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_85(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_84(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_86(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_85(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_87(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_86(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_88(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_87(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_89(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_88(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_90(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_89(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_91(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_90(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_92(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_91(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_93(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_92(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_94(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_93(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_95(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_94(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_96(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_95(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_97(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_96(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_98(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_97(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FS_99(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR, ...) WHAT(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR)EVAL(FS_98(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))

	'////////////////////////////
	' #ifdef __clang__
	' #define _EXPAND_META_CALL(FN, SIG, OPCLASS, NUM_A, TYPE_A, NUM_B, TYPE_B) if(opNumA == NUM_A && opNumB == NUM_B){ MIX4(FN,NUM_A,NUM_B,OPCLASS) LAUNCH(256, 512, 1024, *stream) SIG; };
	' #elif _MSC_VER
	' #define _EXPAND_META_CALL(FN, SIG, OPCLASS, NUM_A, TYPE_A, NUM_B, TYPE_B) if(opNumA == NUM_A && opNumB == NUM_B){ MIX4(FN,NUM_A,NUM_B,OPCLASS) LAUNCH(256, 512, 1024, *stream) SIG; };
	' #elif __GNUC__
	' #define _EXPAND_META_CALL(FN, SIG, OPCLASS, NUM_A, TYPE_A, NUM_B, TYPE_B) else if(opNumA == NUM_A && opNumB == NUM_B){ MIX4(FN,NUM_A,NUM_B,OPCLASS) LAUNCH(256, 512, 2048, *stream) SIG; }
	' #elif __CUDACC__
	' #endif
	' #define _EXPAND_OP_SIMPLE(NAME, TYPE, PARAMZ, NUM_A, TYPE_A) case NUM_A: {MIX3(NAME, NUM_A, TYPE) LAUNCH(launchDims.x, launchDims.y, launchDims.z, *stream) PARAMZ;} break;

	' #define _EXPAND_OP_CALL_1(NAME, TYPE, PARAMZ, NUM_A, TYPE_A) NAME<TYPE_A<TYPE>>PARAMZ;
	' #define _EXPAND_OP_DIRECT(PARAMZ, NUM_A, TYPE_A)  case NUM_A: { z = TYPE_A<T>::op PARAMZ; break; }
	' #define _EXPAND_OP_CALL_T(TYPE, NUM_A, TYPE_A) OpTracker::getInstance().storeOperation(TYPE, #TYPE_A, NUM_A);

	' #define _EXPAND_FACTORY_CALL(TYPE, LAYER_ID, LAYER_NAME, ACTIVATION_ID, ACTIVATION_NAME) if (activationNum == ACTIVATION_ID && layerNum == LAYER_ID) { return new LAYER_NAME<TYPE, ACTIVATION_NAME<TYPE>>(); };

	' #define _EXPAND_PACKED_CALL_1(NAME, TYPE, PARAMZ, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_CALL_1(NAME, TYPE, PARAMZ, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_DIRECT(PARAMZ, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_DIRECT(PARAMZ, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_CALL_T(TYPE, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_CALL_T(TYPE, UNPAREN(OPNUM_PAIR)))

	' #define _EXPAND_KERNEL_CALL(NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, NUM_A, TYPE_A, NUM_B, TYPE_B) extern "C" __global__ void ARGMIX4(NAME, NUM_A, NUM_B, TYPE)INPUTZ {KERNEL<TYPE, OPCLASS<TYPE, TYPE_A<TYPE>, TYPE_B<TYPE>>>PARAMZ ;};
	' #define _EXPAND_KERNEL_SIMPLE(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, NUM_A, TYPE_A) extern "C" __global__ void ARGMIX3(NAME, NUM_A, TYPE)INPUTZ {KERNEL<TYPE, TYPE_A<TYPE>>PARAMZ ;};
	' #define _EXPAND_PACKED_SIMPLE(NAME, TYPE, PARAMZ, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _OP_SIMPLE(NAME, TYPE, PARAMZ, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_KERNEL_SIMPLE(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, OPNUM_PAIR) EVALUATING_PASTE(_EXPAND, _KERNEL_SIMPLE (NAME, KERNEL, TYPE, INPUTZ, PARAMZ, UNPAREN(OPNUM_PAIR)))
	' #define _EXPAND_PACKED_KERNEL_CALL(NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR_A, OPNUM_PAIR_B) EVALUATING_PASTE(_EXPAND, _KERNEL_CALL (NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, UNPAREN(OPNUM_PAIR_B), UNPAREN(OPNUM_PAIR_A)))
	' #define _EXPAND_PACKED_META_CALL(FN, SIG, OPCLASS, OPNUM_PAIR_A, OPNUM_PAIR_B) EVALUATING_PASTE(_EXPAND, _META_CALL (FN, SIG, OPCLASS, UNPAREN(OPNUM_PAIR_B), UNPAREN(OPNUM_PAIR_A) ))

	' #define _EXPAND_PACKED_FACTORY_CALL(TYPE, OPNUM_PAIR_A, OPNUM_PAIR_B) EVALUATING_PASTE(_EXPAND, _FACTORY_CALL (TYPE, UNPAREN(OPNUM_PAIR_B), UNPAREN(OPNUM_PAIR_A)))
	'////////////////////////////

	' #define GET_MACROS_1(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME,...) NAME
	' #define GET_MACROS_D(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME,...) NAME
	' #define GET_MACROS_T(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME,...) NAME

	' #define  GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME,...) NAME
	' #define GET_MACROS(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, NAME,...) NAME
	' #define GET_MACROX(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, NAME,...) NAME
	' #define GET_MACROE(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, NAME,...) NAME
	' #define GET_MACROK(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, NAME,...) NAME
	' #define GET_MACROI(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, NAME,...) NAME
	' #define GET_MACROF(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, NAME,...) NAME
	' #define FOR_EACH(WHAT, NAME, SIGNATURE, ...) EVAL(GET_MACRO(__VA_ARGS__,  FE_99, FE_98, FE_97, FE_96, FE_95, FE_94, FE_93, FE_92, FE_91, FE_90, FE_89, FE_88, FE_87, FE_86, FE_85, FE_84, FE_83, FE_82, FE_81, FE_80, FE_79, FE_78, FE_77, FE_76, FE_75, FE_74, FE_73, FE_72, FE_71, FE_70, FE_69, FE_68, FE_67, FE_66, FE_65, FE_64, FE_63, FE_62, FE_61, FE_60, FE_59, FE_58, FE_57, FE_56, FE_55, FE_54, FE_53, FE_52, FE_51, FE_50, FE_49, FE_48, FE_47, FE_46, FE_45, FE_44, FE_43, FE_42, FE_41, FE_40, FE_39, FE_38, FE_37, FE_36, FE_35, FE_34, FE_33, FE_32, FE_31, FE_30, FE_29, FE_28, FE_27, FE_26, FE_25, FE_24, FE_23, FE_22, FE_21, FE_20, FE_19, FE_18, FE_17, FE_16, FE_15, FE_14, FE_13, FE_12, FE_11, FE_10, FE_9, FE_8, FE_7, FE_6, FE_5, FE_4, FE_3, FE_2, FE_1)(WHAT, NAME, SIGNATURE, __VA_ARGS__))

	' #define FOR_EACH_M(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR, ...) EXPAND(GET_MACROX(__VA_ARGS__, FM_70, FM_69, FM_68, FM_67, FM_66, FM_65, FM_64, FM_63, FM_62, FM_61, FM_60, FM_59, FM_58, FM_57, FM_56, FM_55, FM_54, FM_53, FM_52, FM_51, FM_50, FM_49, FM_48, FM_47, FM_46, FM_45, FM_44, FM_43, FM_42, FM_41, FM_40, FM_39, FM_38, FM_37, FM_36, FM_35, FM_34, FM_33, FM_32, FM_31, FM_30, FM_29, FM_28, FM_27, FM_26, FM_25, FM_24, FM_23, FM_22, FM_21, FM_20, FM_19, FM_18, FM_17, FM_16, FM_15, FM_14, FM_13, FM_12, FM_11, FM_10, FM_9, FM_8, FM_7, FM_6, FM_5, FM_4, FM_3, FM_2, FM_1)(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR, __VA_ARGS__))
	' #define FOR_EACH_X(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR, ...) EXPAND(GET_MACROE(__VA_ARGS__, FX_70, FX_69, FX_68, FX_67, FX_66, FX_65, FX_64, FX_63, FX_62, FX_61, FX_60, FX_59, FX_58, FX_57, FX_56, FX_55, FX_54, FX_53, FX_52, FX_51, FX_50, FX_49, FX_48, FX_47, FX_46, FX_45, FX_44, FX_43, FX_42, FX_41, FX_40, FX_39, FX_38, FX_37, FX_36, FX_35, FX_34, FX_33, FX_32, FX_31, FX_30, FX_29, FX_28, FX_27, FX_26, FX_25, FX_24, FX_23, FX_22, FX_21, FX_20, FX_19, FX_18, FX_17, FX_16, FX_15, FX_14, FX_13, FX_12, FX_11, FX_10, FX_9, FX_8, FX_7, FX_6, FX_5, FX_4, FX_3, FX_2, FX_1)(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR, __VA_ARGS__))

	' #define FOR_EACH_CALL_1(WHAT, NAME, TYPE, PARAMZ, ...) EXPAND(GET_MACROS_1(__VA_ARGS__,  CL1_99, CL1_98, CL1_97, CL1_96, CL1_95, CL1_94, CL1_93, CL1_92, CL1_91, CL1_90, CL1_89, CL1_88, CL1_87, CL1_86, CL1_85, CL1_84, CL1_83, CL1_82, CL1_81, CL1_80, CL1_79, CL1_78, CL1_77, CL1_76, CL1_75, CL1_74, CL1_73, CL1_72, CL1_71, CL1_70, CL1_69, CL1_68, CL1_67, CL1_66, CL1_65, CL1_64, CL1_63, CL1_62, CL1_61, CL1_60, CL1_59, CL1_58, CL1_57, CL1_56, CL1_55, CL1_54, CL1_53, CL1_52, CL1_51, CL1_50, CL1_49, CL1_48, CL1_47, CL1_46, CL1_45, CL1_44, CL1_43, CL1_42, CL1_41, CL1_40, CL1_39, CL1_38, CL1_37, CL1_36, CL1_35, CL1_34, CL1_33, CL1_32, CL1_31, CL1_30, CL1_29, CL1_28, CL1_27, CL1_26, CL1_25, CL1_24, CL1_23, CL1_22, CL1_21, CL1_20, CL1_19, CL1_18, CL1_17, CL1_16, CL1_15, CL1_14, CL1_13, CL1_12, CL1_11, CL1_10, CL1_9, CL1_8, CL1_7, CL1_6, CL1_5, CL1_4, CL1_3, CL1_2, CL1_1)(WHAT, NAME, TYPE, PARAMZ, __VA_ARGS__))
	' #define FOR_EACH_DIRECT(WHAT, PARAMZ, ...) EXPAND(GET_MACROS_D(__VA_ARGS__,  DIR_99, DIR_98, DIR_97, DIR_96, DIR_95, DIR_94, DIR_93, DIR_92, DIR_91, DIR_90, DIR_89, DIR_88, DIR_87, DIR_86, DIR_85, DIR_84, DIR_83, DIR_82, DIR_81, DIR_80, DIR_79, DIR_78, DIR_77, DIR_76, DIR_75, DIR_74, DIR_73, DIR_72, DIR_71, DIR_70, DIR_69, DIR_68, DIR_67, DIR_66, DIR_65, DIR_64, DIR_63, DIR_62, DIR_61, DIR_60, DIR_59, DIR_58, DIR_57, DIR_56, DIR_55, DIR_54, DIR_53, DIR_52, DIR_51, DIR_50, DIR_49, DIR_48, DIR_47, DIR_46, DIR_45, DIR_44, DIR_43, DIR_42, DIR_41, DIR_40, DIR_39, DIR_38, DIR_37, DIR_36, DIR_35, DIR_34, DIR_33, DIR_32, DIR_31, DIR_30, DIR_29, DIR_28, DIR_27, DIR_26, DIR_25, DIR_24, DIR_23, DIR_22, DIR_21, DIR_20, DIR_19, DIR_18, DIR_17, DIR_16, DIR_15, DIR_14, DIR_13, DIR_12, DIR_11, DIR_10, DIR_9, DIR_8, DIR_7, DIR_6, DIR_5, DIR_4, DIR_3, DIR_2, DIR_1)(WHAT, PARAMZ, __VA_ARGS__))
	' #define FOR_EACH_TRACKER(WHAT, TYPE, ...) EXPAND(GET_MACROS_T(__VA_ARGS__,  TR_99, TR_98, TR_97, TR_96, TR_95, TR_94, TR_93, TR_92, TR_91, TR_90, TR_89, TR_88, TR_87, TR_86, TR_85, TR_84, TR_83, TR_82, TR_81, TR_80, TR_79, TR_78, TR_77, TR_76, TR_75, TR_74, TR_73, TR_72, TR_71, TR_70, TR_69, TR_68, TR_67, TR_66, TR_65, TR_64, TR_63, TR_62, TR_61, TR_60, TR_59, TR_58, TR_57, TR_56, TR_55, TR_54, TR_53, TR_52, TR_51, TR_50, TR_49, TR_48, TR_47, TR_46, TR_45, TR_44, TR_43, TR_42, TR_41, TR_40, TR_39, TR_38, TR_37, TR_36, TR_35, TR_34, TR_33, TR_32, TR_31, TR_30, TR_29, TR_28, TR_27, TR_26, TR_25, TR_24, TR_23, TR_22, TR_21, TR_20, TR_19, TR_18, TR_17, TR_16, TR_15, TR_14, TR_13, TR_12, TR_11, TR_10, TR_9, TR_8, TR_7, TR_6, TR_5, TR_4, TR_3, TR_2, TR_1)(WHAT, TYPE, __VA_ARGS__))

	' #define FOR_EACH_Z(WHAT, NAME, TYPE, PARAMZ, ...) EXPAND(GET_MACROS(__VA_ARGS__,  FZ_99, FZ_98, FZ_97, FZ_96, FZ_95, FZ_94, FZ_93, FZ_92, FZ_91, FZ_90, FZ_89, FZ_88, FZ_87, FZ_86, FZ_85, FZ_84, FZ_83, FZ_82, FZ_81, FZ_80, FZ_79, FZ_78, FZ_77, FZ_76, FZ_75, FZ_74, FZ_73, FZ_72, FZ_71, FZ_70, FZ_69, FZ_68, FZ_67, FZ_66, FZ_65, FZ_64, FZ_63, FZ_62, FZ_61, FZ_60, FZ_59, FZ_58, FZ_57, FZ_56, FZ_55, FZ_54, FZ_53, FZ_52, FZ_51, FZ_50, FZ_49, FZ_48, FZ_47, FZ_46, FZ_45, FZ_44, FZ_43, FZ_42, FZ_41, FZ_40, FZ_39, FZ_38, FZ_37, FZ_36, FZ_35, FZ_34, FZ_33, FZ_32, FZ_31, FZ_30, FZ_29, FZ_28, FZ_27, FZ_26, FZ_25, FZ_24, FZ_23, FZ_22, FZ_21, FZ_20, FZ_19, FZ_18, FZ_17, FZ_16, FZ_15, FZ_14, FZ_13, FZ_12, FZ_11, FZ_10, FZ_9, FZ_8, FZ_7, FZ_6, FZ_5, FZ_4, FZ_3, FZ_2, FZ_1)(WHAT, NAME, TYPE, PARAMZ, __VA_ARGS__))
	' #define FOR_EACH_S(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, ...) EXPAND(GET_MACROS(__VA_ARGS__,  FS_99, FS_98, FS_97, FS_96, FS_95, FS_94, FS_93, FS_92, FS_91, FS_90, FS_89, FS_88, FS_87, FS_86, FS_85, FS_84, FS_83, FS_82, FS_81, FS_80, FS_79, FS_78, FS_77, FS_76, FS_75, FS_74, FS_73, FS_72, FS_71, FS_70, FS_69, FS_68, FS_67, FS_66, FS_65, FS_64, FS_63, FS_62, FS_61, FS_60, FS_59, FS_58, FS_57, FS_56, FS_55, FS_54, FS_53, FS_52, FS_51, FS_50, FS_49, FS_48, FS_47, FS_46, FS_45, FS_44, FS_43, FS_42, FS_41, FS_40, FS_39, FS_38, FS_37, FS_36, FS_35, FS_34, FS_33, FS_32, FS_31, FS_30, FS_29, FS_28, FS_27, FS_26, FS_25, FS_24, FS_23, FS_22, FS_21, FS_20, FS_19, FS_18, FS_17, FS_16, FS_15, FS_14, FS_13, FS_12, FS_11, FS_10, FS_9, FS_8, FS_7, FS_6, FS_5, FS_4, FS_3, FS_2, FS_1)(WHAT, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__))
	' #define FOR_EACH_I(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, ...) EXPAND(GET_MACROI(__VA_ARGS__, FI_70, FI_69, FI_68, FI_67, FI_66, FI_65, FI_64, FI_63, FI_62, FI_61, FI_60, FI_59, FI_58, FI_57, FI_56, FI_55, FI_54, FI_53, FI_52, FI_51, FI_50, FI_49, FI_48, FI_47, FI_46, FI_45, FI_44, FI_43, FI_42, FI_41, FI_40, FI_39, FI_38, FI_37, FI_36, FI_35, FI_34, FI_33, FI_32, FI_31, FI_30, FI_29, FI_28, FI_27, FI_26, FI_25, FI_24, FI_23, FI_22, FI_21, FI_20, FI_19, FI_18, FI_17, FI_16, FI_15, FI_14, FI_13, FI_12, FI_11, FI_10, FI_9, FI_8, FI_7, FI_6, FI_5, FI_4, FI_3, FI_2, FI_1)(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))
	' #define FOR_EACH_K(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, ...) EXPAND(GET_MACROK(__VA_ARGS__, FK_70, FK_69, FK_68, FK_67, FK_66, FK_65, FK_64, FK_63, FK_62, FK_61, FK_60, FK_59, FK_58, FK_57, FK_56, FK_55, FK_54, FK_53, FK_52, FK_51, FK_50, FK_49, FK_48, FK_47, FK_46, FK_45, FK_44, FK_43, FK_42, FK_41, FK_40, FK_39, FK_38, FK_37, FK_36, FK_35, FK_34, FK_33, FK_32, FK_31, FK_30, FK_29, FK_28, FK_27, FK_26, FK_25, FK_24, FK_23, FK_22, FK_21, FK_20, FK_19, FK_18, FK_17, FK_16, FK_15, FK_14, FK_13, FK_12, FK_11, FK_10, FK_9, FK_8, FK_7, FK_6, FK_5, FK_4, FK_3, FK_2, FK_1)(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR, __VA_ARGS__))

	' #define FOR_EACH_F(WHAT, TYPE, OPNUM_PAIR, ...) EXPAND(GET_MACROF(__VA_ARGS__, FF_20, FF_19, FF_18, FF_17, FF_16, FF_15, FF_14, FF_13, FF_12, FF_11, FF_10, FF_9, FF_8, FF_7, FF_6, FF_5, FF_4, FF_3, FF_2, FF_1)(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))
	' #define FOR_EACH_FI(WHAT, TYPE, OPNUM_PAIR, ...) EXPAND(GET_MACROF(__VA_ARGS__, FFI_20, FFI_19, FFI_18, FFI_17, FFI_16, FFI_15, FFI_14, FFI_13, FFI_12, FFI_11, FFI_10, FFI_9, FFI_8, FFI_7, FFI_6, FFI_5, FFI_4, FFI_3, FFI_2, FFI_1)(WHAT, TYPE, OPNUM_PAIR, __VA_ARGS__))


	' #define _EXEC_OPS(WHAT, NAME, SIGNATURE, ...) EVAL(FOR_EACH(WHAT, NAME, SIGNATURE, __VA_ARGS__))
	' #define _EXEC_OP_SIMPLE(NAME, TYPE, SIGNATURE, ...) EVAL(FOR_EACH_Z(THETA, NAME, TYPE, SIGNATURE, __VA_ARGS__))

	' #define _EXEC_BUILDER_1(NAME, TYPE, SIGNATURE, ...) EVAL(FOR_EACH_CALL_1(CALL_1, NAME, TYPE, SIGNATURE, __VA_ARGS__))
	' #define _EXEC_OP_DIRECT(SIGNATURE, ...) EVAL(FOR_EACH_DIRECT(DIRECT, SIGNATURE, __VA_ARGS__))
	' #define _EXEC_TRACKER(TYPE, ...) EVAL(FOR_EACH_TRACKER(CALL_T, TYPE, __VA_ARGS__))

	' #define _EXEC_META_X(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR_A, ...) EVAL(FOR_EACH_X(WHAT, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR_A, __VA_ARGS__))
	' #define _EXEC_META_M(WHAT, NAME, SIGNATURE, OPCLASS, LIST_A, ...) EVAL(FOR_EACH_M(ALPHA, NAME, SIGNATURE, OPCLASS, OPS_A(LIST_A), __VA_ARGS__))
	' #define _EXEC_FACTORY(WHAT, TYPE, LIST_A, ...) EVAL(FOR_EACH_F(PHI, TYPE, OPS_A(LIST_A), __VA_ARGS__))
	' #define _EXEC_FACTORY_INTERNAL(WHAT, TYPE, ACTIVATION, ...) EVAL(FOR_EACH_FI(WHAT, TYPE, ACTIVATION, __VA_ARGS__))

	' #define _EXEC_KERNEL_F(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, ...) EVAL(FOR_EACH_S(GAMMA, NAME, KERNEL, TYPE, INPUTZ, PARAMZ, __VA_ARGS__ ))
	' #define _EXEC_KERNEL_M(NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, LIST_A, ...) EVAL(FOR_EACH_K(BETA, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPS_A(LIST_A), __VA_ARGS__ ))
	' #define _EXEC_KERNEL_X(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ,  OPNUM_PAIR_A, ...) EVAL(FOR_EACH_I(WHAT, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR_A, __VA_ARGS__))
	'_EXPAND_PACKED_OP_CALL
	' #define DISPATCH_BY_OPNUM_T(NAME, SIGNATURE, ...) switch(opNum) { EVAL(_EXEC_OPS(_EXPAND_PACKED_OP_CALL, NAME, (SIGNATURE), __VA_ARGS__)) default: { printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); }}
	' #define DISPATCH_BY_OPNUM_TT(NAME, SIGNATURE, ...) switch(opNum) { EVAL(_EXEC_OPS(_EXPAND_PACKED_OP_CALL_TT, NAME, (SIGNATURE), __VA_ARGS__)) default: { printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); }}
	' #define DISPATCH_BY_OPNUM_TTT(NAME, SIGNATURE, ...) switch(opNum) { EVAL(_EXEC_OPS(_EXPAND_PACKED_OP_CALL_TTT, NAME, (SIGNATURE), __VA_ARGS__)) default: { printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); }}

	' #ifdef __clang__
	' #define DISPATCH_METAOP(NAME, SIGNATURE, OPCLASS, LIST_A, LIST_B) EVAL(_EXEC_META_M(RANDOMWHAT, NAME, (SIGNATURE), OPCLASS, (LIST_A), LIST_B))
	' #elif _MSC_VER
	' #define DISPATCH_METAOP(NAME, SIGNATURE, OPCLASS, LIST_A, LIST_B) EVAL(_EXEC_META_M(RANDOMWHAT, NAME, (SIGNATURE), OPCLASS, (LIST_A), LIST_B))
	' #elif __GNUC__
	' #define DISPATCH_METAOP(NAME, SIGNATURE, OPCLASS, LIST_A, LIST_B) if(false){} EVAL(_EXEC_META_M(RANDOMWHAT, NAME, (SIGNATURE), OPCLASS, (LIST_A), LIST_B)) else{ printf("[ERROR] Unknown opNum=%d on %s:%d", opNumA, __FILE__, __LINE__); }
	' #elif __CUDACC__
	' #endif

	' #define BUILD_LAYERS_FACTORY(TYPE, LIST_A, LIST_B) EVAL(_EXEC_FACTORY(RANDOMWHAT, TYPE, (LIST_A), LIST_B))

	' #define DISPATCH_SIMPLE(NAME, TYPE, SIGNATURE, LIST_A) switch(opNum) { EVAL(_EXEC_OP_SIMPLE(NAME, TYPE, (SIGNATURE), LIST_A)) default: { printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); }}

	' #define DISPATCH_KERNEL_SIMPLE(NAME, KERNEL, TYPE, INPUTZ, PARAMZ, LIST_A) EVAL(_EXEC_KERNEL_F(NAME, KERNEL, TYPE, (INPUTZ), (PARAMZ), LIST_A))
	' #define DISPATCH_KERNEL_META(NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, LIST_A, LIST_B ) EVAL(_EXEC_KERNEL_M(NAME, KERNEL, TYPE, OPCLASS, (INPUTZ), (PARAMZ), (LIST_A), LIST_B))
	' #define DISPATCH_INTERNAL(NAME, SIGNATURE, OPCLASS, OPNUM_PAIR_B, ...) EXPAND(_EXEC_META_X(_EXPAND_PACKED_META_CALL, NAME, SIGNATURE, OPCLASS, OPNUM_PAIR_B, __VA_ARGS__))

	' #define DISPATCH_FACTORY(TYPE, ACTIVATION, ...) EXPAND(_EXEC_FACTORY_INTERNAL(_EXPAND_PACKED_FACTORY_CALL, TYPE, ACTIVATION, __VA_ARGS__))

	' #define DISPATCH_KERNEL_INTERNAL(NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR_B, ...) EXPAND(_EXEC_KERNEL_X(_EXPAND_PACKED_KERNEL_CALL, NAME, KERNEL, TYPE, OPCLASS, INPUTZ, PARAMZ, OPNUM_PAIR_B, __VA_ARGS__))

	' #define BUILD_CALL_1(NAME, TYPE, SIGNATURE, OPS) EVAL(_EXEC_BUILDER_1(NAME, TYPE, SIGNATURE, OPS))
	' #define BUILD_TRACKER(TYPE, OPS) EVAL(_EXEC_TRACKER(TYPE, OPS))

	' #define EXECUTE_NOE(SIGNATURE, LIST_A) switch(opNum) {EVAL(_EXEC_OP_DIRECT(SIGNATURE, LIST_A)) default: { printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); }};

	' #define RETURNING_DISPATCH_BY_OPNUM_T(NAME, SIGNATURE, ...) if(false){} EVAL(_EXEC_OPS(_EXPAND_RETURNING_PACKED_OP_CALL, NAME, (SIGNATURE), __VA_ARGS__)) else{ printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); return 0; }
	' #define RETURNING_DISPATCH_BY_OPNUM_TT(NAME, SIGNATURE, ...) if(false){} EVAL(_EXEC_OPS(_EXPAND_RETURNING_PACKED_OP_CALL_TT, NAME, (SIGNATURE), __VA_ARGS__)) else{ printf("[ERROR] Unknown opNum=%d on %s:%d", opNum, __FILE__, __LINE__); return 0; }

	' #define PARAMS(...) __VA_ARGS__
	' #define INPUT(...) __VA_ARGS__
	' #define OPS_A(...) __VA_ARGS__
	' #define OPS_B(...) __VA_ARGS__
	' #define OPS_X(...) __VA_ARGS__
	' #define ALPHA(A, B, C, D, E) EXPAND(DISPATCH_INTERNAL(A, B, C, E, UNPAREN(D)))
	' #define BETA(A, B, C, D, E, F, G, H) EXPAND(DISPATCH_KERNEL_INTERNAL(A, B, C, D, E, F, H, UNPAREN(G)))
	' #define GAMMA(A, B, C, D, E, F) EXPAND(_EXPAND_PACKED_KERNEL_SIMPLE(A, B, C, D, E, F))
	' #define THETA(A, B, C, D) EXPAND(_EXPAND_PACKED_SIMPLE(A, B, C, D))
	' #define PHI(A, B, C) EXPAND(DISPATCH_FACTORY(A, C, UNPAREN(B)))

	' #define CALL_1(A, B, C, D) EXPAND(_EXPAND_PACKED_CALL_1(A, B, C, D))
	' #define CALL_T(A, B) EXPAND(_EXPAND_PACKED_CALL_T(A, B))
	' #define DIRECT(A, B) EXPAND(_EXPAND_PACKED_DIRECT(A, B))




	''' <summary>
	''' graph definitions </summary>
	' #define REQUIRE_OK(A)  if (sd::ops::resultHelper( (A), #A, __FILE__, __LINE__ ) != 0) return ND4J_STATUS_VALIDATION;
	' #define REQUIRE_TRUE(COND, ...) if (!(COND)) { if (sd::ops::conditionHelper(__FILE__, __LINE__, COND, __VA_ARGS__) != 0) throw std::invalid_argument("Op validation failed");};

	' #define DECLARE_ENTRY(NAME, ...)           template struct ND4J_EXPORT __registratorFloat<NAME<float>>;
	'                                       template struct ND4J_EXPORT __registratorHalf<NAME<float16>>;
	'                                       template struct ND4J_EXPORT __registratorDouble<NAME<double>>;
	'                                       template struct ND4J_EXPORT __registratorSynonymHalf<NAME<float16>>;
	'                                       template struct ND4J_EXPORT __registratorSynonymDouble<NAME<double>>;
	'                                       template struct ND4J_EXPORT __registratorSynonymFloat<NAME<float>>;


	' #if defined(_MSC_VER) || defined(_WIN64) || defined(_WIN32) || defined(__CLION_IDE__) || defined(__VSCODE__)
	' #define NOT_EXCLUDED(NAME) 1>0
	' #else
	' for now we don't want minifier mechanics working
	'#define NOT_EXCLUDED(NAME) defined(SD_ALL_OPS) || defined(NAME)
	' #define NOT_EXCLUDED(NAME) 1>0
	' #endif

	' #ifdef __JAVACPP_HACK__
	' #define REGISTER_H(NAME)
	' #elif defined(SD_ALL_OPS)
	' #else
	' #define REGISTER_H(NAME)  template <typename OpName>
	'                         struct __registrator_##NAME {
	'                             __registrator_##NAME() {
	'                                 OpName *ptr = new OpName();
	'                                 OpRegistrator::getInstance().registerOperation(ptr);
	'                             }
	'                         };
	'                         static sd::ops::__registrator_##NAME<NAME> zzz_register_opd_##NAME;
	' #endif

	' #ifdef __JAVACPP_HACK__
	' #define REGISTER_C(NAME)
	' #elif defined(SD_ALL_OPS)
	' #else
	' #define REGISTER_C(NAME)
	' #endif

	' #define DECLARE_OP(NAME, NIN, NOUT, INPLACEABLE)   class ND4J_EXPORT NAME: public sd::ops::DeclarableOp {
	'                                                 public:
	'                                                     NAME();
	'                                                     sd::ShapeList* calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block);
	'                                                 protected:
	'                                                     void registerTypes();
	'                                                     Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                                 };
	'                                                 REGISTER_H(NAME)

	' #define DECLARE_BOOLEAN_OP(NAME, NIN, SCALAR)   class ND4J_EXPORT NAME: public sd::ops::BooleanOp {
	'                                                 public:
	'                                                     NAME();
	'                                                 protected:
	'                                                     void registerTypes();
	'                                                     Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                                 };
	'                                                 REGISTER_H(NAME)

	' #define BOOLEAN_OP_IMPL(NAME, NIN, SCALAR)   NAME::NAME() : sd::ops::BooleanOp(#NAME, NIN, SCALAR) { };
	'                                                 REGISTER_C(NAME)
	'                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)

	' #define DECLARE_LIST_OP(NAME, NIN, NOUT, TARGS, IARGS)      class ND4J_EXPORT  NAME: public sd::ops::DeclarableListOp {
	'                                                             public:
	'                                                                 NAME();
	'                                                             protected:
	'                                                                 Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                                             };
	'                                                             REGISTER_H(NAME)

	' #define LIST_OP_IMPL(NAME, NIN, NOUT, TARGS, IARGS)         NAME::NAME() : sd::ops::DeclarableListOp(NIN, NOUT, #NAME, TARGS, IARGS) { };
	'                                                             REGISTER_C(NAME)
	'                                                             Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)

	' #define DECLARE_LOGIC_OP(NAME)      class ND4J_EXPORT NAME: public sd::ops::LogicOp {
	'                                     public:
	'                                         NAME();
	'                                     protected:
	'                                         Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                     };
	'                                     REGISTER_H(NAME)

	' #define LOGIC_OP_IMPL(NAME)     NAME::NAME() : sd::ops::LogicOp(#NAME) { };
	'                                 REGISTER_C(NAME)
	'                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block) { return sd::ops::LogicOp::validateAndExecute(block); };



	' #define OP_IMPL(NAME, NIN, NOUT, INPLACEABLE)   NAME::NAME() : sd::ops::DeclarableOp(NIN, NOUT, #NAME, INPLACEABLE) { };
	'                                                 REGISTER_C(NAME)
	'                                                 sd::ShapeList* sd::ops::NAME::calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block) {
	'                                                     auto shapeList = SHAPELIST();
	'                                                     auto opLimit = this->getOpDescriptor()->getNumberOfOutputs() < 1 ? block.width() : this->getOpDescriptor()->getNumberOfOutputs();
	'                                                     for (int e = 0; e < opLimit; e++) {
	'                                                         auto newshape = ConstantShapeHelper::getInstance().createShapeInfo(ArrayOptions::dataType(inputShape->at(e)), shape::order(inputShape->at(e)), shape::rank(inputShape->at(e)), shape::shapeOf(inputShape->at(e)));
	'                                                         shapeList->push_back(newshape);
	'                                                     }
	'                                                     return shapeList;
	'                                                 }
	'                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)


	' #define DECLARE_SYN(NAME, ORIGINAL) template <typename OpName>
	'                                     struct __registratorSynonym_##NAME {
	'                                         __registratorSynonym_##NAME(const char *name, const char *oname) {
	'                                             auto ptr = reinterpret_cast<OpName *>(OpRegistrator::getInstance().getOperation(oname));
	'                                             if (ptr == nullptr) {
	'                                                 std::string newName(name);
	'                                                 std::string oldName(oname);
	'                                                 OpRegistrator::getInstance().pdateMSVC(sd::ops::HashHelper::getInstance().getLongHash(newName), oldName);
	'                                                 return;
	'                                             }
	'                                             OpRegistrator::getInstance().registerOperation(name, ptr);
	'                                             }
	'                                         };
	'                                         static sd::ops::__registratorSynonym_##NAME<ORIGINAL> zzz_register_opd_##NAME(#NAME, #ORIGINAL)

	' #define DECLARE_DIVERGENT_OP(NAME, NIN, NOUT, INPLACEABLE)  class ND4J_EXPORT NAME: public sd::ops::DeclarableOp {
	'                                                             public:
	'                                                                 NAME();
	'                                                                 sd::ShapeList* calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block);
	'                                                             protected:
	'                                                                 Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                                             };
	'                                                             REGISTER_H(NAME)

	' #define DIVERGENT_OP_IMPL(NAME, NIN, NOUT, INPLACEABLE)     NAME::NAME() : sd::ops::DeclarableOp(NIN, NOUT, #NAME, INPLACEABLE, true) { };
	'                                                             REGISTER_C(NAME)
	'                                                             sd::ShapeList* sd::ops::NAME::calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block) {
	'                                                                 auto shapeList = SHAPELIST();
	'                                                                 auto opLimit = this->getOpDescriptor()->getNumberOfOutputs() < 1 ? block.width() : this->getOpDescriptor()->getNumberOfOutputs();
	'                                                                 for (int e = 0; e < opLimit; e++) {
	'                                                                     Nd4jLong* newshape;
	'                                                                     COPY_SHAPE(inputShape->at(0), newshape);
	'                                                                     shapeList->push_back(CONSTANT(newshape));
	'                                                                 }
	'                                                                 return shapeList;
	'                                                             }
	'                                                             Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)

	' #define DECLARE_CONFIGURABLE_OP(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)     class ND4J_EXPORT NAME: public sd::ops::DeclarableOp {
	'                                                                                 public:
	'                                                                                     NAME();
	'                                                                                     sd::ShapeList* calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block);
	'                                                                                 protected:
	'                                                                                     void registerTypes();
	'                                                                                     Nd4jStatus validateAndExecute(sd::graph::Context& block);
	'                                                                                 };
	'                                                                                 REGISTER_H(NAME)

	' #define CONFIGURABLE_OP_IMPL(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)        NAME::NAME() : sd::ops::DeclarableOp(NIN, NOUT, #NAME, INPLACEABLE, TARGS, IARGS) { };
	'                                                                                 REGISTER_C(NAME)
	'                                                                                 sd::ShapeList* sd::ops::NAME::calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block) {
	'                                                                                     auto shapeList = SHAPELIST();
	'                                                                                     auto opLimit = this->getOpDescriptor()->getNumberOfOutputs() < 1 ? block.width() : this->getOpDescriptor()->getNumberOfOutputs();
	'                                                                                     for (int e = 0; e < opLimit; e++) {
	'                                                                                         auto newshape = ConstantShapeHelper::getInstance().createShapeInfo(ArrayOptions::dataType(inputShape->at(e)), shape::order(inputShape->at(e)), shape::rank(inputShape->at(e)), shape::shapeOf(inputShape->at(e)));
	'                                                                                         shapeList->push_back(newshape);
	'                                                                                     }
	'                                                                                     return shapeList;
	'                                                                                 }
	'                                                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(Context& block)

	' #define DECLARE_REDUCTION_OP(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)        class ND4J_EXPORT NAME: public sd::ops::DeclarableReductionOp {
	'                                                                                 public:
	'                                                                                     NAME();
	'                                                                                 protected:
	'                                                                                     void registerTypes();
	'                                                                                     Nd4jStatus validateAndExecute(Context& block);
	'                                                                                 };
	'                                                                                 REGISTER_H(NAME)

	' #define REDUCTION_OP_IMPL(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)           NAME::NAME() : sd::ops::DeclarableReductionOp(NIN, NOUT, #NAME, INPLACEABLE, TARGS, IARGS) { };
	'                                                                                 REGISTER_C(NAME)
	'                                                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)


	' #define DECLARE_CUSTOM_OP(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)           class ND4J_EXPORT NAME: public sd::ops::DeclarableCustomOp {
	'                                                                                 protected:
	'                                                                                     void registerTypes();
	'                                                                                     Nd4jStatus validateAndExecute(Context& block);
	'                                                                                 public:
	'                                                                                     NAME();
	'                                                                                     sd::ShapeList* calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block);
	'                                                                                 };
	'                                                                                 REGISTER_H(NAME)

	' #define CUSTOM_OP_IMPL(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)              NAME::NAME(): sd::ops::DeclarableCustomOp(NIN, NOUT, #NAME, INPLACEABLE, TARGS, IARGS) { };
	'                                                                                 REGISTER_C(NAME)
	'                                                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)

	' this declaration MUST follow DECLARE_CUSTOM_OP
	' #define DECLARE_SHAPE_FN(NAME)                                                  sd::ShapeList* sd::ops::NAME::calculateOutputShape(sd::ShapeList* inputShape, sd::graph::Context& block)


	' #define DECLARE_SAME_TYPE(NAME)                                                 void sd::ops::NAME::registerTypes() {this->getOpDescriptor()->setSameMode(true);}

	' #define DECLARE_TYPES(NAME)                                                     void sd::ops::NAME::registerTypes()

	' #define DECLARE_BROADCASTABLE_OP(NAME,TARGS, IARGS)                             class ND4J_EXPORT NAME: public sd::ops::BroadcastableOp {
	'                                                                                 protected:
	'                                                                                     void registerTypes();
	'                                                                                     Nd4jStatus validateAndExecute(Context& block);
	'                                                                                 public:
	'                                                                                     NAME();
	'                                                                                 };
	'                                                                                 REGISTER_H(NAME)

	' #define DECLARE_BROADCASTABLE_BOOL_OP(NAME,TARGS, IARGS)                        class ND4J_EXPORT NAME: public sd::ops::BroadcastableBoolOp {
	'                                                                                 protected:
	'                                                                                     void registerTypes();
	'                                                                                     Nd4jStatus validateAndExecute(Context& block);
	'                                                                                 public:
	'                                                                                     NAME();
	'                                                                                 };
	'                                                                                 REGISTER_H(NAME)


	' #define BROADCASTABLE_OP_IMPL(NAME, TARGS, IARGS)                               NAME::NAME(): sd::ops::BroadcastableOp(#NAME, TARGS, IARGS) { };
	'                                                                                 REGISTER_C(NAME)
	'                                                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)

	' #define BROADCASTABLE_BOOL_OP_IMPL(NAME, TARGS, IARGS)                          NAME::NAME(): sd::ops::BroadcastableBoolOp(#NAME, TARGS, IARGS) { };
	'                                                                                 REGISTER_C(NAME)
	'                                                                                 Nd4jStatus sd::ops::NAME::validateAndExecute(sd::graph::Context& block)


	' #define DECLARE_DEVICE_OP(NAME, NIN, NOUT, INPLACEABLE, TARGS, IARGS)

	' #define REPLICATE_SHAPE(SRC, TGT)   if (shape::order(SRC) == 'c')
	'                                         shape::shapeBuffer(shape::rank(SRC), sd::ArrayOptions::dataType(SRC), shape::shapeOf(SRC), TGT);
	'                                     else
	'                                         shape::shapeBufferFortran(shape::rank(SRC),  sd::ArrayOptions::dataType(SRC), shape::shapeOf(SRC), TGT);


	' #ifdef __CUDABLAS__

	' #else

	' #define ALLOCATE_SPECIAL(VARIABLE, WORKSPACE, LENGTH, TT) VARIABLE = nullptr;
	' #define RELEASE_SPECIAL(VARIABLE, WORKSPACE)

	' #endif

	' #ifdef _RELEASE

	' #define ALLOCATE(VARIABLE, WORKSPACE, LENGTH, TT)   if (WORKSPACE == nullptr) {VARIABLE = new TT[LENGTH]; } else {VARIABLE = reinterpret_cast<TT *>(WORKSPACE->allocateBytes(LENGTH * sizeof(TT))); }; memset(VARIABLE, 0, LENGTH * sizeof(TT));
	' #define RELEASE(VARIABLE, WORKSPACE)    if (WORKSPACE == nullptr) { delete[] VARIABLE;};

	' #else

	' #define ALLOCATE(VARIABLE, WORKSPACE, LENGTH, TT)   if (WORKSPACE == nullptr) {VARIABLE = new TT[LENGTH]; sd::memory::MemoryTracker::getInstance().countIn(sd::memory::MemoryType::HOST, VARIABLE, LENGTH * sizeof(TT)); } else {VARIABLE = reinterpret_cast<TT *>(WORKSPACE->allocateBytes(LENGTH * sizeof(TT))); }; memset(VARIABLE, 0, LENGTH * sizeof(TT));
	' #define RELEASE(VARIABLE, WORKSPACE)    if (WORKSPACE == nullptr) { sd::memory::MemoryTracker::getInstance().countOut(VARIABLE); delete[] VARIABLE;};

	' #endif

	' #define CONSTANT(SHAPE) ConstantShapeHelper::getInstance().createFromExisting(SHAPE, block.workspace())



	' #define STORE_RESULT(A)     this->storeResult(block, 0, A)
	' #define OVERWRITE_RESULT(A)     this->overwriteResult(block, 0, A)
	' #define OVERWRITE_2_RESULTS(A, B)     this->overwriteResult(block, 0, A); this->overwriteResult(block, 1, B)
	' #define STORE_2_RESULTS(A, B)   this->storeResult(block, 0, A); this->storeResult(block, 1, B)
	' #define STORE_3_RESULTS(A, B, C)    this->storeResult(block, 0, A); this->storeResult(block, 1, B); this->storeResult(block, 2, C)
	' #define STORE_4_RESULTS(A, B, C, D)     this->storeResult(block, 0, A); this->storeResult(block, 1, B); this->storeResult(block, 2, C); this->storeResult(block, 3, D)
	' #define STORE_5_RESULTS(A, B, C, D, E)      this->storeResult(block, 0, A); this->storeResult(block, 1, B); this->storeResult(block, 2, C); this->storeResult(block, 3, D); this->storeResult(block, 4, E)
	' #define BROADCAST_CHECK_EMPTY(X,Y,Z)     if(X->isEmpty() || Y->isEmpty()){ if(!Z->isEmpty()){ throw std::invalid_argument("Broadcast op validation failed: if x or y are empty, z must be empty");} return Status::OK();}

	' #define STASH(NAME, ARRAY)  block.getStash()->storeArray(block.getNodeId(), NAME, ARRAY);
	' #define CHECK_STASH(NAME)   block.getStash()->checkStash(block.getNodeId(), NAME);
	' #define UNSTASH(NAME)       block.getStash()->extractArray(block.getNodeId(), NAME);

	' #define INPUT_VARIABLE(INDEX)     block.array(INDEX)
	' #define OUTPUT_VARIABLE(INDEX)    reinterpret_cast<sd::NDArray *>(this->getZ(block, INDEX))
	' #define OUTPUT_NULLIFIED(INDEX)    reinterpret_cast<sd::NDArray *>(this->getNullifiedZ(block, INDEX))

	' #define INPUT_LIST(INDEX)     reinterpret_cast<sd::NDArrayList *>(block.getVariable(INDEX)->getNDArrayList())

	' #define D_ARG(INDEX)     block.getDArguments()->at(INDEX)
	' #define INT_ARG(INDEX)     block.getIArguments()->at(INDEX)
	' #define I_ARG(INDEX)     INT_ARG(INDEX)
	' #define T_ARG(INDEX)     block.getTArguments()->at(INDEX)
	' #define B_ARG(INDEX)     block.getBArguments()->at(INDEX)


	' #define COPY_SHAPE(SRC, TGT)    TGT = ShapeBuilders::copyShapeInfo(SRC, true, block.getWorkspace())

	' #define COPY_SHAPE_EX(SRC, TGT, WORKSPACE)    TGT = ShapeBuilders::copyShapeInfo(SRC, true, WORKSPACE)

	' define macros for compiler enforcement to make function inline  
	' #ifdef __clang__
	' #define INLINE_LOOPS
	' #define FORCEINLINE inline
	' #elif _MSC_VER
	' #define FORCEINLINE __forceinline
	' #elif __GNUC__
	' #define INLINE_LOOPS
	' #define FORCEINLINE __attribute__((always_inline)) inline 
	' #elif __CUDACC__ 
	' #else
	' #define FORCEINLINE inline 
	' #endif


	' #ifdef __CUDACC__

	' #else

	' #define _CUDA_H
	' #define _CUDA_D
	' #define _CUDA_G
	' #define _CUDA_HD

	' #endif // CUDACC

	' #define CHECK_ALLOC(PTR, MSG, BYTES) if (PTR == nullptr) { throw sd::allocation_exception::build(MSG, BYTES); };



	' #ifdef __CUDABLAS__

	' #else

	' #define LAMBDA_T(X, ...) [__VA_ARGS__] (T X) -> T
	' #define LAMBDA_TT(X, Y, ...) [__VA_ARGS__] (T X, T Y) -> T
	' #define LAMBDA_TTT(t, u, v, ...) [__VA_ARGS__] (T t, T u, T v) -> T

	' #define ILAMBDA_T(X, ...) [__VA_ARGS__] (Nd4jLong _idx, T X) -> T
	' #define ILAMBDA_TT(X, Y, ...) [__VA_ARGS__] (Nd4jLong _idx, T X, T Y) -> T

	' #define LAMBDA_D(X, ...) [__VA_ARGS__] (double X) -> double
	' #define LAMBDA_DD(X, Y, ...) [__VA_ARGS__] (double X, double Y) -> double
	' #define LAMBDA_DDD(t, u, v, ...) [__VA_ARGS__] (double t, double u, double v) -> double

	' #define LAMBDA_H(X, ...) [__VA_ARGS__] (float16 X) -> float16
	' #define LAMBDA_HH(X, Y, ...) [__VA_ARGS__] (float16 X, float16 Y) -> float16

	' #define ILAMBDA_D(X, ...) [__VA_ARGS__] (Nd4jLong _idx, double X) -> double
	' #define ILAMBDA_DD(X, Y, ...) [__VA_ARGS__] (Nd4jLong _idx, double X, double Y) -> double

	' #define ILAMBDA_F(X, ...) [__VA_ARGS__] (Nd4jLong _idx, float X) -> float
	' #define ILAMBDA_FF(X, Y, ...) [__VA_ARGS__] (Nd4jLong _idx, float X, float Y) -> float

	' #define LAMBDA_F(X, ...) [__VA_ARGS__] (float X) -> float
	' #define LAMBDA_FF(X, Y, ...) [__VA_ARGS__] (float X, float Y) -> float
	' #define LAMBDA_FFF(t, u, v, ...) [__VA_ARGS__] (float t, float u, float v) -> float

	' #endif

	' stuff for benchmarks
	' #define GENERATE_XYZ() [&] (ResultSet &x, ResultSet &y, ResultSet &z)
	' #define GENERATE_XZ() [&] (ResultSet &x, ResultSet &z)

	' #define PARAMETRIC_XYZ() [&] (Parameters &p, ResultSet &x, ResultSet &y, ResultSet &z)
	' #define PARAMETRIC_XZ() [&] (Parameters &p, ResultSet &x, ResultSet &z)

	' #define PARAMETRIC_D() [&] (Parameters &p) -> Context*


	' #ifdef __CUDABLAS__
	' #endif

	' #endif


	' Parsed from ops/InputType.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef ND4J_INPUTTYPE_H
	' #define ND4J_INPUTTYPE_H
			''' <summary>
			''' enum sd::ops::InputType </summary>
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int InputType_BOOLEAN = 0, InputType_NUMERIC = 1, InputType_STRINGULAR = 2, InputType_NUMERIC_SET = 3, InputType_STRINGULAR_SET = 4;
			3, InputType_STRINGULAR_SET = 4
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int InputType_BOOLEAN = 0, InputType_NUMERIC = 1, InputType_STRINGULAR = 2, InputType_NUMERIC_SET = 3, InputType_STRINGULAR_SET
				2, InputType_NUMERIC_SET = 3, InputType_STRINGULAR_SET
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int InputType_BOOLEAN = 0, InputType_NUMERIC = 1, InputType_STRINGULAR = 2, InputType_NUMERIC_SET
					1, InputType_STRINGULAR = 2, InputType_NUMERIC_SET
'JAVA TO VB CONVERTER WARNING: An assignment within expression was extracted from the following statement:
'ORIGINAL LINE: public static final int InputType_BOOLEAN = 0, InputType_NUMERIC = 1, InputType_STRINGULAR
						0, InputType_NUMERIC = 1, InputType_STRINGULAR
							public static final Integer InputType_BOOLEAN = 0, InputType_NUMERIC



	' #endif

	' Parsed from ops/declarable/OpDescriptor.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_OPDESCRIPTOR_H
	' #define LIBND4J_OPDESCRIPTOR_H

	' #include <string>
	' #include <vector>
	' #include <initializer_list>
	' #include <helpers/helper_hash.h>
	' #include <ops/InputType.h>
	' #include <graph/generated/node_generated.h>
	' #include <array/DataType.h>

			''' <summary>
			'''   This class is very basic info holder for ops. bean/pojo pretty much.
			''' 
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") @NoOffset public static class OpDescriptor extends Pointer
			public static class OpDescriptor extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public OpDescriptor(Pointer p)
				If True Then
					MyBase(p)
				End If

				' default constructor
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @StdString BytePointer opName, @Cast("bool") boolean allowsInplace)
				public OpDescriptor(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @StdString BytePointer opName, @Cast("bool") boolean allowsInplace);
				private native void allocate(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @StdString String opName, @Cast("bool") boolean allowsInplace)
				public OpDescriptor(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @StdString String opName, @Cast("bool") boolean allowsInplace);
				private native void allocate(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace)

				' constructor for boolean ops
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, @StdString BytePointer opName, @Cast("bool") boolean isScalar)
				public OpDescriptor(Integer numInputs, BytePointer opName, Boolean isScalar)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, opName, isScalar)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, @StdString BytePointer opName, @Cast("bool") boolean isScalar);
				private native void allocate(Integer numInputs, BytePointer opName, Boolean isScalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, @StdString String opName, @Cast("bool") boolean isScalar)
				public OpDescriptor(Integer numInputs, String opName, Boolean isScalar)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, opName, isScalar)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, @StdString String opName, @Cast("bool") boolean isScalar);
				private native void allocate(Integer numInputs, String opName, Boolean isScalar)

				' default constructor

				' constructor for configurable op
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @Cast("char*") String opName, @Cast("bool") boolean allowsInplace, int tArgs, int iArgs)
				public OpDescriptor(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Integer tArgs, Integer iArgs)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, tArgs, iArgs)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @Cast("char*") String opName, @Cast("bool") boolean allowsInplace, int tArgs, int iArgs);
				private native void allocate(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Integer tArgs, Integer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @Cast("char*") BytePointer opName, @Cast("bool") boolean allowsInplace, int tArgs, int iArgs)
				public OpDescriptor(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Integer tArgs, Integer iArgs)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, tArgs, iArgs)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @Cast("char*") BytePointer opName, @Cast("bool") boolean allowsInplace, int tArgs, int iArgs);
				private native void allocate(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Integer tArgs, Integer iArgs)

				' constructor for non-configurable divergent op
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @StdString BytePointer opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent)
				public OpDescriptor(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Boolean divergent)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, divergent)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @StdString BytePointer opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent);
				private native void allocate(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Boolean divergent)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @StdString String opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent)
				public OpDescriptor(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Boolean divergent)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, divergent)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @StdString String opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent);
				private native void allocate(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Boolean divergent)

				' constructor for non-configurable divergent op

				' constructor for configurable divergent op
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @Cast("char*") String opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent, int tArgs, int iArgs)
				public OpDescriptor(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Boolean divergent, Integer tArgs, Integer iArgs)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, divergent, tArgs, iArgs)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @Cast("char*") String opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent, int tArgs, int iArgs);
				private native void allocate(Integer numInputs, Integer numOutputs, String opName, Boolean allowsInplace, Boolean divergent, Integer tArgs, Integer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(int numInputs, int numOutputs, @Cast("char*") BytePointer opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent, int tArgs, int iArgs)
				public OpDescriptor(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Boolean divergent, Integer tArgs, Integer iArgs)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(numInputs, numOutputs, opName, allowsInplace, divergent, tArgs, iArgs)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(int numInputs, int numOutputs, @Cast("char*") BytePointer opName, @Cast("bool") boolean allowsInplace, @Cast("bool") boolean divergent, int tArgs, int iArgs);
				private native void allocate(Integer numInputs, Integer numOutputs, BytePointer opName, Boolean allowsInplace, Boolean divergent, Integer tArgs, Integer iArgs)

				' constructor for logical ops (while, scope, etc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(@Cast("char*") String opName, @Cast("bool") boolean isLogic)
				public OpDescriptor( String opName, Boolean isLogic)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(opName, isLogic)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") String opName, @Cast("bool") boolean isLogic);
				private native void allocate( String opName, Boolean isLogic)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public OpDescriptor(@Cast("char*") BytePointer opName, @Cast("bool") boolean isLogic)
				public OpDescriptor( BytePointer opName, Boolean isLogic)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(opName, isLogic)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") BytePointer opName, @Cast("bool") boolean isLogic);
				private native void allocate( BytePointer opName, Boolean isLogic)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef OpDescriptor other);
				public native @Name("operator ==") Boolean Equals( OpDescriptor other)

				' default destructor

				' this method returns minimal expected number of T arguments
				public native Integer getNumberOfTArgs()

				' this method returns minimal expected number of Integer arguments
				public native Integer getNumberOfIArgs()

				' this method returns minimal expected number of inputs
				public native Integer getNumberOfInputs()

				' this method returns hash code for this operation
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getHash();
				public native Long getHash()

				' this method returns minimal expected number of outputs
				public native Integer getNumberOfOutputs()

				' this method returns opName (can be empty)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString @Cast({"char*", "std::string*"}) BytePointer getOpName();
				public native @Cast({"char*", "std::string*"}) BytePointer getOpName()

				' returns TRUE if this op is divergent. FALSE otherwise
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isDivergent();
				public native Boolean isDivergent()

				' returns TRUE if this op allows in-place execution
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean allowsInplace();
				public native Boolean allowsInplace()

				' this method allows you to enable/disable inplace call for a given op
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void allowInplace(@Cast("bool") boolean reallyAllow);
				public native void allowInplace( Boolean reallyAllow)

				' this method returns opNum (applicable for legacy XYZ ops only)
				public native Integer getOpNum()

				' this method allows to set specifc opNum
				public native void setOpNum(Integer opNum)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void setHash(@Cast("Nd4jLong") long hash);
				public native void setHash( Long hash)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::ops::InputType") int inputType();
				public native Integer inputType()



'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setInputType(@Cast("sd::ops::InputType") int type);
				public native OpDescriptor setInputType( Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedInputTypes(int index, @Cast("sd::DataType*") @StdVector IntPointer dtype);
				public native OpDescriptor setAllowedInputTypes(Integer index, @StdVector IntPointer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedInputTypes(int index, @Cast("sd::DataType*") @StdVector IntBuffer dtype);
				public native OpDescriptor setAllowedInputTypes(Integer index, @StdVector IntBuffer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedInputTypes(int index, @Cast("sd::DataType*") @StdVector int[] dtype);
				public native OpDescriptor setAllowedInputTypes(Integer index, @StdVector Integer() dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedOutputTypes(int index, @Cast("sd::DataType*") @StdVector IntPointer dtype);
				public native OpDescriptor setAllowedOutputTypes(Integer index, @StdVector IntPointer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedOutputTypes(int index, @Cast("sd::DataType*") @StdVector IntBuffer dtype);
				public native OpDescriptor setAllowedOutputTypes(Integer index, @StdVector IntBuffer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedOutputTypes(int index, @Cast("sd::DataType*") @StdVector int[] dtype);
				public native OpDescriptor setAllowedOutputTypes(Integer index, @StdVector Integer() dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedInputTypes(int index, @Cast("sd::DataType") int dtype);
				public native OpDescriptor setAllowedInputTypes(Integer index, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedOutputTypes(int index, @Cast("sd::DataType") int dtype);
				public native OpDescriptor setAllowedOutputTypes(Integer index, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedInputTypes(@Cast("sd::DataType") int dtype);
				public native OpDescriptor setAllowedInputTypes( Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setAllowedOutputTypes(@Cast("sd::DataType") int dtype);
				public native OpDescriptor setAllowedOutputTypes( Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor allowOverride(@Cast("bool") boolean reallyAllow);
				public native OpDescriptor allowOverride( Boolean reallyAllow)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setSameMode(@Cast("bool") boolean reallySame);
				public native OpDescriptor setSameMode( Boolean reallySame)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setInputType(int idx, @Cast("sd::DataType") int dtype);
				public native OpDescriptor setInputType(Integer idx, Integer dtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native OpDescriptor setOutputType(int idx, @Cast("sd::DataType") int dtype);
				public native OpDescriptor setOutputType(Integer idx, Integer dtype)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType*") @StdVector IntPointer getOutputTypesForOutput(int index);
				public native @StdVector IntPointer getOutputTypesForOutput(Integer index)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean checkInputMatch(int index, @Cast("sd::DataType") int dataType);
				public native Boolean checkInputMatch(Integer index, Integer dataType)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean checkOutputMatch(int index, @Cast("sd::DataType") int dataType);
				public native Boolean checkOutputMatch(Integer index, Integer dataType)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isSameMode();
				public native Boolean isSameMode()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInherit(int index);
				public native Boolean isInherit(Integer index)
			End If



	' #endif //LIBND4J_OPDESCRIPTOR_H


	' Parsed from ops/declarable/PlatformHelper.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef SD_PLATFORMHELPER_H
	' #define SD_PLATFORMHELPER_H

	' #include <helpers/ShapeUtils.h>
	' #include <execution/Engine.h>
	' #include <graph/Context.h>
	' #include <string>
	' #include <system/pointercast.h>
	' #include <system/dll.h>
				''' <summary>
				''' This abstract class defines methods used by platform-specific helpers implementations
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops::platforms") @NoOffset public static class PlatformHelper extends Pointer
				public static class PlatformHelper extends Pointer
				If True Then
					''' <summary>
					''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
					public PlatformHelper(Pointer p)
					If True Then
						MyBase(p)
					End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString BytePointer name();
					public native BytePointer name()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("samediff::Engine") int engine();
					public native Integer engine()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long hash();
					public native Long hash()

					''' <summary>
					''' This method checks, if given helper can be used with given input/output/configuration options
					''' </summary>
					''' <param name="context">
					''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isUsable(@ByRef Context context);
					public native Boolean isUsable( Context context)

					''' <summary>
					''' This method invokes helper. Typically this method replaces actual op execution
					''' </summary>
					''' <param name="context">
					''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int invokeHelper(@ByRef Context context);
					public native Integer invokeHelper( Context context)

					''' <summary>
					''' Helper method, needed for compatibility with DeclarableOp macros </summary>
					''' <param name="ctx"> </param>
					''' <param name="inputId">
					''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray getZ(@ByRef Context ctx, int inputId);
					public native NDArray getZ( Context ctx, Integer inputId)

					''' <summary>
					''' Helper method, needed for compatibility with DeclarableOp macros </summary>
					''' <param name="ctx"> </param>
					''' <param name="inputId">
					''' @return </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native NDArray getNullifiedZ(@ByRef Context ctx, int inputId);
					public native NDArray getNullifiedZ( Context ctx, Integer inputId)
				End If





	' #endif //SD_PLATFORMHELPER_H


	' Parsed from ops/declarable/BroadcastableOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver on 6/6/2018.
	'

	' #ifndef LIBND4J_BROADCASTABLEOP_H
	' #define LIBND4J_BROADCASTABLEOP_H

	' #include <graph/Context.h>
	' #include "OpDescriptor.h"
	' #include "DeclarableOp.h"
	' #include "DeclarableCustomOp.h"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class BroadcastableOp extends DeclarableCustomOp
			public static class BroadcastableOp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public BroadcastableOp(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If




	' #endif //LIBND4J_BROADCASTABLEOP_H


	' Parsed from ops/declarable/BroadcastableBoolOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver on 6/6/2018.
	'

	' #ifndef SD_BROADCASTABLEBOOLOP_H
	' #define SD_BROADCASTABLEBOOLOP_H

	' #include <graph/Context.h>
	' #include "OpDescriptor.h"
	' #include "DeclarableOp.h"
	' #include "DeclarableCustomOp.h"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class BroadcastableBoolOp extends DeclarableCustomOp
			public static class BroadcastableBoolOp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public BroadcastableBoolOp(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If




	' #endif //SD_BROADCASTABLEBOOLOP_H


	' Parsed from ops/declarable/DeclarableOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_DECLARABLE_OPS_H
	' #define LIBND4J_DECLARABLE_OPS_H

	' #include <sstream>
	' #include <types/float16.h>
	' #include <system/pointercast.h>
	' #include <array/NDArray.h>
	' #include <graph/Context.h>
	' #include "OpDescriptor.h"
	' #include <helpers/helper_hash.h>
	' #include <array/ShapeList.h>
	' #include <array/ResultSet.h>
	' #include <helpers/OpArgsHolder.h>
	' #include <system/dll.h>
	' #include <ops/declarable/EmptyHandling.h>
	'#include <ops/declarable/declarable_ops.h>

	' #include <chrono>
	' #include <ctime>
	' #include <mutex>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public native @Cast("Nd4jStatus") int conditionHelper(@Cast("char*") String file, int line, int condition, int argNumber, @Cast("char*") String format);
			Integer conditionHelper( String file, Integer line, Integer condition, Integer argNumber, String format)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public native @Cast("Nd4jStatus") int conditionHelper(@Cast("char*") BytePointer file, int line, int condition, int argNumber, @Cast("char*") BytePointer format);
			Integer conditionHelper( BytePointer file, Integer line, Integer condition, Integer argNumber, BytePointer format)

			''' <summary>
			''' This class is the basic building block of Graph Operations. Any CustomOp out there is built on top of this "abstract" class.
			''' 
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") @NoOffset public static class DeclarableOp extends Pointer
			public static class DeclarableOp extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public DeclarableOp(Pointer p)
				If True Then
					MyBase(p)
				End If

				' for special cases, like BooleanOps

				' regular constructors

				' for LogicalOps

				' default testructor

				' this method returns OpDescriptor, describing this Op instance
				public native OpDescriptor getOpDescriptor()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateDataTypes(@ByRef Context block);
				public native Integer validateDataTypes( Context block)

				''' <summary>
				'''   This method should be available in each implemented Op, and should return Op output shape(s), for a given input shape(s)
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)

				''' <summary>
				''' Returns opName
				''' 
				''' @return
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdString @Cast({"char*", "std::string*"}) BytePointer getOpName();
				public native @Cast({"char*", "std::string*"}) BytePointer getOpName()

				''' <summary>
				''' Returns opHash
				''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long getOpHash();
				public native Long getOpHash()

				''' <summary>
				''' This method sets arguments for op
				''' </summary>
	'            void setArguments();

				''' <summary>
				''' This method returns pointer to results
				''' </summary>
	'            void getResults();

				''' <summary>
				''' This method executes given Op
				''' </summary>
				''' <param name="block"> </param>
				''' <returns> 0 if OK, error code otherwise </returns>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(Context block);
				public native Integer execute(Context block)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntPointer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs, @StdVector IntBuffer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs, @StdVector Integer() dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs, @StdVector IntPointer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntBuffer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace);
				public native Integer execute( NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs, @StdVector Integer() dArgs, Boolean isInplace)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs);
				public native ResultSet evaluate( NDArrayVector inputs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntPointer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs);
				public native ResultSet evaluate( NDArrayVector inputs, DoublePointer tArgs, @StdVector LongPointer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs, @StdVector IntBuffer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs);
				public native ResultSet evaluate( NDArrayVector inputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs, @StdVector Integer() dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs);
				public native ResultSet evaluate( NDArrayVector inputs, Double() tArgs, @StdVector Long() iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs, @StdVector IntPointer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntBuffer dArgs, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet evaluate(@Const @ByRef NDArrayVector inputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace);
				public native ResultSet evaluate( NDArrayVector inputs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs, @StdVector Integer() dArgs, Boolean isInplace)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntPointer dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs, @StdVector IntBuffer dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector Boolean() bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs, @StdVector Integer() dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector IntPointer dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs, @StdVector IntPointer dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoublePointer tArgs, @Cast("Nd4jLong*") @StdVector LongPointer iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoublePointer tArgs, @StdVector LongPointer iArgs, @StdVector Boolean() bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs, @Cast("sd::DataType*") @StdVector IntBuffer dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs, @StdVector IntBuffer dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector DoubleBuffer tArgs, @Cast("Nd4jLong*") @StdVector LongBuffer iArgs, @Cast("bool*") @StdVector BooleanPointer bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, DoubleBuffer tArgs, @StdVector LongBuffer iArgs, @StdVector BooleanPointer bArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs, @Cast("sd::DataType*") @StdVector int[] dArgs, @Cast("bool") boolean isInplace, @Cast("sd::DataType") int type);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs, @StdVector Integer() dArgs, Boolean isInplace, Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(@ByRef RandomGenerator rng, @Const @ByRef NDArrayVector inputs, @Const @ByRef NDArrayVector outputs, @StdVector double[] tArgs, @Cast("Nd4jLong*") @StdVector long[] iArgs, @Cast("bool*") @StdVector boolean[] bArgs);
				public native Integer execute( RandomGenerator rng, @ByRef NDArrayVector inputs, @ByRef NDArrayVector outputs, Double() tArgs, @StdVector Long() iArgs, @StdVector Boolean() bArgs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet execute(@Const @ByRef OpArgsHolder holder, @Cast("bool") boolean isInplace);
				public native ResultSet execute( OpArgsHolder holder, Boolean isInplace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet execute(@Const @ByRef OpArgsHolder holder);
				public native ResultSet execute( OpArgsHolder holder)


				' There methods provide various validation options
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateNonEmptyInput(@ByRef Context block);
				public native Integer validateNonEmptyInput( Context block)

				' this method checks if all input arrays have equal lengths
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInputLengthMatch(@ByRef Context block);
				public native Integer validateInputLengthMatch( Context block)

				' this method checks if all input arrays have the same shapes (orders/strides are NOT checked)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInputDimensionsMatch(@ByRef Context block);
				public native Integer validateInputDimensionsMatch( Context block)

				' this method check if all input arrays have the same orders
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateOrdersMatch(@ByRef Context block);
				public native Integer validateOrdersMatch( Context block)

				' this method checks if all input arrays are 2D
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInput2D(@ByRef Context block);
				public native Integer validateInput2D( Context block)

				' this method checks if all input arrays are 3D
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInput3D(@ByRef Context block);
				public native Integer validateInput3D( Context block)

				' this method checks if all input arrays are 4D
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInput4D(@ByRef Context block);
				public native Integer validateInput4D( Context block)

				' this method checks if all input arrays are ND
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateInputDimensions(@ByRef Context block, int rank);
				public native Integer validateInputDimensions( Context block, Integer rank)

				' this method checks if number of available arguments matches op expectations
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int validateArguments(@ByRef Context block);
				public native Integer validateArguments( Context block)
			End If



	' #endif //LIBND4J_DECLARABLE_OPS_H


	' Parsed from ops/declarable/DeclarableListOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_DECLARABLE_LIST_OP_H
	' #define LIBND4J_DECLARABLE_LIST_OP_H

	' #include <array/ResultSet.h>
	' #include <graph/Context.h>
	' #include <ops/declarable/OpRegistrator.h>
	' #include <ops/declarable/DeclarableOp.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class DeclarableListOp extends DeclarableOp
			public static class DeclarableListOp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public DeclarableListOp(Pointer p)
				If True Then
					MyBase(p)
				End If



'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(Context block);
				public native Integer execute(Context block)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet execute(NDArrayList list, @ByRef NDArrayVector inputs, @StdVector DoublePointer tArgs, @StdVector IntPointer iArgs);
				public native ResultSet execute(NDArrayList list, NDArrayVector inputs, DoublePointer tArgs, IntPointer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet execute(NDArrayList list, @ByRef NDArrayVector inputs, @StdVector DoubleBuffer tArgs, @StdVector IntBuffer iArgs);
				public native ResultSet execute(NDArrayList list, NDArrayVector inputs, DoubleBuffer tArgs, IntBuffer iArgs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ResultSet execute(NDArrayList list, @ByRef NDArrayVector inputs, @StdVector double[] tArgs, @StdVector int[] iArgs);
				public native ResultSet execute(NDArrayList list, NDArrayVector inputs, Double() tArgs, Integer() iArgs)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If



	' #endif

	' Parsed from ops/declarable/DeclarableReductionOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 07.10.2017.
	'

	' #ifndef LIBND4J_DECLARABLE_REDUCTION_OP_H
	' #define LIBND4J_DECLARABLE_REDUCTION_OP_H

	' #include <ops/declarable/DeclarableOp.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class DeclarableReductionOp extends DeclarableOp
			public static class DeclarableReductionOp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public DeclarableReductionOp(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If



	' #endif //LIBND4J_DECLARABLE_REDUCTION_OP_H


	' Parsed from ops/declarable/DeclarableCustomOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 07.10.2017.
	'

	' #ifndef LIBND4J_DECLARABLECUSTOMOP_H
	' #define LIBND4J_DECLARABLECUSTOMOP_H

	' #include <ops/declarable/DeclarableOp.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class DeclarableCustomOp extends DeclarableOp
			public static class DeclarableCustomOp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public DeclarableCustomOp(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShapes, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShapes, Context block)
			End If



	' #endif //LIBND4J_DECLARABLECUSTOMOP_H


	' Parsed from ops/declarable/BooleanOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 13.10.2017.
	'

	' #ifndef LIBND4J_BOOLEANOP_H
	' #define LIBND4J_BOOLEANOP_H

	' #include <graph/Context.h>
	' #include "OpDescriptor.h"
	' #include "DeclarableOp.h"
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") @NoOffset public static class BooleanOp extends DeclarableOp
			public static class BooleanOp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public BooleanOp(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean verify(@Const @ByRef NDArrayVector args);
				public native Boolean verify( NDArrayVector args)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean verify(@ByRef Context block);
				public native Boolean verify( Context block)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jStatus") int execute(Context block);
				public native Integer execute(Context block)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If





	' #endif //LIBND4J_BOOLEANOP_H

	' Parsed from ops/declarable/LogicOp.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 15.10.2017.
	'

	' #ifndef LIBND4J_LOGICOP_H
	' #define LIBND4J_LOGICOP_H

	' #include "DeclarableOp.h"

			''' <summary>
			''' Logic ops are unique snowflakes in any Graph. They dramatically change Graph Execution process, by introducing loops, conditions, etc.
			''' 
			''' Their code is the part of GraphExecutioner logic. But we still want them to be expressed via Graph
			''' \tparam T
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class LogicOp extends DeclarableOp
			public static class LogicOp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public LogicOp(Pointer p)
				If True Then
					MyBase(p)
				End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public LogicOp(@Cast("char*") String name)
				public LogicOp( String name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") String name);
				private native void allocate( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public LogicOp(@Cast("char*") BytePointer name)
				public LogicOp( BytePointer name)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocate(name)
				End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("char*") BytePointer name);
				private native void allocate( BytePointer name)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
				public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If




	' #endif //LIBND4J_LOGICOP_H


	' Parsed from ops/declarable/OpRegistrator.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 07.10.2017.
	'

	' #ifndef LIBND4J_OPREGISTRATOR_H
	' #define LIBND4J_OPREGISTRATOR_H

	' #include <system/pointercast.h>
	' #include <vector>
	' #include <unordered_map>
	' #include <mutex>
	' #include <ops/declarable/DeclarableOp.h>
	' #include <ops/declarable/PlatformHelper.h>
	' #include <execution/Engine.h>

	' handlers part
	' #include <cstdlib>
	' #include <csignal>

	' #ifndef __JAVACPP_HACK__

	' #endif
			''' <summary>
			'''   This class provides runtime ops lookup, based on opName or opHash.
			'''   To build lookup directory we use *_OP_IMPL macro, which puts static structs at compile time in .cpp files,
			'''   so once binary is executed, static objects are initialized automatically, and we get list of all ops
			'''   available at runtime via this singleton.
			''' 
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") @NoOffset public static class OpRegistrator extends Pointer
			public static class OpRegistrator extends Pointer
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public OpRegistrator(Pointer p)
				If True Then
					MyBase(p)
				End If


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef OpRegistrator getInstance();
				public native OpRegistrator getInstance()

				public native void exitHandler()
				public native void sigIntHandler(Integer sig)
				public native void sigSegVHandler(Integer sig)


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("char*") String getAllCustomOperations();
				public native String getAllCustomOperations()

				''' <summary>
				''' This method registers operation in our registry, so we can use them later
				''' </summary>
				''' <param name="op"> </param>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean registerOperation(@Cast("char*") String name, DeclarableOp op);
				public native Boolean registerOperation( String name, DeclarableOp op)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean registerOperation(@Cast("char*") BytePointer name, DeclarableOp op);
				public native Boolean registerOperation( BytePointer name, DeclarableOp op)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean registerOperation(DeclarableOp op);
				public native Boolean registerOperation(DeclarableOp op)

				public native void registerHelper(PlatformHelper op)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean hasHelper(@Cast("Nd4jLong") long hash, @Cast("samediff::Engine") int engine);
				public native Boolean hasHelper( Long hash, Integer engine)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native DeclarableOp getOperation(@Cast("char*") String name);
				public native DeclarableOp getOperation( String name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native DeclarableOp getOperation(@Cast("char*") BytePointer name);
				public native DeclarableOp getOperation( BytePointer name)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native DeclarableOp getOperation(@Cast("Nd4jLong") long hash);
				public native DeclarableOp getOperation( Long hash)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native PlatformHelper getPlatformHelper(@Cast("Nd4jLong") long hash, @Cast("samediff::Engine") int engine);
				public native PlatformHelper getPlatformHelper( Long hash, Integer engine)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer getAllHashes();
				public native @StdVector LongPointer getAllHashes()

				public native Integer numberOfOperations()
			End If


	'        
	'         *  These structs are used to "register" our ops in OpRegistrator.
	'         




	' #endif //LIBND4J_OPREGISTRATOR_H


	' Parsed from ops/declarable/CustomOperations.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 07.10.2017.
	'

	' #ifndef LIBND4J_CUSTOMOPERATIONS_H
	' #define LIBND4J_CUSTOMOPERATIONS_H

	' #include <ops/declarable/headers/activations.h>
	' #include <ops/declarable/headers/boolean.h>
	' #include <ops/declarable/headers/broadcastable.h>
	' #include <ops/declarable/headers/convo.h>
	' #include <ops/declarable/headers/compression.h>
	' #include <ops/declarable/headers/list.h>
	' #include <ops/declarable/headers/recurrent.h>
	' #include <ops/declarable/headers/transforms.h>
	' #include <ops/declarable/headers/parity_ops.h>
	' #include <ops/declarable/headers/shape.h>
	' #include <ops/declarable/headers/random.h>
	' #include <ops/declarable/headers/nlp.h>
	' #include <ops/declarable/headers/nn.h>
	' #include <ops/declarable/headers/blas.h>
	' #include <ops/declarable/headers/bitwise.h>
	' #include <ops/declarable/headers/loss.h>
	' #include <ops/declarable/headers/datatypes.h>
	' #include <ops/declarable/headers/third_party.h>
	' #include <ops/declarable/headers/tests.h>
	' #include <ops/declarable/headers/kernels.h>
	' #include <ops/declarable/headers/strings.h>
	' #include <ops/declarable/headers/compat.h>
	' #include <ops/declarable/headers/util.h>
	' #include <ops/declarable/headers/BarnesHutTsne.h>
	' #include <ops/declarable/headers/images.h>
	' #include <ops/declarable/headers/updaters.h>
	' #include <ops/declarable/headers/decoder.h>
	' #include <system/dll.h>
	' #include <helpers/shape.h>
	' #include <helpers/TAD.h>
	' #include <graph/Status.h>
	' #include <helpers/ArrayUtils.h>
	' #include <helpers/ShapeBuilders.h>
	' #include <array/NDArrayFactory.h>
	' #include <helpers/OpTracker.h>
	' #include <helpers/ConstantShapeHelper.h>
	' #include <helpers/ConstantTadHelper.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class _loader extends Pointer
		public static class _loader extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public _loader(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public _loader(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public _loader position(Long position)
			If True Then
				Return CType(MyBase.position(position), _loader)
			End If
			public _loader getPointer(Long i)
			If True Then
				Return (New _loader(CType(Me, Pointer))).position(position + i)
			End If

			public _loader()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
		End If

			' logic ops 
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Switch extends DeclarableOp
			public static class Switch extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Switch(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Switch(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Switch position(Long position)
				If True Then
					Return CType(MyBase.position(position), Switch)
				End If
				public Switch getPointer(Long i)
				If True Then
					Return (New Switch(CType(Me, Pointer))).position(position + i)
				End If

																	public Switch()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																	public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class @While extends LogicOp
			public static class [While] extends LogicOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public [While](Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public [While](Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public [While] position(Long position)
				If True Then
					Return CType(MyBase.position(position), [While])
				End If
				public [While] getPointer(Long i)
				If True Then
					Return (New [While](CType(Me, Pointer))).position(position + i)
				End If

											public [While]()
											If True Then
												MyBase(DirectCast(Nothing, Pointer))
												allocate()
											End If
											private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Scope extends LogicOp
			public static class Scope extends LogicOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Scope(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Scope(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Scope position(Long position)
				If True Then
					Return CType(MyBase.position(position), Scope)
				End If
				public Scope getPointer(Long i)
				If True Then
					Return (New Scope(CType(Me, Pointer))).position(position + i)
				End If

											public Scope()
											If True Then
												MyBase(DirectCast(Nothing, Pointer))
												allocate()
											End If
											private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Conditional extends LogicOp
			public static class Conditional extends LogicOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Conditional(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Conditional(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Conditional position(Long position)
				If True Then
					Return CType(MyBase.position(position), Conditional)
				End If
				public Conditional getPointer(Long i)
				If True Then
					Return (New Conditional(CType(Me, Pointer))).position(position + i)
				End If

											public Conditional()
											If True Then
												MyBase(DirectCast(Nothing, Pointer))
												allocate()
											End If
											private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class @Return extends LogicOp
			public static class [Return] extends LogicOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public [Return](Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public [Return](Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public [Return] position(Long position)
				If True Then
					Return CType(MyBase.position(position), [Return])
				End If
				public [Return] getPointer(Long i)
				If True Then
					Return (New [Return](CType(Me, Pointer))).position(position + i)
				End If

											public [Return]()
											If True Then
												MyBase(DirectCast(Nothing, Pointer))
												allocate()
											End If
											private native void allocate()
			End If


			''' <summary>
			''' This operations exposes given arguments as it's own outputs, but does it only once.
			''' Subsequent calls will be served directly by this op.
			''' 
			''' PLEASE NOTE: This operation is internal graph operation, and shouldn't be used directly usually.
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class expose extends DeclarableCustomOp
			public static class expose extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public expose(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public expose(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public expose position(Long position)
				If True Then
					Return CType(MyBase.position(position), expose)
				End If
				public expose getPointer(Long i)
				If True Then
					Return (New expose(CType(Me, Pointer))).position(position + i)
				End If

																						public expose()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If



	' #endif //LIBND4J_CUSTOMOPERATIONS_H


	' Parsed from ops/declarable/headers/activations.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_ACTIVATIONS_H
	' #define LIBND4J_HEADERS_ACTIVATIONS_H


	' #include <ops/declarable/headers/common.h>
			''' <summary>
			''' This is Sigmoid activation function implementation
			''' Math is: 1 / 1 + exp(-x)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_sigmoid)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sigmoid extends DeclarableOp
			public static class sigmoid extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sigmoid(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sigmoid(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sigmoid position(Long position)
				If True Then
					Return CType(MyBase.position(position), sigmoid)
				End If
				public sigmoid getPointer(Long i)
				If True Then
					Return (New sigmoid(CType(Me, Pointer))).position(position + i)
				End If

																						public sigmoid()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sigmoid_bp extends DeclarableOp
			public static class sigmoid_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sigmoid_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sigmoid_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sigmoid_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), sigmoid_bp)
				End If
				public sigmoid_bp getPointer(Long i)
				If True Then
					Return (New sigmoid_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public sigmoid_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Softsign activation function implementation
			''' Math is: x / 1 + abs(x)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_softsign)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softsign extends DeclarableOp
			public static class softsign extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softsign(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softsign(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softsign position(Long position)
				If True Then
					Return CType(MyBase.position(position), softsign)
				End If
				public softsign getPointer(Long i)
				If True Then
					Return (New softsign(CType(Me, Pointer))).position(position + i)
				End If

																						public softsign()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softsign_bp extends DeclarableOp
			public static class softsign_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softsign_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softsign_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softsign_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), softsign_bp)
				End If
				public softsign_bp getPointer(Long i)
				If True Then
					Return (New softsign_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public softsign_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Tanh activation function implementation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_tanh)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tanh extends DeclarableOp
			public static class tanh extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tanh(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tanh(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tanh position(Long position)
				If True Then
					Return CType(MyBase.position(position), tanh)
				End If
				public tanh getPointer(Long i)
				If True Then
					Return (New tanh(CType(Me, Pointer))).position(position + i)
				End If

																						public tanh()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tanh_bp extends DeclarableOp
			public static class tanh_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tanh_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tanh_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tanh_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), tanh_bp)
				End If
				public tanh_bp getPointer(Long i)
				If True Then
					Return (New tanh_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public tanh_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Softplus activation function implementation
			''' Math is: log(1 + exp(x))
			''' </summary>
	'         #if NOT_EXCLUDED(OP_softplus)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softplus extends DeclarableOp
			public static class softplus extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softplus(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softplus(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softplus position(Long position)
				If True Then
					Return CType(MyBase.position(position), softplus)
				End If
				public softplus getPointer(Long i)
				If True Then
					Return (New softplus(CType(Me, Pointer))).position(position + i)
				End If

																						public softplus()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softplus_bp extends DeclarableOp
			public static class softplus_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softplus_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softplus_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softplus_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), softplus_bp)
				End If
				public softplus_bp getPointer(Long i)
				If True Then
					Return (New softplus_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public softplus_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is RELU activation function implementation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_relu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class relu extends DeclarableOp
			public static class relu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public relu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public relu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public relu position(Long position)
				If True Then
					Return CType(MyBase.position(position), relu)
				End If
				public relu getPointer(Long i)
				If True Then
					Return (New relu(CType(Me, Pointer))).position(position + i)
				End If

																						public relu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class relu_bp extends DeclarableOp
			public static class relu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public relu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public relu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public relu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), relu_bp)
				End If
				public relu_bp getPointer(Long i)
				If True Then
					Return (New relu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public relu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is SELU activation function implementation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_selu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class selu extends DeclarableOp
			public static class selu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public selu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public selu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public selu position(Long position)
				If True Then
					Return CType(MyBase.position(position), selu)
				End If
				public selu getPointer(Long i)
				If True Then
					Return (New selu(CType(Me, Pointer))).position(position + i)
				End If

																						public selu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class selu_bp extends DeclarableOp
			public static class selu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public selu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public selu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public selu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), selu_bp)
				End If
				public selu_bp getPointer(Long i)
				If True Then
					Return (New selu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public selu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Leaky RELU activation function.
			''' Math is: x < 0 ?  alpha * x : x;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lrelu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lrelu extends DeclarableOp
			public static class lrelu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lrelu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lrelu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lrelu position(Long position)
				If True Then
					Return CType(MyBase.position(position), lrelu)
				End If
				public lrelu getPointer(Long i)
				If True Then
					Return (New lrelu(CType(Me, Pointer))).position(position + i)
				End If

																						public lrelu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lrelu_bp extends DeclarableOp
			public static class lrelu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lrelu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lrelu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lrelu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), lrelu_bp)
				End If
				public lrelu_bp getPointer(Long i)
				If True Then
					Return (New lrelu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public lrelu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op is ELU activation function.
			''' Math is: x >= 0 ? x : exp(x) - 1;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_elu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class elu extends DeclarableOp
			public static class elu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public elu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public elu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public elu position(Long position)
				If True Then
					Return CType(MyBase.position(position), elu)
				End If
				public elu getPointer(Long i)
				If True Then
					Return (New elu(CType(Me, Pointer))).position(position + i)
				End If

																						public elu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class elu_bp extends DeclarableOp
			public static class elu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public elu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public elu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public elu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), elu_bp)
				End If
				public elu_bp getPointer(Long i)
				If True Then
					Return (New elu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public elu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Cube activation function.
			''' Math is: x^3
			''' </summary>
	'         #if NOT_EXCLUDED(OP_cube)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cube extends DeclarableOp
			public static class cube extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cube(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cube(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cube position(Long position)
				If True Then
					Return CType(MyBase.position(position), cube)
				End If
				public cube getPointer(Long i)
				If True Then
					Return (New cube(CType(Me, Pointer))).position(position + i)
				End If

																						public cube()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cube_bp extends DeclarableOp
			public static class cube_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cube_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cube_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cube_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), cube_bp)
				End If
				public cube_bp getPointer(Long i)
				If True Then
					Return (New cube_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public cube_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is RectifiedTanh activation function.
			''' Math is: max(0, tanh(x))
			''' </summary>
	'         #if NOT_EXCLUDED(OP_rectifiedtanh)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rectifiedtanh extends DeclarableOp
			public static class rectifiedtanh extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rectifiedtanh(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rectifiedtanh(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rectifiedtanh position(Long position)
				If True Then
					Return CType(MyBase.position(position), rectifiedtanh)
				End If
				public rectifiedtanh getPointer(Long i)
				If True Then
					Return (New rectifiedtanh(CType(Me, Pointer))).position(position + i)
				End If

																						public rectifiedtanh()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rectifiedtanh_bp extends DeclarableOp
			public static class rectifiedtanh_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rectifiedtanh_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rectifiedtanh_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rectifiedtanh_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), rectifiedtanh_bp)
				End If
				public rectifiedtanh_bp getPointer(Long i)
				If True Then
					Return (New rectifiedtanh_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public rectifiedtanh_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is RationalTanh activation function.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_rationaltanh)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rationaltanh extends DeclarableOp
			public static class rationaltanh extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rationaltanh(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rationaltanh(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rationaltanh position(Long position)
				If True Then
					Return CType(MyBase.position(position), rationaltanh)
				End If
				public rationaltanh getPointer(Long i)
				If True Then
					Return (New rationaltanh(CType(Me, Pointer))).position(position + i)
				End If

																						public rationaltanh()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rationaltanh_bp extends DeclarableOp
			public static class rationaltanh_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rationaltanh_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rationaltanh_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rationaltanh_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), rationaltanh_bp)
				End If
				public rationaltanh_bp getPointer(Long i)
				If True Then
					Return (New rationaltanh_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public rationaltanh_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is HardTanh activation function.
			''' Math is: x < -1.0 ? -1.0 : x > 1.0 ? 1.0 : x;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_hardtanh)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hardtanh extends DeclarableOp
			public static class hardtanh extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hardtanh(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hardtanh(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hardtanh position(Long position)
				If True Then
					Return CType(MyBase.position(position), hardtanh)
				End If
				public hardtanh getPointer(Long i)
				If True Then
					Return (New hardtanh(CType(Me, Pointer))).position(position + i)
				End If

																						public hardtanh()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hardtanh_bp extends DeclarableOp
			public static class hardtanh_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hardtanh_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hardtanh_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hardtanh_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), hardtanh_bp)
				End If
				public hardtanh_bp getPointer(Long i)
				If True Then
					Return (New hardtanh_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public hardtanh_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is HardSigmoid activation function.
			''' Math is: min(1, max(0, 0.2 * x + 0.5))
			''' </summary>
	'         #if NOT_EXCLUDED(OP_hardsigmoid)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hardsigmoid extends DeclarableOp
			public static class hardsigmoid extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hardsigmoid(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hardsigmoid(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hardsigmoid position(Long position)
				If True Then
					Return CType(MyBase.position(position), hardsigmoid)
				End If
				public hardsigmoid getPointer(Long i)
				If True Then
					Return (New hardsigmoid(CType(Me, Pointer))).position(position + i)
				End If

																						public hardsigmoid()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hardsigmoid_bp extends DeclarableOp
			public static class hardsigmoid_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hardsigmoid_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hardsigmoid_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hardsigmoid_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), hardsigmoid_bp)
				End If
				public hardsigmoid_bp getPointer(Long i)
				If True Then
					Return (New hardsigmoid_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public hardsigmoid_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Indentity operation. It passes signal umodified in both directions.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_identity)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class identity extends DeclarableOp
			public static class identity extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public identity(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public identity(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public identity position(Long position)
				If True Then
					Return CType(MyBase.position(position), identity)
				End If
				public identity getPointer(Long i)
				If True Then
					Return (New identity(CType(Me, Pointer))).position(position + i)
				End If

														public identity()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class identity_bp extends DeclarableOp
			public static class identity_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public identity_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public identity_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public identity_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), identity_bp)
				End If
				public identity_bp getPointer(Long i)
				If True Then
					Return (New identity_bp(CType(Me, Pointer))).position(position + i)
				End If

														public identity_bp()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Indentity operation. It passes signal umodified in both directions.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_identity_n)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class identity_n extends DeclarableCustomOp
			public static class identity_n extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public identity_n(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public identity_n(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public identity_n position(Long position)
				If True Then
					Return CType(MyBase.position(position), identity_n)
				End If
				public identity_n getPointer(Long i)
				If True Then
					Return (New identity_n(CType(Me, Pointer))).position(position + i)
				End If

																						public identity_n()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is Concatenated RELU implementation.
			''' What happens inside: RELU(Concat((x, -x, {-1})))
			''' 
			''' PLEASE NOTE: Concatenation will double amount of features available in input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_crelu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class crelu extends DeclarableCustomOp
			public static class crelu extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public crelu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public crelu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public crelu position(Long position)
				If True Then
					Return CType(MyBase.position(position), crelu)
				End If
				public crelu getPointer(Long i)
				If True Then
					Return (New crelu(CType(Me, Pointer))).position(position + i)
				End If

																						public crelu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class crelu_bp extends DeclarableCustomOp
			public static class crelu_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public crelu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public crelu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public crelu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), crelu_bp)
				End If
				public crelu_bp getPointer(Long i)
				If True Then
					Return (New crelu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public crelu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is RELU6 activation function implementation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_relu6)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class relu6 extends DeclarableOp
			public static class relu6 extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public relu6(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public relu6(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public relu6 position(Long position)
				If True Then
					Return CType(MyBase.position(position), relu6)
				End If
				public relu6 getPointer(Long i)
				If True Then
					Return (New relu6(CType(Me, Pointer))).position(position + i)
				End If

																						public relu6()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class relu6_bp extends DeclarableOp
			public static class relu6_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public relu6_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public relu6_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public relu6_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), relu6_bp)
				End If
				public relu6_bp getPointer(Long i)
				If True Then
					Return (New relu6_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public relu6_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' Parametric Rectified Linear Unit
			''' f(x) = alpha * x for x < 0, f(x) = x for x >= 0
			''' </summary>
	'         #if NOT_EXCLUDED(OP_prelu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class prelu extends DeclarableOp
			public static class prelu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public prelu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public prelu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public prelu position(Long position)
				If True Then
					Return CType(MyBase.position(position), prelu)
				End If
				public prelu getPointer(Long i)
				If True Then
					Return (New prelu(CType(Me, Pointer))).position(position + i)
				End If

																						public prelu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class prelu_bp extends DeclarableOp
			public static class prelu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public prelu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public prelu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public prelu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), prelu_bp)
				End If
				public prelu_bp getPointer(Long i)
				If True Then
					Return (New prelu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public prelu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Thresholded Rectified Linear Unit
			''' f(x) = x for x > theta, f(x) = 0 otherwise
			''' theta must be >= 0
			''' </summary>
	'         #if NOT_EXCLUDED(OP_thresholdedrelu)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class thresholdedrelu extends DeclarableOp
			public static class thresholdedrelu extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public thresholdedrelu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public thresholdedrelu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public thresholdedrelu position(Long position)
				If True Then
					Return CType(MyBase.position(position), thresholdedrelu)
				End If
				public thresholdedrelu getPointer(Long i)
				If True Then
					Return (New thresholdedrelu(CType(Me, Pointer))).position(position + i)
				End If

																						public thresholdedrelu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class thresholdedrelu_bp extends DeclarableOp
			public static class thresholdedrelu_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public thresholdedrelu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public thresholdedrelu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public thresholdedrelu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), thresholdedrelu_bp)
				End If
				public thresholdedrelu_bp getPointer(Long i)
				If True Then
					Return (New thresholdedrelu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public thresholdedrelu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif





	' #endif

	' Parsed from ops/declarable/headers/boolean.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_BOOLEAN_H
	' #define LIBND4J_HEADERS_BOOLEAN_H

	' #include <ops/declarable/headers/common.h>

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if x < y
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lt_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lt_scalar extends BooleanOp
			public static class lt_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lt_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lt_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lt_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), lt_scalar)
				End If
				public lt_scalar getPointer(Long i)
				If True Then
					Return (New lt_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public lt_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if x > y
			''' </summary>
	'         #if NOT_EXCLUDED(OP_gt_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gt_scalar extends BooleanOp
			public static class gt_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gt_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gt_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gt_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), gt_scalar)
				End If
				public gt_scalar getPointer(Long i)
				If True Then
					Return (New gt_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public gt_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if x <= y
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lte_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lte_scalar extends BooleanOp
			public static class lte_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lte_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lte_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lte_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), lte_scalar)
				End If
				public lte_scalar getPointer(Long i)
				If True Then
					Return (New lte_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public lte_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if x >= y
			''' </summary>
	'         #if NOT_EXCLUDED(OP_gte_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gte_scalar extends BooleanOp
			public static class gte_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gte_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gte_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gte_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), gte_scalar)
				End If
				public gte_scalar getPointer(Long i)
				If True Then
					Return (New gte_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public gte_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if both operands are equal.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_eq_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class eq_scalar extends BooleanOp
			public static class eq_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public eq_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public eq_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public eq_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), eq_scalar)
				End If
				public eq_scalar getPointer(Long i)
				If True Then
					Return (New eq_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public eq_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This is scalar boolean op.
			''' Both operands should be scalars.
			''' 
			''' Returns true if x != y
			''' </summary>
	'         #if NOT_EXCLUDED(OP_neq_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class neq_scalar extends BooleanOp
			public static class neq_scalar extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public neq_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public neq_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public neq_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), neq_scalar)
				End If
				public neq_scalar getPointer(Long i)
				If True Then
					Return (New neq_scalar(CType(Me, Pointer))).position(position + i)
				End If

														public neq_scalar()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 n-dimensional arrays as input, and return 
			''' array of the same shape, with elements, either from x or y, depending on the condition.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_where)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Where extends DeclarableCustomOp
			public static class Where extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Where(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Where(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Where position(Long position)
				If True Then
					Return CType(MyBase.position(position), Where)
				End If
				public Where getPointer(Long i)
				If True Then
					Return (New Where(CType(Me, Pointer))).position(position + i)
				End If

																						public Where()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_where_np)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class where_np extends DeclarableCustomOp
			public static class where_np extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public where_np(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public where_np(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public where_np position(Long position)
				If True Then
					Return CType(MyBase.position(position), where_np)
				End If
				public where_np getPointer(Long i)
				If True Then
					Return (New where_np(CType(Me, Pointer))).position(position + i)
				End If

																						public where_np()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 n-dimensional arrays as input, and return
			''' array of the same shape, with elements, either from x or y, depending on the condition.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_select)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class select extends DeclarableCustomOp
			public static class [select] extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public [select](Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public [select](Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public [select] position(Long position)
				If True Then
					Return CType(MyBase.position(position), [select])
				End If
				public [select] getPointer(Long i)
				If True Then
					Return (New [select](CType(Me, Pointer))).position(position + i)
				End If

																						public [select]()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op takes either 1 argument and 1 scalar
			''' or 1 argument and another comparison array
			''' and runs a pre defined conditional op.
			''' 
			'''  The output of the op is dynamic in size and returns a flat vector of elements
			'''  that return true on the given condition.
			'''  In numpy parlance, most people might understand:
			'''  a[a > 2]
			'''  where a is a numpy array and the condition is true when an element is
			'''  > 2. Libnd4j already implements a number of pre defined conditions.
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_choose)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class choose extends DeclarableCustomOp
			public static class choose extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public choose(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public choose(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public choose position(Long position)
				If True Then
					Return CType(MyBase.position(position), choose)
				End If
				public choose getPointer(Long i)
				If True Then
					Return (New choose(CType(Me, Pointer))).position(position + i)
				End If

																						public choose()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op takes 1 n-dimensional array as input, and returns true if for every adjacent pair we have x[i] <= x[i+1].
			''' </summary>
	'         #if NOT_EXCLUDED(OP_is_non_decreasing)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class is_non_decreasing extends BooleanOp
			public static class is_non_decreasing extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public is_non_decreasing(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public is_non_decreasing(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public is_non_decreasing position(Long position)
				If True Then
					Return CType(MyBase.position(position), is_non_decreasing)
				End If
				public is_non_decreasing getPointer(Long i)
				If True Then
					Return (New is_non_decreasing(CType(Me, Pointer))).position(position + i)
				End If

														public is_non_decreasing()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 1 n-dimensional array as input, and returns true if for every adjacent pair we have x[i] < x[i+1].
			''' </summary>
	'         #if NOT_EXCLUDED(OP_is_strictly_increasing)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class is_strictly_increasing extends BooleanOp
			public static class is_strictly_increasing extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public is_strictly_increasing(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public is_strictly_increasing(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public is_strictly_increasing position(Long position)
				If True Then
					Return CType(MyBase.position(position), is_strictly_increasing)
				End If
				public is_strictly_increasing getPointer(Long i)
				If True Then
					Return (New is_strictly_increasing(CType(Me, Pointer))).position(position + i)
				End If

														public is_strictly_increasing()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 1 n-dimensional array as input, and returns true if input is a numeric array.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_is_numeric_tensor)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class is_numeric_tensor extends BooleanOp
			public static class is_numeric_tensor extends BooleanOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public is_numeric_tensor(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public is_numeric_tensor(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public is_numeric_tensor position(Long position)
				If True Then
					Return CType(MyBase.position(position), is_numeric_tensor)
				End If
				public is_numeric_tensor getPointer(Long i)
				If True Then
					Return (New is_numeric_tensor(CType(Me, Pointer))).position(position + i)
				End If

														public is_numeric_tensor()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
			End If
	'         #endif

			''' 
	'         #if NOT_EXCLUDED(OP_boolean_not)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class boolean_not extends DeclarableOp
			public static class boolean_not extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public boolean_not(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public boolean_not(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public boolean_not position(Long position)
				If True Then
					Return CType(MyBase.position(position), boolean_not)
				End If
				public boolean_not getPointer(Long i)
				If True Then
					Return (New boolean_not(CType(Me, Pointer))).position(position + i)
				End If

														public boolean_not()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/broadcastable.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_BROADCASTABLE_H
	' #define LIBND4J_HEADERS_BROADCASTABLE_H

	' #include <ops/declarable/BroadcastableOp.h>
	' #include <ops/declarable/BroadcastableBoolOp.h>
	' #include <ops/declarable/headers/common.h>
	' #include <ops/declarable/generic/helpers/BroadcastHelper.h>
			' TODO: make broadcastables separate class

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Max(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_maximum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maximum extends BroadcastableOp
			public static class maximum extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maximum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maximum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public maximum position(Long position)
				If True Then
					Return CType(MyBase.position(position), maximum)
				End If
				public maximum getPointer(Long i)
				If True Then
					Return (New maximum(CType(Me, Pointer))).position(position + i)
				End If

																						public maximum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maximum_bp extends DeclarableCustomOp
			public static class maximum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maximum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maximum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public maximum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), maximum_bp)
				End If
				public maximum_bp getPointer(Long i)
				If True Then
					Return (New maximum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public maximum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Min(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_minimum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class minimum extends BroadcastableOp
			public static class minimum extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public minimum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public minimum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public minimum position(Long position)
				If True Then
					Return CType(MyBase.position(position), minimum)
				End If
				public minimum getPointer(Long i)
				If True Then
					Return (New minimum(CType(Me, Pointer))).position(position + i)
				End If

																						public minimum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class minimum_bp extends DeclarableCustomOp
			public static class minimum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public minimum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public minimum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public minimum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), minimum_bp)
				End If
				public minimum_bp getPointer(Long i)
				If True Then
					Return (New minimum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public minimum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Add(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_add)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class add extends BroadcastableOp
			public static class add extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public add(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public add(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public add position(Long position)
				If True Then
					Return CType(MyBase.position(position), add)
				End If
				public add getPointer(Long i)
				If True Then
					Return (New add(CType(Me, Pointer))).position(position + i)
				End If

																						public add()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class add_bp extends DeclarableCustomOp
			public static class add_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public add_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public add_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public add_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), add_bp)
				End If
				public add_bp getPointer(Long i)
				If True Then
					Return (New add_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public add_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Subtract(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_subtract)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class subtract extends BroadcastableOp
			public static class subtract extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public subtract(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public subtract(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public subtract position(Long position)
				If True Then
					Return CType(MyBase.position(position), subtract)
				End If
				public subtract getPointer(Long i)
				If True Then
					Return (New subtract(CType(Me, Pointer))).position(position + i)
				End If

																						public subtract()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class subtract_bp extends DeclarableCustomOp
			public static class subtract_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public subtract_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public subtract_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public subtract_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), subtract_bp)
				End If
				public subtract_bp getPointer(Long i)
				If True Then
					Return (New subtract_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public subtract_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Subtract(Y, X)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reversesubtract)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversesubtract extends BroadcastableOp
			public static class reversesubtract extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversesubtract(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversesubtract(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversesubtract position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversesubtract)
				End If
				public reversesubtract getPointer(Long i)
				If True Then
					Return (New reversesubtract(CType(Me, Pointer))).position(position + i)
				End If

																						public reversesubtract()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversesubtract_bp extends DeclarableCustomOp
			public static class reversesubtract_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversesubtract_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversesubtract_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversesubtract_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversesubtract_bp)
				End If
				public reversesubtract_bp getPointer(Long i)
				If True Then
					Return (New reversesubtract_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reversesubtract_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = ReverseMod(X, Y) == Mod(Y, X)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reversemod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversemod extends BroadcastableOp
			public static class reversemod extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversemod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversemod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversemod position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversemod)
				End If
				public reversemod getPointer(Long i)
				If True Then
					Return (New reversemod(CType(Me, Pointer))).position(position + i)
				End If

																						public reversemod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversemod_bp extends DeclarableCustomOp
			public static class reversemod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversemod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversemod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversemod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversemod_bp)
				End If
				public reversemod_bp getPointer(Long i)
				If True Then
					Return (New reversemod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reversemod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Subtract(X, Y) * Subtract(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_squaredsubtract)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class squaredsubtract extends BroadcastableOp
			public static class squaredsubtract extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public squaredsubtract(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public squaredsubtract(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public squaredsubtract position(Long position)
				If True Then
					Return CType(MyBase.position(position), squaredsubtract)
				End If
				public squaredsubtract getPointer(Long i)
				If True Then
					Return (New squaredsubtract(CType(Me, Pointer))).position(position + i)
				End If

																						public squaredsubtract()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class squaredsubtract_bp extends DeclarableCustomOp
																					public static class squaredsubtract_bp extends DeclarableCustomOp
																					If True Then
																						''' <summary>
																						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
																						public squaredsubtract_bp(Pointer p)
																						If True Then
																							MyBase(p)
																						End If
																						''' <summary>
																						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
																						public squaredsubtract_bp(Long size)
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocateArray(size)
																						End If
																						private native void allocateArray(Long size)
																						public squaredsubtract_bp position(Long position)
																						If True Then
																							Return CType(MyBase.position(position), squaredsubtract_bp)
																						End If
																						public squaredsubtract_bp getPointer(Long i)
																						If True Then
																							Return (New squaredsubtract_bp(CType(Me, Pointer))).position(position + i)
																						End If

																						public squaredsubtract_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
																					End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Multiply(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_multiply)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class multiply extends BroadcastableOp
			public static class multiply extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public multiply(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public multiply(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public multiply position(Long position)
				If True Then
					Return CType(MyBase.position(position), multiply)
				End If
				public multiply getPointer(Long i)
				If True Then
					Return (New multiply(CType(Me, Pointer))).position(position + i)
				End If

																						public multiply()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class multiply_bp extends DeclarableCustomOp
			public static class multiply_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public multiply_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public multiply_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public multiply_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), multiply_bp)
				End If
				public multiply_bp getPointer(Long i)
				If True Then
					Return (New multiply_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public multiply_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Divide(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_divide)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class divide extends BroadcastableOp
			public static class divide extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public divide(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public divide(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public divide position(Long position)
				If True Then
					Return CType(MyBase.position(position), divide)
				End If
				public divide getPointer(Long i)
				If True Then
					Return (New divide(CType(Me, Pointer))).position(position + i)
				End If

																						public divide()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class divide_bp extends DeclarableCustomOp
			public static class divide_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public divide_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public divide_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public divide_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), divide_bp)
				End If
				public divide_bp getPointer(Long i)
				If True Then
					Return (New divide_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public divide_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Divide(X, Y) with exception, 0 if Y = 0
			''' </summary>
	'         #if NOT_EXCLUDED(OP_divide_no_nan)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class divide_no_nan extends BroadcastableOp
			public static class divide_no_nan extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public divide_no_nan(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public divide_no_nan(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public divide_no_nan position(Long position)
				If True Then
					Return CType(MyBase.position(position), divide_no_nan)
				End If
				public divide_no_nan getPointer(Long i)
				If True Then
					Return (New divide_no_nan(CType(Me, Pointer))).position(position + i)
				End If

																						public divide_no_nan()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif
			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Divide(Y, x)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reversedivide)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversedivide extends BroadcastableOp
			public static class reversedivide extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversedivide(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversedivide(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversedivide position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversedivide)
				End If
				public reversedivide getPointer(Long i)
				If True Then
					Return (New reversedivide(CType(Me, Pointer))).position(position + i)
				End If

																						public reversedivide()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reversedivide_bp extends DeclarableCustomOp
			public static class reversedivide_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reversedivide_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reversedivide_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reversedivide_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reversedivide_bp)
				End If
				public reversedivide_bp getPointer(Long i)
				If True Then
					Return (New reversedivide_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reversedivide_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = FloorMod(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_floormod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class floormod extends BroadcastableOp
			public static class floormod extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public floormod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public floormod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public floormod position(Long position)
				If True Then
					Return CType(MyBase.position(position), floormod)
				End If
				public floormod getPointer(Long i)
				If True Then
					Return (New floormod(CType(Me, Pointer))).position(position + i)
				End If

																						public floormod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class floormod_bp extends DeclarableCustomOp
			public static class floormod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public floormod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public floormod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public floormod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), floormod_bp)
				End If
				public floormod_bp getPointer(Long i)
				If True Then
					Return (New floormod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public floormod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_mod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mod extends BroadcastableOp
			public static class [mod] extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public [mod](Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public [mod](Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public [mod] position(Long position)
				If True Then
					Return CType(MyBase.position(position), [mod])
				End If
				public [mod] getPointer(Long i)
				If True Then
					Return (New [mod](CType(Me, Pointer))).position(position + i)
				End If

																						public [mod]()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mod_bp extends DeclarableCustomOp
			public static class mod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), mod_bp)
				End If
				public mod_bp getPointer(Long i)
				If True Then
					Return (New mod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public mod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = FloorDiv(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_floordiv)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class floordiv extends BroadcastableOp
			public static class floordiv extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public floordiv(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public floordiv(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public floordiv position(Long position)
				If True Then
					Return CType(MyBase.position(position), floordiv)
				End If
				public floordiv getPointer(Long i)
				If True Then
					Return (New floordiv(CType(Me, Pointer))).position(position + i)
				End If

																						public floordiv()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class floordiv_bp extends DeclarableCustomOp
																					public static class floordiv_bp extends DeclarableCustomOp
																					If True Then
																						''' <summary>
																						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
																						public floordiv_bp(Pointer p)
																						If True Then
																							MyBase(p)
																						End If
																						''' <summary>
																						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
																						public floordiv_bp(Long size)
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocateArray(size)
																						End If
																						private native void allocateArray(Long size)
																						public floordiv_bp position(Long position)
																						If True Then
																							Return CType(MyBase.position(position), floordiv_bp)
																						End If
																						public floordiv_bp getPointer(Long i)
																						If True Then
																							Return (New floordiv_bp(CType(Me, Pointer))).position(position + i)
																						End If

																						public floordiv_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
																					End If
																					'         #endif

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Divide(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_realdiv)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class realdiv extends BroadcastableOp
			public static class realdiv extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public realdiv(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public realdiv(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public realdiv position(Long position)
				If True Then
					Return CType(MyBase.position(position), realdiv)
				End If
				public realdiv getPointer(Long i)
				If True Then
					Return (New realdiv(CType(Me, Pointer))).position(position + i)
				End If

																						public realdiv()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class realdiv_bp extends DeclarableCustomOp
			public static class realdiv_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public realdiv_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public realdiv_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public realdiv_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), realdiv_bp)
				End If
				public realdiv_bp getPointer(Long i)
				If True Then
					Return (New realdiv_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public realdiv_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' 
			''' 
			''' <summary>
			''' \tparam T
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class truncatediv extends BroadcastableOp
			public static class truncatediv extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public truncatediv(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public truncatediv(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public truncatediv position(Long position)
				If True Then
					Return CType(MyBase.position(position), truncatediv)
				End If
				public truncatediv getPointer(Long i)
				If True Then
					Return (New truncatediv(CType(Me, Pointer))).position(position + i)
				End If

																						public truncatediv()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If

			''' <summary>
			''' This is one of auto-broadcastable operations. It accepts 2 operands, and operation is applied based on their shapes:
			''' 1) if shapes are equal that's pairwise operation, result will have the same shape.
			''' 2) if shape X is scalar and shape Y is array - result will have shape equal to Y.
			''' 3) if shape X is array and shape Y is scalar - result will have shape equal to X.
			''' 4) if shape X and Y are both arrays, but shapes aren't equal - result shape will be broadcast result.
			''' 
			''' This operation returns Z = Assign(X, Y)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_assign)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class assign extends BroadcastableOp
			public static class assign extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public assign(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public assign(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public assign position(Long position)
				If True Then
					Return CType(MyBase.position(position), assign)
				End If
				public assign getPointer(Long i)
				If True Then
					Return (New assign(CType(Me, Pointer))).position(position + i)
				End If

																						public assign()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class assign_bp extends DeclarableCustomOp
			public static class assign_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public assign_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public assign_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public assign_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), assign_bp)
				End If
				public assign_bp getPointer(Long i)
				If True Then
					Return (New assign_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public assign_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_meshgrid)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class meshgrid extends DeclarableCustomOp
			public static class meshgrid extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public meshgrid(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public meshgrid(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public meshgrid position(Long position)
				If True Then
					Return CType(MyBase.position(position), meshgrid)
				End If
				public meshgrid getPointer(Long i)
				If True Then
					Return (New meshgrid(CType(Me, Pointer))).position(position + i)
				End If

																						public meshgrid()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			 ''' <summary>
			 ''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			 ''' Math is: _x == _y ? (T) 1.0f : (T) 0.0f;
			 ''' 
			 ''' </summary>
	'         #if NOT_EXCLUDED(OP_equals)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class equals extends BroadcastableBoolOp
			public static class equals extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Equals(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Equals(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public equals position(Long position)
				If True Then
					Return CType(MyBase.position(position), equals)
				End If
				public equals getPointer(Long i)
				If True Then
					Return (New Equals(CType(Me, Pointer))).position(position + i)
				End If

																						public equals()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			''' Math is: _x != _y ? (T) 1.0f : (T) 0.0f;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_not_equals)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class not_equals extends BroadcastableBoolOp
			public static class not_equals extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public not_equals(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public not_equals(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public not_equals position(Long position)
				If True Then
					Return CType(MyBase.position(position), not_equals)
				End If
				public not_equals getPointer(Long i)
				If True Then
					Return (New not_equals(CType(Me, Pointer))).position(position + i)
				End If

																						public not_equals()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			''' Math is: _x <= _y ? (T) 1.0f : (T) 0.0f;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_less_equal)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class less_equal extends BroadcastableBoolOp
			public static class less_equal extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public less_equal(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public less_equal(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public less_equal position(Long position)
				If True Then
					Return CType(MyBase.position(position), less_equal)
				End If
				public less_equal getPointer(Long i)
				If True Then
					Return (New less_equal(CType(Me, Pointer))).position(position + i)
				End If

																						public less_equal()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			''' Math is: _x >= _y ? (T) 1.0f : (T) 0.0f;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_greater_equal)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class greater_equal extends BroadcastableBoolOp
			public static class greater_equal extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public greater_equal(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public greater_equal(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public greater_equal position(Long position)
				If True Then
					Return CType(MyBase.position(position), greater_equal)
				End If
				public greater_equal getPointer(Long i)
				If True Then
					Return (New greater_equal(CType(Me, Pointer))).position(position + i)
				End If

																						public greater_equal()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			''' Math is: _x < _y ? (T) 1.0f : (T) 0.0f;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_less)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class less extends BroadcastableBoolOp
			public static class less extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public less(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public less(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public less position(Long position)
				If True Then
					Return CType(MyBase.position(position), less)
				End If
				public less getPointer(Long i)
				If True Then
					Return (New less(CType(Me, Pointer))).position(position + i)
				End If

																						public less()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This op takes 2 equally shaped arrays as input, and provides binary matrix as output.
			''' Math is: _x > _y ? (T) 1.0f : (T) 0.0f;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_greater)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class greater extends BroadcastableBoolOp
			public static class greater extends BroadcastableBoolOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public greater(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public greater(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public greater position(Long position)
				If True Then
					Return CType(MyBase.position(position), greater)
				End If
				public greater getPointer(Long i)
				If True Then
					Return (New greater(CType(Me, Pointer))).position(position + i)
				End If

																						public greater()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' 
	'         #if NOT_EXCLUDED(OP_boolean_and)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class boolean_and extends BroadcastableOp
			public static class boolean_and extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public boolean_and(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public boolean_and(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public boolean_and position(Long position)
				If True Then
					Return CType(MyBase.position(position), boolean_and)
				End If
				public boolean_and getPointer(Long i)
				If True Then
					Return (New boolean_and(CType(Me, Pointer))).position(position + i)
				End If

																						public boolean_and()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' 
	'         #if NOT_EXCLUDED(OP_boolean_or)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class boolean_or extends BroadcastableOp
			public static class boolean_or extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public boolean_or(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public boolean_or(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public boolean_or position(Long position)
				If True Then
					Return CType(MyBase.position(position), boolean_or)
				End If
				public boolean_or getPointer(Long i)
				If True Then
					Return (New boolean_or(CType(Me, Pointer))).position(position + i)
				End If

																						public boolean_or()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' 
	'         #if NOT_EXCLUDED(OP_boolean_xor)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class boolean_xor extends BroadcastableOp
			public static class boolean_xor extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public boolean_xor(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public boolean_xor(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public boolean_xor position(Long position)
				If True Then
					Return CType(MyBase.position(position), boolean_xor)
				End If
				public boolean_xor getPointer(Long i)
				If True Then
					Return (New boolean_xor(CType(Me, Pointer))).position(position + i)
				End If

																						public boolean_xor()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation performs calculation of percentile of input array along given axises
			''' 
			''' Input - tensor with rank N > 0
			''' Output - tensor with rank (N - length(axis)) or scalar if number of Integer arguments is zero
			''' Float arguments:
			'''   0: percentile (scalar) in range [0,100] (inclusively)
			'''   1: interpolation (optional), possible values are 0-"lower", 1-"higher", 2-"nearest"(default)
			'''   2: keepDims (optional), if it is non zero, then unities are kept in reduced resulting shape of output array, default is 0
			''' Integer arguments - axis - the sequence of axises to calculate percentile along, if sequence is empty then calculate percentile for whole input tensor and return result as scalar
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_percentile)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class percentile extends DeclarableCustomOp
			public static class percentile extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public percentile(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public percentile(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public percentile position(Long position)
				If True Then
					Return CType(MyBase.position(position), percentile)
				End If
				public percentile getPointer(Long i)
				If True Then
					Return (New percentile(CType(Me, Pointer))).position(position + i)
				End If

																						public percentile()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' Special atan2 op impl for TF's args order
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_tf_atan2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tf_atan2 extends BroadcastableOp
			public static class tf_atan2 extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tf_atan2(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tf_atan2(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tf_atan2 position(Long position)
				If True Then
					Return CType(MyBase.position(position), tf_atan2)
				End If
				public tf_atan2 getPointer(Long i)
				If True Then
					Return (New tf_atan2(CType(Me, Pointer))).position(position + i)
				End If

																						public tf_atan2()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' Broadcastable pow implementation
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_Pow)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Pow extends BroadcastableOp
			public static class Pow extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Pow(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Pow(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Pow position(Long position)
				If True Then
					Return CType(MyBase.position(position), Pow)
				End If
				public Pow getPointer(Long i)
				If True Then
					Return (New Pow(CType(Me, Pointer))).position(position + i)
				End If

																						public Pow()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Pow_bp extends DeclarableCustomOp
			public static class Pow_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Pow_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Pow_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Pow_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), Pow_bp)
				End If
				public Pow_bp getPointer(Long i)
				If True Then
					Return (New Pow_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public Pow_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Broadcastable igamma implementation
			''' 
			''' igamma(a, x) = gamma(а, x) / Gamma(a) - Gamma distribution function P(a,x)
			''' Gamma(a) = int from 0 to infinity { t ^ {a - 1} e^{-t}dt }
			''' gamma(a, x) = int from 0 to x { t ^ {a - 1} e^{-t}dt }
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_igamma)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class igamma extends BroadcastableOp
					public static class igamma extends BroadcastableOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public igamma(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public igamma(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public igamma position(Long position)
						If True Then
							Return CType(MyBase.position(position), igamma)
						End If
						public igamma getPointer(Long i)
						If True Then
							Return (New igamma(CType(Me, Pointer))).position(position + i)
						End If

																						public igamma()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
					End If
	'         #endif
			''' <summary>
			''' Broadcastable igammac implementation
			''' igammac(a, x) = Gamma(a,x)/Gamma(а) - Gamma distribution function Q(a,x)
			''' Gamma(a) = int from 0 to infinity { t ^ {a - 1} e^{-t}dt }
			''' Gamma(a, x) = int from x to infinity { t ^ {a - 1} e^{-t}dt }
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_igammac)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class igammac extends BroadcastableOp
					public static class igammac extends BroadcastableOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public igammac(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public igammac(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public igammac position(Long position)
						If True Then
							Return CType(MyBase.position(position), igammac)
						End If
						public igammac getPointer(Long i)
						If True Then
							Return (New igammac(CType(Me, Pointer))).position(position + i)
						End If

																						public igammac()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
					End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/convo.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'
	'

	' #ifndef LIBND4J_HEADERS_CONVOL_H
	' #define LIBND4J_HEADERS_CONVOL_H

	' #include <ops/declarable/headers/common.h>

			''' <summary>
			''' 1D temporal convolution implementation
			''' Expected input:
			''' x: 3D array
			''' weight: 3D Array
			''' bias: optional vector
			''' 
			''' Int args:
			''' 0: kernel
			''' 1: stride
			''' 2: padding
			''' </summary>
	'         #if NOT_EXCLUDED(OP_conv1d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv1d extends DeclarableCustomOp
			public static class conv1d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv1d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv1d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv1d position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv1d)
				End If
				public conv1d getPointer(Long i)
				If True Then
					Return (New conv1d(CType(Me, Pointer))).position(position + i)
				End If

																						public conv1d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv1d_bp extends DeclarableCustomOp
			public static class conv1d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv1d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv1d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv1d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv1d_bp)
				End If
				public conv1d_bp getPointer(Long i)
				If True Then
					Return (New conv1d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public conv1d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' 2D convolution implementation
			''' Expected input:
			''' x: 4D array
			''' weight: 4D Array
			''' bias: optional vector, length of outputChannels
			''' 
			''' IntArgs:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: same mode:   1 true, 0 false
			''' 9: data format: 1 NHWC, 0 NCHW
			''' </summary>
	'         #if NOT_EXCLUDED(OP_conv2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv2d extends DeclarableCustomOp
			public static class conv2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv2d)
				End If
				public conv2d getPointer(Long i)
				If True Then
					Return (New conv2d(CType(Me, Pointer))).position(position + i)
				End If

																						public conv2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv2d_bp extends DeclarableCustomOp
			public static class conv2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv2d_bp)
				End If
				public conv2d_bp getPointer(Long i)
				If True Then
					Return (New conv2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public conv2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv2d_input_bp extends DeclarableCustomOp
			public static class conv2d_input_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv2d_input_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv2d_input_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv2d_input_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv2d_input_bp)
				End If
				public conv2d_input_bp getPointer(Long i)
				If True Then
					Return (New conv2d_input_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public conv2d_input_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Depthwise convolution2d op:
			''' Expected inputs:
			''' x: 4D array, NCHW format
			''' weightsDepth: 4D array,
			''' weightsPointwise: optional, 4D array
			''' bias: optional, vector
			''' </summary>
	'         #if NOT_EXCLUDED(OP_sconv2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sconv2d extends DeclarableCustomOp
			public static class sconv2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sconv2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sconv2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sconv2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), sconv2d)
				End If
				public sconv2d getPointer(Long i)
				If True Then
					Return (New sconv2d(CType(Me, Pointer))).position(position + i)
				End If

																						public sconv2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sconv2d_bp extends DeclarableCustomOp
			public static class sconv2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sconv2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sconv2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sconv2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), sconv2d_bp)
				End If
				public sconv2d_bp getPointer(Long i)
				If True Then
					Return (New sconv2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public sconv2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' 2D deconvolution implementation
			''' 
			''' IntArgs:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: same mode: 0 false, 1 true
			''' </summary>
	'         #if NOT_EXCLUDED(OP_deconv2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class deconv2d extends DeclarableCustomOp
			public static class deconv2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public deconv2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public deconv2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public deconv2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), deconv2d)
				End If
				public deconv2d getPointer(Long i)
				If True Then
					Return (New deconv2d(CType(Me, Pointer))).position(position + i)
				End If

																						public deconv2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class deconv2d_bp extends DeclarableCustomOp
			public static class deconv2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public deconv2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public deconv2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public deconv2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), deconv2d_bp)
				End If
				public deconv2d_bp getPointer(Long i)
				If True Then
					Return (New deconv2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public deconv2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' 3D deconvolution implementation
			''' 
			''' IntArgs:
			''' 0:  filter(kernel) depth
			''' 1:  filter(kernel) height
			''' 2:  filter(kernel) width
			''' 3:  strides depth
			''' 4:  strides height
			''' 5:  strides width
			''' 6:  paddings depth
			''' 7:  paddings height
			''' 8:  paddings width
			''' 9:  dilations depth
			''' 10: dilations height
			''' 11: dilations width
			''' 12: same mode: 0 false, 1 true
			''' 13: data format (optional): 0-NDHWC, 1-NCDHW, default is 1
			''' </summary>

	'         #if NOT_EXCLUDED(OP_deconv3d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class deconv3d extends DeclarableCustomOp
			public static class deconv3d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public deconv3d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public deconv3d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public deconv3d position(Long position)
				If True Then
					Return CType(MyBase.position(position), deconv3d)
				End If
				public deconv3d getPointer(Long i)
				If True Then
					Return (New deconv3d(CType(Me, Pointer))).position(position + i)
				End If

																						public deconv3d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class deconv3d_bp extends DeclarableCustomOp
			public static class deconv3d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public deconv3d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public deconv3d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public deconv3d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), deconv3d_bp)
				End If
				public deconv3d_bp getPointer(Long i)
				If True Then
					Return (New deconv3d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public deconv3d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This op implements max pooling for convolution networks.
			''' Expected Input: 4D array, NCHW format.
			''' 
			''' IntArgs:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: same mode: 0 false, 1 true
			''' </summary>
	'         #if NOT_EXCLUDED(OP_maxpool2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maxpool2d extends DeclarableCustomOp
			public static class maxpool2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maxpool2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maxpool2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public maxpool2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), maxpool2d)
				End If
				public maxpool2d getPointer(Long i)
				If True Then
					Return (New maxpool2d(CType(Me, Pointer))).position(position + i)
				End If

																						public maxpool2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maxpool2d_bp extends DeclarableCustomOp
			public static class maxpool2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maxpool2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maxpool2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public maxpool2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), maxpool2d_bp)
				End If
				public maxpool2d_bp getPointer(Long i)
				If True Then
					Return (New maxpool2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public maxpool2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op implements average pooling for convolution networks.
			''' Expected Input: 4D array, NCHW format.
			''' 
			''' IntArgs:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: same mode: 0 false, 1 true
			''' </summary>
	'         #if NOT_EXCLUDED(OP_avgpool2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class avgpool2d extends DeclarableCustomOp
			public static class avgpool2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public avgpool2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public avgpool2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public avgpool2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), avgpool2d)
				End If
				public avgpool2d getPointer(Long i)
				If True Then
					Return (New avgpool2d(CType(Me, Pointer))).position(position + i)
				End If

																						public avgpool2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class avgpool2d_bp extends DeclarableCustomOp
			public static class avgpool2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public avgpool2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public avgpool2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public avgpool2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), avgpool2d_bp)
				End If
				public avgpool2d_bp getPointer(Long i)
				If True Then
					Return (New avgpool2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public avgpool2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op implements pnorm pooling for convolution networks.
			''' Expected Input: 4D array, NCHW format.
			''' 
			''' IntArgs:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: same mode: 0 false, 1 true
			''' 9: p for p-norm
			''' </summary>
	'         #if NOT_EXCLUDED(OP_pnormpool2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class pnormpool2d extends DeclarableCustomOp
			public static class pnormpool2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public pnormpool2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public pnormpool2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public pnormpool2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), pnormpool2d)
				End If
				public pnormpool2d getPointer(Long i)
				If True Then
					Return (New pnormpool2d(CType(Me, Pointer))).position(position + i)
				End If

																						public pnormpool2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class pnormpool2d_bp extends DeclarableCustomOp
			public static class pnormpool2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public pnormpool2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public pnormpool2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public pnormpool2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), pnormpool2d_bp)
				End If
				public pnormpool2d_bp getPointer(Long i)
				If True Then
					Return (New pnormpool2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public pnormpool2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op implements im2col algorithm, widely used in convolution neural networks
			''' Input: 4D input expected
			''' 
			''' Int args:
			''' 0: kernel height
			''' 1: kernel width
			''' 2: stride height
			''' 3: stride width
			''' 4: padding height
			''' 5: padding width
			''' 6: dilation height
			''' 7: dilation width
			''' 8: isSameMode
			''' </summary>
	'         #if NOT_EXCLUDED(OP_im2col)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class im2col extends DeclarableCustomOp
			public static class im2col extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public im2col(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public im2col(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public im2col position(Long position)
				If True Then
					Return CType(MyBase.position(position), im2col)
				End If
				public im2col getPointer(Long i)
				If True Then
					Return (New im2col(CType(Me, Pointer))).position(position + i)
				End If

																						public im2col()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class im2col_bp extends DeclarableCustomOp
			public static class im2col_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public im2col_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public im2col_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public im2col_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), im2col_bp)
				End If
				public im2col_bp getPointer(Long i)
				If True Then
					Return (New im2col_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public im2col_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op implements col2im algorithm, widely used in convolution neural networks
			''' Input: 6D input expected (like output of im2col op)
			''' 
			''' Int args:
			''' 0: stride height
			''' 1: stride width
			''' 2: padding height
			''' 3: padding width
			''' 4: image height
			''' 5: image width
			''' 6: dilation height
			''' 7: dilation width
			''' </summary>
	'         #if NOT_EXCLUDED(OP_col2im)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class col2im extends DeclarableCustomOp
			public static class col2im extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public col2im(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public col2im(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public col2im position(Long position)
				If True Then
					Return CType(MyBase.position(position), col2im)
				End If
				public col2im getPointer(Long i)
				If True Then
					Return (New col2im(CType(Me, Pointer))).position(position + i)
				End If

																						public col2im()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Expected input: 4D array
			''' 
			''' IntArgs:
			''' 0: scale factor for rows (height)
			''' 1: scale factor for columns (width)
			''' 2: data format: 0 NHWC (default), 1 NCHW
			''' </summary>
	'         #if NOT_EXCLUDED(OP_upsampling2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class upsampling2d extends DeclarableCustomOp
			public static class upsampling2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public upsampling2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public upsampling2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public upsampling2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), upsampling2d)
				End If
				public upsampling2d getPointer(Long i)
				If True Then
					Return (New upsampling2d(CType(Me, Pointer))).position(position + i)
				End If

																						public upsampling2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class upsampling2d_bp extends DeclarableCustomOp
			public static class upsampling2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public upsampling2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public upsampling2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public upsampling2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), upsampling2d_bp)
				End If
				public upsampling2d_bp getPointer(Long i)
				If True Then
					Return (New upsampling2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public upsampling2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Expected input: 4D array
			''' 
			''' IntArgs:
			''' 0: scale factor for depth
			''' 1: scale factor for rows (height)
			''' 2: scale factor for columns (width)
			''' 3: data format: 0 NDHWC (default), 1 NCDHW
			''' </summary>
	'         #if NOT_EXCLUDED(OP_upsampling3d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class upsampling3d extends DeclarableCustomOp
			public static class upsampling3d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public upsampling3d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public upsampling3d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public upsampling3d position(Long position)
				If True Then
					Return CType(MyBase.position(position), upsampling3d)
				End If
				public upsampling3d getPointer(Long i)
				If True Then
					Return (New upsampling3d(CType(Me, Pointer))).position(position + i)
				End If

																						public upsampling3d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class upsampling3d_bp extends DeclarableCustomOp
			public static class upsampling3d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public upsampling3d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public upsampling3d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public upsampling3d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), upsampling3d_bp)
				End If
				public upsampling3d_bp getPointer(Long i)
				If True Then
					Return (New upsampling3d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public upsampling3d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op produces binary matrix wrt to target dimension.
			''' Maximum value within each TAD is replaced with 1, other values are set to true.
			''' 
			''' Int args:
			''' 0: axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_ismax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class ismax extends DeclarableOp
			public static class ismax extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ismax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ismax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ismax position(Long position)
				If True Then
					Return CType(MyBase.position(position), ismax)
				End If
				public ismax getPointer(Long i)
				If True Then
					Return (New ismax(CType(Me, Pointer))).position(position + i)
				End If

																						public ismax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Dilation2D op
			''' 
			''' Int args:
			''' 0: isSameMode
			''' </summary>
	'         #if NOT_EXCLUDED(OP_dilation2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dilation2d extends DeclarableCustomOp
			public static class dilation2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dilation2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dilation2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dilation2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), dilation2d)
				End If
				public dilation2d getPointer(Long i)
				If True Then
					Return (New dilation2d(CType(Me, Pointer))).position(position + i)
				End If

																						public dilation2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_conv3dnew)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv3dnew extends DeclarableCustomOp
			public static class conv3dnew extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv3dnew(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv3dnew(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public conv3dnew position(long position)
				If True Then
					Return CType(MyBase.position(position), conv3dnew)
				End If
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public conv3dnew getPointer(long i)
				If True Then
					Return (New conv3dnew(CType(Me, Pointer))).position(position + i)
				End If

																						public conv3dnew()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class conv3dnew_bp extends DeclarableCustomOp
			public static class conv3dnew_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public conv3dnew_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public conv3dnew_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public conv3dnew_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), conv3dnew_bp)
				End If
				public conv3dnew_bp getPointer(Long i)
				If True Then
					Return (New conv3dnew_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public conv3dnew_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_avgpool3dnew)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class avgpool3dnew extends DeclarableCustomOp
			public static class avgpool3dnew extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public avgpool3dnew(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public avgpool3dnew(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public avgpool3dnew position(long position)
				If True Then
					Return CType(MyBase.position(position), avgpool3dnew)
				End If
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public avgpool3dnew getPointer(long i)
				If True Then
					Return (New avgpool3dnew(CType(Me, Pointer))).position(position + i)
				End If

																						public avgpool3dnew()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class avgpool3dnew_bp extends DeclarableCustomOp
			public static class avgpool3dnew_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public avgpool3dnew_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public avgpool3dnew_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public avgpool3dnew_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), avgpool3dnew_bp)
				End If
				public avgpool3dnew_bp getPointer(Long i)
				If True Then
					Return (New avgpool3dnew_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public avgpool3dnew_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_maxpool3dnew)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maxpool3dnew extends DeclarableCustomOp
			public static class maxpool3dnew extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maxpool3dnew(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maxpool3dnew(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public maxpool3dnew position(long position)
				If True Then
					Return CType(MyBase.position(position), maxpool3dnew)
				End If
'JAVA TO VB CONVERTER TODO TASK: The following line could not be converted:
				@Override public maxpool3dnew getPointer(long i)
				If True Then
					Return (New maxpool3dnew(CType(Me, Pointer))).position(position + i)
				End If

																						public maxpool3dnew()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class maxpool3dnew_bp extends DeclarableCustomOp
			public static class maxpool3dnew_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public maxpool3dnew_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public maxpool3dnew_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public maxpool3dnew_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), maxpool3dnew_bp)
				End If
				public maxpool3dnew_bp getPointer(Long i)
				If True Then
					Return (New maxpool3dnew_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public maxpool3dnew_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op same as maxpool2d with a variant to return a matrix of indexes for max values
			''' 
			''' Input - 4D tensor
			''' Output:
			'''     0 - 4D tensor as input
			'''     1 - 4D tensor with max value indexes
			''' 
			''' Int params:
			'''   9 int with 2x4 vectors and 1 bool value
			''' </summary>
	'         #if NOT_EXCLUDED(OP_max_pool_woth_argmax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class max_pool_with_argmax extends DeclarableCustomOp
			public static class max_pool_with_argmax extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public max_pool_with_argmax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public max_pool_with_argmax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public max_pool_with_argmax position(Long position)
				If True Then
					Return CType(MyBase.position(position), max_pool_with_argmax)
				End If
				public max_pool_with_argmax getPointer(Long i)
				If True Then
					Return (New max_pool_with_argmax(CType(Me, Pointer))).position(position + i)
				End If

																						public max_pool_with_argmax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


	'         #if NOT_EXCLUDED(OP_depthwise_conv2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class depthwise_conv2d extends DeclarableCustomOp
			public static class depthwise_conv2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public depthwise_conv2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public depthwise_conv2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public depthwise_conv2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), depthwise_conv2d)
				End If
				public depthwise_conv2d getPointer(Long i)
				If True Then
					Return (New depthwise_conv2d(CType(Me, Pointer))).position(position + i)
				End If

																						public depthwise_conv2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class depthwise_conv2d_bp extends DeclarableCustomOp
			public static class depthwise_conv2d_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public depthwise_conv2d_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public depthwise_conv2d_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public depthwise_conv2d_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), depthwise_conv2d_bp)
				End If
				public depthwise_conv2d_bp getPointer(Long i)
				If True Then
					Return (New depthwise_conv2d_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public depthwise_conv2d_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' point-wise 2D convolution
			''' Expected input:
			''' x: 4D array
			''' weight: 4D Array [1,  1,  iC, oC] (NHWC) or [oC, iC,  1,  1] (NCHW)
			''' bias: optional vector, length of oC
			''' 
			''' IntArgs:
			''' 0: data format: 1 NHWC, 0 NCHW (optional, by default = NHWC)
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class pointwise_conv2d extends DeclarableCustomOp
			public static class pointwise_conv2d extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public pointwise_conv2d(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public pointwise_conv2d(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public pointwise_conv2d position(Long position)
				If True Then
					Return CType(MyBase.position(position), pointwise_conv2d)
				End If
				public pointwise_conv2d getPointer(Long i)
				If True Then
					Return (New pointwise_conv2d(CType(Me, Pointer))).position(position + i)
				End If

																						public pointwise_conv2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class deconv2d_tf extends DeclarableCustomOp
			public static class deconv2d_tf extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public deconv2d_tf(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public deconv2d_tf(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public deconv2d_tf position(Long position)
				If True Then
					Return CType(MyBase.position(position), deconv2d_tf)
				End If
				public deconv2d_tf getPointer(Long i)
				If True Then
					Return (New deconv2d_tf(CType(Me, Pointer))).position(position + i)
				End If

																						public deconv2d_tf()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If





	' #endif

	' Parsed from ops/declarable/headers/list.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_LIST_H
	' #define LIBND4J_HEADERS_LIST_H

	' #include <ops/declarable/headers/common.h>
			' list operations, basically all around NDArrayList

			''' <summary>
			''' This operations puts given NDArray into (optionally) given NDArrayList. 
			''' If no NDArrayList was provided - new one will be created
			''' </summary>
	'         #if NOT_EXCLUDED(OP_write_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class write_list extends DeclarableListOp
			public static class write_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public write_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public write_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public write_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), write_list)
				End If
				public write_list getPointer(Long i)
				If True Then
					Return (New write_list(CType(Me, Pointer))).position(position + i)
				End If

																	public write_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation concatenates given NDArrayList, and returns NDArray as result
			''' </summary>
	'         #if NOT_EXCLUDED(OP_stack_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class stack_list extends DeclarableListOp
			public static class stack_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public stack_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public stack_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public stack_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), stack_list)
				End If
				public stack_list getPointer(Long i)
				If True Then
					Return (New stack_list(CType(Me, Pointer))).position(position + i)
				End If

																	public stack_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operations selects specified index fron NDArrayList and returns it as NDArray
			''' Expected arguments:
			''' x: non-empty list
			''' indices: optional, scalar with index
			''' 
			''' Int args:
			''' optional, index
			''' </summary>
	'         #if NOT_EXCLUDED(OP_read_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class read_list extends DeclarableListOp
			public static class read_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public read_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public read_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public read_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), read_list)
				End If
				public read_list getPointer(Long i)
				If True Then
					Return (New read_list(CType(Me, Pointer))).position(position + i)
				End If

																	public read_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operations selects specified indices fron NDArrayList and returns them as NDArray
			''' Expected arguments:
			''' x: non-empty list
			''' indices: optional, vector with indices
			''' 
			''' Int args:
			''' optional, indices
			''' </summary>
	'         #if NOT_EXCLUDED(OP_pick_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class pick_list extends DeclarableListOp
			public static class pick_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public pick_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public pick_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public pick_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), pick_list)
				End If
				public pick_list getPointer(Long i)
				If True Then
					Return (New pick_list(CType(Me, Pointer))).position(position + i)
				End If

																	public pick_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operations returns scalar, with number of existing arrays within given NDArrayList
			''' Expected arguments:
			''' x: list
			''' </summary>
	'         #if NOT_EXCLUDED(OP_size_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class size_list extends DeclarableListOp
			public static class size_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public size_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public size_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public size_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), size_list)
				End If
				public size_list getPointer(Long i)
				If True Then
					Return (New size_list(CType(Me, Pointer))).position(position + i)
				End If

																	public size_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation creates new empty NDArrayList
			''' </summary>
	'         #if NOT_EXCLUDED(OP_create_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class create_list extends DeclarableListOp
			public static class create_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public create_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public create_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public create_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), create_list)
				End If
				public create_list getPointer(Long i)
				If True Then
					Return (New create_list(CType(Me, Pointer))).position(position + i)
				End If

																	public create_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation unpacks given NDArray into specified NDArrayList wrt specified indices
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_list extends DeclarableListOp
			public static class scatter_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_list)
				End If
				public scatter_list getPointer(Long i)
				If True Then
					Return (New scatter_list(CType(Me, Pointer))).position(position + i)
				End If

																	public scatter_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation splits given NDArray into chunks, and stores them into given NDArrayList wert sizes
			''' Expected arguments:
			''' list: optional, NDArrayList. if not available - new NDArrayList will be created
			''' array: array to be split
			''' sizes: vector with sizes for each chunk
			''' </summary>
	'         #if NOT_EXCLUDED(OP_split_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class split_list extends DeclarableListOp
			public static class split_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public split_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public split_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public split_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), split_list)
				End If
				public split_list getPointer(Long i)
				If True Then
					Return (New split_list(CType(Me, Pointer))).position(position + i)
				End If

																	public split_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation builds NDArray from NDArrayList using indices
			''' Expected arguments:
			''' x: non-empty list
			''' indices: vector with indices for gather operation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_gather_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gather_list extends DeclarableListOp
			public static class gather_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gather_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gather_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gather_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), gather_list)
				End If
				public gather_list getPointer(Long i)
				If True Then
					Return (New gather_list(CType(Me, Pointer))).position(position + i)
				End If

																	public gather_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation clones given NDArrayList
			''' </summary>
	'         #if NOT_EXCLUDED(OP_clone_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clone_list extends DeclarableListOp
			public static class clone_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clone_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clone_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clone_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), clone_list)
				End If
				public clone_list getPointer(Long i)
				If True Then
					Return (New clone_list(CType(Me, Pointer))).position(position + i)
				End If

																	public clone_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation unstacks given NDArray into NDArrayList by the first dimension
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unstack_list)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unstack_list extends DeclarableListOp
			public static class unstack_list extends DeclarableListOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unstack_list(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unstack_list(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unstack_list position(Long position)
				If True Then
					Return CType(MyBase.position(position), unstack_list)
				End If
				public unstack_list getPointer(Long i)
				If True Then
					Return (New unstack_list(CType(Me, Pointer))).position(position + i)
				End If

																	public unstack_list()
																	If True Then
																		MyBase(DirectCast(Nothing, Pointer))
																		allocate()
																	End If
																	private native void allocate()
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/recurrent.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_RECURRENT_H
	' #define LIBND4J_HEADERS_RECURRENT_H

	' #include <ops/declarable/headers/common.h>

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for Simple Recurrent Unit: "Training RNNs as Fast as CNNs" Tao Lei, Yu Zhang, Yoav Artzi
		'''   
		''' Input arrays:
		'''    0: input 3d tensor with shape [bS x K x N], N - number of time steps, bS - batch size, K - number of features
		'''    1: 2d tensor of weights [3K x K]
		'''    2: row of biases with twice length [1 x 2K]
		'''    3: 2d tensor of previous cell state [bS x K]
		'''    4: optional, 2d tensor of dropout mask [bS x K]
		'''   
		''' Output arrays:
		'''    0: 3d tensor of cell output [bS x K x N]
		'''    1: 3d tensor of cell state [bS x K x N]
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sru)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sru extends DeclarableCustomOp
			public static class sru extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sru(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sru(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sru position(Long position)
				If True Then
					Return CType(MyBase.position(position), sru)
				End If
				public sru getPointer(Long i)
				If True Then
					Return (New sru(CType(Me, Pointer))).position(position + i)
				End If

																						public sru()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for Simple Recurrent Unit (bidirectional case): "Training RNNs as Fast as CNNs" Tao Lei, Yu Zhang, Yoav Artzi
		'''   
		''' Input arrays:
		'''    0: input 3d tensor with shape [N x bS x 2K], N - number of time steps, bS - batch size, K - number of features
		'''    1: 2d tensor of weights [2K x 6K]
		'''    2: row of biases with twice length [1 x 4K]
		'''    3: 2d tensor of previous cell state [bS x 2K]
		'''    4: optional, 2d tensor of dropout mask [bS x 2K]
		'''   
		''' Output arrays:
		'''    0: 3d tensor of cell output [N x bS x 2K]
		'''    1: 3d tensor of cell state [N x bS x 2K]
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sru_bi)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sru_bi extends DeclarableCustomOp
			public static class sru_bi extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sru_bi(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sru_bi(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sru_bi position(Long position)
				If True Then
					Return CType(MyBase.position(position), sru_bi)
				End If
				public sru_bi getPointer(Long i)
				If True Then
					Return (New sru_bi(CType(Me, Pointer))).position(position + i)
				End If

																						public sru_bi()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for back propagation in Simple Recurrent Unit: "Training RNNs as Fast as CNNs" Tao Lei, Yu Zhang, Yoav Artzi
		'''   
		''' Input arrays:
		'''    0: input 3d tensor with shape [bS x K x N], N - number of time steps, bS - batch size, K - number of features
		'''    1: 2d tensor of weights [3K x K]
		'''    2: row of biases with twice length [1 x 2K]
		'''    3: 2d tensor of previous cell state [bS x K]
		'''    4: 3d tensor of cell state [bS x K x N]
		'''    5: 2d tensor of cell state gradients [bS x K]
		'''    6: 3d tensor of state output gradients [bS x K x N]
		'''    7: optional, 2d tensor of dropout mask [bS x K]
		'''   
		''' Output arrays:
		'''    0: 3d tensor of input gradients [bS x K x N]
		'''    1: 3d tensor of weights gradients [bS x 3K x K]
		'''    2: 2d, row of biases gradients [1 x 2K]
		'''    3: 2d, tensor of state gradients [bS x K]
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sru)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sru_bp extends DeclarableCustomOp
			public static class sru_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sru_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sru_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sru_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), sru_bp)
				End If
				public sru_bp getPointer(Long i)
				If True Then
					Return (New sru_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public sru_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for back propagation in Simple Recurrent Unit (bidirectional case): "Training RNNs as Fast as CNNs" Tao Lei, Yu Zhang, Yoav Artzi
		'''   
		''' Input arrays:
		'''    0: input 3d tensor with shape [N x bS x 2K], N - number of time steps, bS - batch size, K - number of features
		'''    1: 2d tensor of weights [2K x 6K]
		'''    2: row of biases with twice length [1 x 4K]
		'''    3: 2d tensor of previous cell state [bS x 2K]
		'''    4: 3d tensor of cell state [N x bS x 2K]
		'''    5: 2d tensor of cell state gradients [bS x 2K]
		'''    6: 3d tensor of state output gradients [N x bS x 2K]
		'''    7: optional, 2d tensor of dropout mask [bS x 2K]
		'''   
		''' Output arrays:
		'''    0: 3d tensor of input gradients [N x bS x 2K]
		'''    1: 3d tensor of weights gradients [N x 2K x 6K]
		'''    2: 2d, row of biases gradients [1 x 4K]
		'''    3: 2d, tensor of state gradients [bS x 2K]
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sru_bi)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sru_bi_bp extends DeclarableCustomOp
			public static class sru_bi_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sru_bi_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sru_bi_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sru_bi_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), sru_bi_bp)
				End If
				public sru_bi_bp getPointer(Long i)
				If True Then
					Return (New sru_bi_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public sru_bi_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for LSTM cell with peep hole connections:
		'''    S. Hochreiter and J. Schmidhuber. "Long Short-Term Memory". Neural Computation
		'''    and
		'''    https://research.google.com/pubs/archive/43905.pdf
		'''    Hasim Sak, Andrew Senior, and Francoise Beaufays. "Long short-term memory recurrent neural network architectures for large scale acoustic modeling." INTERSPEECH, 2014.
		'''   
		''' Input arrays:
		'''    0: input with shape [batchSize x inSize], batchSize - batch size, inSize - number of features
		'''    1: previous cell output [batchSize x numProj],  that is at previous time step t-1, in case of projection=false -> numProj=numUnits!!!
		'''    2: previous cell state  [batchSize x numUnits], that is at previous time step t-1
		'''    3: input-to-hidden  weights, [inSize  x 4*numUnits]
		'''    4: hidden-to-hidden weights, [numProj x 4*numUnits]
		'''    5: diagonal weights for peephole connections [3*numUnits]
		'''    6: projection weights [numUnits x numProj]
		'''    7: biases, [4*numUnits]
		'''   
		'''  Input integer arguments:
		'''    0: if not zero, provide peephole connections
		'''    1: if not zero, then projection is performed, if zero then numProj==numUnits is mandatory!
		'''   
		'''  Input float arguments:
		'''    0: clipping value for cell state, if it is not equal to zero, then cell state is clipped
		'''    1: clipping value for projected cell output, if it is not equal to zero, then projected cell output is clipped
		'''    2: the bias added to forget gates in order to reduce the scale of forgetting in the beginning of the training
		'''   
		''' Output arrays:
		'''    0: current cell output [batchSize x numProj], that is at current time step t
		'''    1: current cell state  [batchSize x numUnits], that is at current time step t
		''' </summary>
	'         #if NOT_EXCLUDED(OP_lstmCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmCell extends DeclarableCustomOp
			public static class lstmCell extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmCell(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmCell(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmCell position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmCell)
				End If
				public lstmCell getPointer(Long i)
				If True Then
					Return (New lstmCell(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmCell()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_lstmLayerCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmLayerCell extends DeclarableCustomOp
			public static class lstmLayerCell extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmLayerCell(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmLayerCell(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmLayerCell position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmLayerCell)
				End If
				public lstmLayerCell getPointer(Long i)
				If True Then
					Return (New lstmLayerCell(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmLayerCell()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_lstmLayerCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmLayerCellBp extends DeclarableCustomOp
			public static class lstmLayerCellBp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmLayerCellBp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmLayerCellBp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmLayerCellBp position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmLayerCellBp)
				End If
				public lstmLayerCellBp getPointer(Long i)
				If True Then
					Return (New lstmLayerCellBp(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmLayerCellBp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for LSTM cell with optional peep hole connections:
		'''    S. Hochreiter and J. Schmidhuber. "Long Short-Term Memory". Neural Computation
		'''    and
		'''    https://research.google.com/pubs/archive/43905.pdf
		'''    Hasim Sak, Andrew Senior, and Francoise Beaufays. "Long short-term memory recurrent neural network architectures for large scale acoustic modeling." INTERSPEECH, 2014.
		''' See also: https://arxiv.org/pdf/1503.04069.pdf
		'''   
		''' Input arrays:
		'''    0: input [bS, inSize] at time t
		'''    1: previous cell state  [bS, numUnits], time t-1
		'''    2: previous output [bS, numUnits], time t-1
		'''    3: Weights - concatenated (input-to-hidden, hidden-to-hidden weights)  weights, [(inSize+numUnits), 4*numUnits]
		'''    4: weights - cell peephole (t-1) connections to input modulation gate, [numUnits]
		'''    5: weights - cell peephole (t-1) connections to forget gate, [numUnits]
		'''    6: weights - cell peephole (t) connections to output gate, [numUnits]
		'''    7: biases, shape [4*numUnits]
		'''   
		'''  Input integer arguments:
		'''    0: if not zero, provide peephole connections
		'''   
		'''  Input float arguments:
		'''    0: the bias added to forget gates in order to reduce the scale of forgetting in the beginning of the training
		'''    1: clipping value for cell state, if it is not equal to zero, then cell state is clipped
		'''   
		''' Output arrays:
		'''    0: i      - Input modulation gate activations [bS, numUnits]
		'''    1: c (cs) - Cell state (pre tanh) [bs, numUnits] (cs)
		'''    2: f      - Output - forget gate activations [bs, numUnits]
		'''    3: o      - Output - output gate activations [bs, numUnits]
		'''    4: z (ci) - Output - block input [bs, numUnits]
		'''    5: h (co) - Cell state, post tanh [bs, numUnits]
		'''    6: y (h)  - Current cell output [bS, numUnits], time t
		''' </summary>
	'         #if NOT_EXCLUDED(OP_lstmBlockCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmBlockCell extends DeclarableCustomOp
			public static class lstmBlockCell extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmBlockCell(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmBlockCell(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmBlockCell position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmBlockCell)
				End If
				public lstmBlockCell getPointer(Long i)
				If True Then
					Return (New lstmBlockCell(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmBlockCell()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation for LSTM layer with optional peep hole connections.
		''' See lstmBlockCell for details. lstmBlockCell is used internally for computation.
		''' This method expects as input (and returns as output) sequences in one of 3 formats, depending on the data format arg:
		''' dataFormat = 0 -> TNS: shape [timeLength, numExamples, inOutSize] - sometimes referred to as "time major"
		''' dataFormat = 1 -> NST: shape [numExamples, inOutSize, timeLength]
		''' dataFormat = 2 -> NTS: shape [numExamples, timeLength, inOutSize] - TF "time_major=false" layout
		'''   
		'''   
		''' Input arrays:
		'''    0: max sequence length; long/int64 scalar
		'''    1: input [seqLength, bS, inSize] at time t
		'''    2: previous/initial cell state  [bS, numUnits]
		'''    3: previous/initial output [bS, numUnits]
		'''    4: Weights - concatenated (input-to-hidden, hidden-to-hidden weights)  weights, [(inSize+numUnits), 4*numUnits]
		'''    5: weights - cell peephole (t-1) connections to input modulation gate, [numUnits]
		'''    6: weights - cell peephole (t-1) connections to forget gate, [numUnits]
		'''    7: weights - cell peephole (t) connections to output gate, [numUnits]
		'''    8: biases, Shape [4*numUnits]
		'''   
		'''  Input integer arguments:
		'''    0: if not zero, provide peephole connections
		'''    1: Data format - 0=TNS=[seqLen,mb,size]; 1=NST=[mb,size,seqLen]; 2=NTS=[mb,seqLen,size]
		'''   
		'''  Input float arguments:
		'''    0: the bias added to forget gates in order to reduce the scale of forgetting in the beginning of the training
		'''    1: clipping value for cell state, if it is not equal to zero, then cell state is clipped
		'''   
		''' Output arrays:
		'''    0: i      - Input modulation gate activations, rank 3, shape as per dataFormat
		'''    1: c (cs) - Cell state (pre tanh), rank 3, shape as per dataFormat
		'''    2: f      - Output - forget gate activations, rank 3, shape as per dataFormat
		'''    3: o      - Output - output gate activations, rank 3, shape as per dataFormat
		'''    4: z (ci) - Output - block input, rank 3, shape as per dataFormat
		'''    5: h (co) - Cell state, post tanh, rank 3, shape as per dataFormat
		'''    6: y (h)  - Current cell output, rank 3, shape as per dataFormat
		''' </summary>
	'         #if NOT_EXCLUDED(OP_lstmBlock)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmBlock extends DeclarableCustomOp
			public static class lstmBlock extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmBlock(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmBlock(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmBlock position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmBlock)
				End If
				public lstmBlock getPointer(Long i)
				If True Then
					Return (New lstmBlock(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmBlock()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			'////////////////////////////////////////////////////////////////////////
	'         #if NOT_EXCLUDED(OP_lstmLayer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmLayer extends DeclarableCustomOp
			public static class lstmLayer extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmLayer(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmLayer(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmLayer position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmLayer)
				End If
				public lstmLayer getPointer(Long i)
				If True Then
					Return (New lstmLayer(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmLayer()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			'////////////////////////////////////////////////////////////////////////
	'         #if NOT_EXCLUDED(OP_lstmLayer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstmLayer_bp extends DeclarableCustomOp
			public static class lstmLayer_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstmLayer_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstmLayer_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstmLayer_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstmLayer_bp)
				End If
				public lstmLayer_bp getPointer(Long i)
				If True Then
					Return (New lstmLayer_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public lstmLayer_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operations for Simple Recurrent Unit cell: "Training RNNs as Fast as CNNs" Tao Lei, Yu Zhang, Yoav Artzi
		'''   
		''' Input arrays:
		'''    0: input with shape [batchSize x inSize], batchSize - batch size, inSize - number of features
		'''    1: previous cell state [batchSize x inSize], that is at previous time step t-1
		'''    2: weights [inSize x 3*inSize]
		'''    3: biases [1 x 2*inSize]
		'''   
		''' Output arrays:
		'''    0: current cell output [batchSize x inSize], that is at current time step t
		'''    1: current cell state  [batchSize x inSize], that is at current time step t
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sruCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sruCell extends DeclarableCustomOp
			public static class sruCell extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sruCell(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sruCell(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sruCell position(Long position)
				If True Then
					Return CType(MyBase.position(position), sruCell)
				End If
				public sruCell getPointer(Long i)
				If True Then
					Return (New sruCell(CType(Me, Pointer))).position(position + i)
				End If

																						public sruCell()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of gated Recurrent Unit cell:
		'''    Kyunghyun Cho, Bart van Merrienboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, Yoshua Bengio
		'''    "Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation"
		'''   
		''' Input arrays:
		'''    0: input with shape [batchSize x inSize], batchSize - batch size, inSize - number of features
		'''    1: previous cell output [batchSize x numUnits],  that is at previous time step t-1
		'''    2: RU weights - [(inSize+numUnits), 2*numUnits] - reset and update gates (input/recurrent weights)
		'''    3: C weights - [(inSize+numUnits), numUnits] - cell gate (input/recurrent weights)
		'''    4: reset and update biases, [2*numUnits] - reset and update gates
		'''    5: cell biases, [numUnits]
		'''   
		''' Output arrays:
		'''    0: Reset gate output [bS, numUnits]
		'''    1: Update gate output [bS, numUnits]
		'''    2: Cell gate output [bS, numUnits]
		'''    3: Current cell output [bS, numUnits]
		''' </summary>
	'         #if NOT_EXCLUDED(OP_gruCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gruCell extends DeclarableCustomOp
			public static class gruCell extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gruCell(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gruCell(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gruCell position(Long position)
				If True Then
					Return CType(MyBase.position(position), gruCell)
				End If
				public gruCell getPointer(Long i)
				If True Then
					Return (New gruCell(CType(Me, Pointer))).position(position + i)
				End If

																						public gruCell()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_gruCell)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gruCell_bp extends DeclarableCustomOp
			public static class gruCell_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gruCell_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gruCell_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gruCell_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), gruCell_bp)
				End If
				public gruCell_bp getPointer(Long i)
				If True Then
					Return (New gruCell_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public gruCell_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation "LSTM time sequences" with peep hole connections:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: initial cell output [batchSize x numProj],  that is at time step = 0, in case of projection=false -> numProj=numUnits!!!
		'''    2: initial cell state  [batchSize x numUnits], that is at time step = 0
		'''    3: input-to-hidden  weights, [inSize  x 4*numUnits]
		'''    4: hidden-to-hidden weights, [numProj x 4*numUnits]
		'''    5: diagonal weights for peephole connections [3*numUnits]
		'''    6: projection weights [numUnits x numProj]
		'''    7: biases, [4*numUnits]
		'''   
		'''  Input integer arguments:
		'''    0: if not zero, provide peephole connections
		'''    1: if not zero, then projection is performed, if zero then numProj==numUnits is mandatory!
		'''   
		'''  Input float arguments:
		'''    0: clipping value for cell state, if it is not equal to zero, then cell state is clipped
		'''    1: clipping value for projected cell output, if it is not equal to zero, then projected cell output is clipped
		'''    2: the bias added to forget gates in order to reduce the scale of forgetting in the beginning of the training
		'''   
		''' Output arrays:
		'''    0: cell outputs [time x batchSize x numProj], that is per each time step
		'''    1: cell states  [time x batchSize x numUnits], that is per each time step
		''' </summary>
	'         #if NOT_EXCLUDED(OP_lstm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstm extends DeclarableCustomOp
			public static class lstm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstm position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstm)
				End If
				public lstm getPointer(Long i)
				If True Then
					Return (New lstm(CType(Me, Pointer))).position(position + i)
				End If

																						public lstm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of gated Recurrent Unit:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: initial cell output [batchSize x numUnits],  that is at time step = 0
		'''    2: input-to-hidden  weights, [inSize   x 3*numUnits]
		'''    3: hidden-to-hidden weights, [numUnits x 3*numUnits]
		'''    4: biases, [3*numUnits]
		'''   
		''' Output arrays:
		'''    0: cell outputs [time x batchSize x numUnits], that is per each time step
		''' </summary>
	'         #if NOT_EXCLUDED(OP_gru)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gru extends DeclarableCustomOp
			public static class gru extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gru(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gru(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gru position(Long position)
				If True Then
					Return CType(MyBase.position(position), gru)
				End If
				public gru getPointer(Long i)
				If True Then
					Return (New gru(CType(Me, Pointer))).position(position + i)
				End If

																						public gru()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_gru)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gru_bp extends DeclarableCustomOp
			public static class gru_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gru_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gru_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gru_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), gru_bp)
				End If
				public gru_bp getPointer(Long i)
				If True Then
					Return (New gru_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public gru_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation "static RNN time sequences" with peep hole connections:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: input-to-hidden  weights, [inSize   x numUnits]
		'''    2: hidden-to-hidden weights, [numUnits x numUnits]
		'''    3: biases, [2*numUnits]
		'''    4: (optional) initial cell output [batchSize x numUnits], that is at time step = 0
		'''    5: (optional) vector with shape [batchSize] containing integer values within [0,time), each element of this vector set max time step per each input in batch, this provides no calculations for time >= maxTimeStep
		'''   
		''' Output arrays:
		'''    0: cell outputs [time x batchSize x numUnits]
		'''    1: cell final non-zero output [batchSize x numUnits]
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class static_rnn extends DeclarableCustomOp
			public static class static_rnn extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public static_rnn(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public static_rnn(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public static_rnn position(Long position)
				If True Then
					Return CType(MyBase.position(position), static_rnn)
				End If
				public static_rnn getPointer(Long i)
				If True Then
					Return (New static_rnn(CType(Me, Pointer))).position(position + i)
				End If

																						public static_rnn()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation "static RNN time sequences" with peep hole connections:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize] or [batchSize x time x numUnits], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: input-to-hidden  weights, [inSize   x numUnits]
		'''    2: hidden-to-hidden weights, [numUnits x numUnits]
		'''    3: biases, [2*numUnits]
		'''    4: (optional) initial cell output [batchSize x numUnits], that is at time step = 0
		'''    5: (optional) vector with shape [batchSize] containing integer values within [0,time), each element of this vector set max time step per each input in batch, this provides no calculations for time >= maxTimeStep
		'''   
		'''  Input integer arguments:
		'''    0: (optional) timeMajor - if non zero then input shape is [time, batchSize, ...], else [batchSize, time, ...]
		'''   
		''' Output arrays:
		'''    0: cell outputs [time x batchSize x numUnits] or [batchSize x time x numUnits]
		'''    1: cell final non-zero output [batchSize x numUnits]
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dynamic_rnn extends DeclarableCustomOp
			public static class dynamic_rnn extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dynamic_rnn(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dynamic_rnn(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dynamic_rnn position(Long position)
				If True Then
					Return CType(MyBase.position(position), dynamic_rnn)
				End If
				public dynamic_rnn getPointer(Long i)
				If True Then
					Return (New dynamic_rnn(CType(Me, Pointer))).position(position + i)
				End If

																						public dynamic_rnn()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation "static RNN time sequences" with peep hole connections:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: input-to-hidden  weights for forward RNN, [inSize   x numUnitsFW]
		'''    2: hidden-to-hidden weights for forward RNN, [numUnitsFW x numUnitsFW]
		'''    3: biases for forward RNN, [2*numUnitsFW]
		'''    4: input-to-hidden  weights for backward RNN, [inSize   x numUnitsBW]
		'''    5: hidden-to-hidden weights for backward RNN, [numUnitsBW x numUnitsBW]
		'''    6: biases for backward RNN, [2*numUnitsBW]
		'''    7: (optional) initial cell output for forward RNN [batchSize x numUnitsFW], that is at time step = 0
		'''    8: (optional) initial cell output for backward RNN [batchSize x numUnitsBW], that is at time step = 0
		'''    9: (optional) vector with shape [batchSize] containing integer values within [0,time), each element of this vector set max time step per each input in batch, this provides no calculations for time >= maxTimeStep
		'''   
		''' Output arrays:
		'''    0: cell outputs [time x batchSize x (numUnitsFW + numUnitsBW)]
		'''    1: cell final non-zero output for forward RNN  [batchSize x numUnitsFW]
		'''    2: cell final non-zero output for backward RNN [batchSize x numUnitsBW]
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class static_bidirectional_rnn extends DeclarableCustomOp
			public static class static_bidirectional_rnn extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public static_bidirectional_rnn(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public static_bidirectional_rnn(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public static_bidirectional_rnn position(Long position)
				If True Then
					Return CType(MyBase.position(position), static_bidirectional_rnn)
				End If
				public static_bidirectional_rnn getPointer(Long i)
				If True Then
					Return (New static_bidirectional_rnn(CType(Me, Pointer))).position(position + i)
				End If

																						public static_bidirectional_rnn()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of operation "static RNN time sequences" with peep hole connections:
		'''   
		''' Input arrays:
		'''    0: input with shape [time x batchSize x inSize] or [batchSize x time x inSize], time - number of time steps, batchSize - batch size, inSize - number of features
		'''    1: input-to-hidden  weights for forward RNN, [inSize   x numUnitsFW]
		'''    2: hidden-to-hidden weights for forward RNN, [numUnitsFW x numUnitsFW]
		'''    3: biases for forward RNN, [2*numUnitsFW]
		'''    4: input-to-hidden  weights for backward RNN, [inSize   x numUnitsBW]
		'''    5: hidden-to-hidden weights for backward RNN, [numUnitsBW x numUnitsBW]
		'''    6: biases for backward RNN, [2*numUnitsBW]
		'''    7: (optional) initial cell output for forward RNN [batchSize x numUnitsFW], that is at time step = 0
		'''    8: (optional) initial cell output for backward RNN [batchSize x numUnitsBW], that is at time step = 0
		'''    9: (optional) vector with shape [batchSize] containing integer values within [0,time), each element of this vector set max time step per each input in batch, this provides no calculations for time >= maxTimeStep
		'''   
		'''  Input integer arguments:
		'''    0: (optional) timeMajor - if non zero then input shape is [time, batchSize, ...], else [batchSize, time, ...]
		'''   
		''' Output arrays:
		'''    0: cell outputs for forward  RNN [time x batchSize x numUnitsFW] or [batchSize x time x  numUnitsFW]
		'''    1: cell outputs for backward RNN [time x batchSize x numUnitsBW] or [batchSize x time x  numUnitsBW]
		'''    2: cell final non-zero output for forward  RNN [batchSize x numUnitsFW]
		'''    3: cell final non-zero output for backward RNN [batchSize x numUnitsBW]
		''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dynamic_bidirectional_rnn extends DeclarableCustomOp
			public static class dynamic_bidirectional_rnn extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dynamic_bidirectional_rnn(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dynamic_bidirectional_rnn(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dynamic_bidirectional_rnn position(Long position)
				If True Then
					Return CType(MyBase.position(position), dynamic_bidirectional_rnn)
				End If
				public dynamic_bidirectional_rnn getPointer(Long i)
				If True Then
					Return (New dynamic_bidirectional_rnn(CType(Me, Pointer))).position(position + i)
				End If

																						public dynamic_bidirectional_rnn()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If



	' #endif

	' Parsed from ops/declarable/headers/transforms.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_TRANSFORMS_H
	' #define LIBND4J_HEADERS_TRANSFORMS_H

	' #include <ops/declarable/headers/common.h>
	'         #if NOT_EXCLUDED(OP_clipbyvalue)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clipbyvalue extends DeclarableOp
			public static class clipbyvalue extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clipbyvalue(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clipbyvalue(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clipbyvalue position(Long position)
				If True Then
					Return CType(MyBase.position(position), clipbyvalue)
				End If
				public clipbyvalue getPointer(Long i)
				If True Then
					Return (New clipbyvalue(CType(Me, Pointer))).position(position + i)
				End If

																						public clipbyvalue()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_clipbynorm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clipbynorm extends DeclarableOp
			public static class clipbynorm extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clipbynorm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clipbynorm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clipbynorm position(Long position)
				If True Then
					Return CType(MyBase.position(position), clipbynorm)
				End If
				public clipbynorm getPointer(Long i)
				If True Then
					Return (New clipbynorm(CType(Me, Pointer))).position(position + i)
				End If

																						public clipbynorm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clipbynorm_bp extends DeclarableCustomOp
			public static class clipbynorm_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clipbynorm_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clipbynorm_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clipbynorm_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), clipbynorm_bp)
				End If
				public clipbynorm_bp getPointer(Long i)
				If True Then
					Return (New clipbynorm_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public clipbynorm_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_clipbyavgnorm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clipbyavgnorm extends DeclarableOp
			public static class clipbyavgnorm extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clipbyavgnorm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clipbyavgnorm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clipbyavgnorm position(Long position)
				If True Then
					Return CType(MyBase.position(position), clipbyavgnorm)
				End If
				public clipbyavgnorm getPointer(Long i)
				If True Then
					Return (New clipbyavgnorm(CType(Me, Pointer))).position(position + i)
				End If

																						public clipbyavgnorm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clipbyavgnorm_bp extends DeclarableCustomOp
			public static class clipbyavgnorm_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clipbyavgnorm_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clipbyavgnorm_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clipbyavgnorm_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), clipbyavgnorm_bp)
				End If
				public clipbyavgnorm_bp getPointer(Long i)
				If True Then
					Return (New clipbyavgnorm_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public clipbyavgnorm_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_cumsum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cumsum extends DeclarableOp
			public static class cumsum extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cumsum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cumsum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cumsum position(Long position)
				If True Then
					Return CType(MyBase.position(position), cumsum)
				End If
				public cumsum getPointer(Long i)
				If True Then
					Return (New cumsum(CType(Me, Pointer))).position(position + i)
				End If

																						public cumsum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_cumprod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cumprod extends DeclarableOp
			public static class cumprod extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cumprod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cumprod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cumprod position(Long position)
				If True Then
					Return CType(MyBase.position(position), cumprod)
				End If
				public cumprod getPointer(Long i)
				If True Then
					Return (New cumprod(CType(Me, Pointer))).position(position + i)
				End If

																						public cumprod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_tile)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tile extends DeclarableCustomOp
			public static class tile extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tile(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tile(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tile position(Long position)
				If True Then
					Return CType(MyBase.position(position), tile)
				End If
				public tile getPointer(Long i)
				If True Then
					Return (New tile(CType(Me, Pointer))).position(position + i)
				End If

																						public tile()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tile_bp extends DeclarableCustomOp
			public static class tile_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tile_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tile_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tile_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), tile_bp)
				End If
				public tile_bp getPointer(Long i)
				If True Then
					Return (New tile_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public tile_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_repeat)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class repeat extends DeclarableCustomOp
			public static class repeat extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public repeat(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public repeat(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public repeat position(Long position)
				If True Then
					Return CType(MyBase.position(position), repeat)
				End If
				public repeat getPointer(Long i)
				If True Then
					Return (New repeat(CType(Me, Pointer))).position(position + i)
				End If

																						public repeat()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_invert_permutation)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class invert_permutation extends DeclarableOp
			public static class invert_permutation extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public invert_permutation(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public invert_permutation(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public invert_permutation position(Long position)
				If True Then
					Return CType(MyBase.position(position), invert_permutation)
				End If
				public invert_permutation getPointer(Long i)
				If True Then
					Return (New invert_permutation(CType(Me, Pointer))).position(position + i)
				End If

																						public invert_permutation()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class concat extends DeclarableCustomOp
			public static class concat extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public concat(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public concat(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public concat position(Long position)
				If True Then
					Return CType(MyBase.position(position), concat)
				End If
				public concat getPointer(Long i)
				If True Then
					Return (New concat(CType(Me, Pointer))).position(position + i)
				End If

																						public concat()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class concat_bp extends DeclarableCustomOp
			public static class concat_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public concat_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public concat_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public concat_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), concat_bp)
				End If
				public concat_bp getPointer(Long i)
				If True Then
					Return (New concat_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public concat_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

	'         #if NOT_EXCLUDED(OP_mergemax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergemax extends DeclarableOp
			public static class mergemax extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergemax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergemax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergemax position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergemax)
				End If
				public mergemax getPointer(Long i)
				If True Then
					Return (New mergemax(CType(Me, Pointer))).position(position + i)
				End If

														public mergemax()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergemax_bp extends DeclarableCustomOp
			public static class mergemax_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergemax_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergemax_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergemax_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergemax_bp)
				End If
				public mergemax_bp getPointer(Long i)
				If True Then
					Return (New mergemax_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public mergemax_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'        
	'         * Complete tensor with max indices merged from all input tensors list
	'         *
	'         * INPUT: tensors with the same shape
	'         * OUTPUT: integer tensor with the same shape
	'         * INT_ARG: result type (one of int), INT32 by default
	'         
	'         #if NOT_EXCLUDED(OP_mergemaxindex)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergemaxindex extends DeclarableCustomOp
			public static class mergemaxindex extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergemaxindex(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergemaxindex(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergemaxindex position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergemaxindex)
				End If
				public mergemaxindex getPointer(Long i)
				If True Then
					Return (New mergemaxindex(CType(Me, Pointer))).position(position + i)
				End If

																						public mergemaxindex()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_mergeadd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergeadd extends DeclarableOp
			public static class mergeadd extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergeadd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergeadd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergeadd position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergeadd)
				End If
				public mergeadd getPointer(Long i)
				If True Then
					Return (New mergeadd(CType(Me, Pointer))).position(position + i)
				End If

														public mergeadd()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergeadd_bp extends DeclarableCustomOp
			public static class mergeadd_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergeadd_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergeadd_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergeadd_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergeadd_bp)
				End If
				public mergeadd_bp getPointer(Long i)
				If True Then
					Return (New mergeadd_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public mergeadd_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_mergeavg)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergeavg extends DeclarableOp
			public static class mergeavg extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergeavg(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergeavg(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergeavg position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergeavg)
				End If
				public mergeavg getPointer(Long i)
				If True Then
					Return (New mergeavg(CType(Me, Pointer))).position(position + i)
				End If

														public mergeavg()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mergeavg_bp extends DeclarableCustomOp
			public static class mergeavg_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mergeavg_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mergeavg_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mergeavg_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), mergeavg_bp)
				End If
				public mergeavg_bp getPointer(Long i)
				If True Then
					Return (New mergeavg_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public mergeavg_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_scatter_update)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_update extends DeclarableOp
			public static class scatter_update extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_update(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_update(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_update position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_update)
				End If
				public scatter_update getPointer(Long i)
				If True Then
					Return (New scatter_update(CType(Me, Pointer))).position(position + i)
				End If

																						public scatter_update()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_Floor)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Floor extends DeclarableOp
			public static class Floor extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Floor(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Floor(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Floor position(Long position)
				If True Then
					Return CType(MyBase.position(position), Floor)
				End If
				public Floor getPointer(Long i)
				If True Then
					Return (New Floor(CType(Me, Pointer))).position(position + i)
				End If

														public Floor()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_Log1p)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Log1p extends DeclarableOp
			public static class Log1p extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Log1p(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Log1p(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Log1p position(Long position)
				If True Then
					Return CType(MyBase.position(position), Log1p)
				End If
				public Log1p getPointer(Long i)
				If True Then
					Return (New Log1p(CType(Me, Pointer))).position(position + i)
				End If

														public Log1p()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reverse)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reverse extends DeclarableOp
			public static class reverse extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reverse(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reverse(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reverse position(Long position)
				If True Then
					Return CType(MyBase.position(position), reverse)
				End If
				public reverse getPointer(Long i)
				If True Then
					Return (New reverse(CType(Me, Pointer))).position(position + i)
				End If

																						public reverse()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reverse_bp extends DeclarableCustomOp
			public static class reverse_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reverse_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reverse_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reverse_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reverse_bp)
				End If
				public reverse_bp getPointer(Long i)
				If True Then
					Return (New reverse_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reverse_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_gather)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gather extends DeclarableCustomOp
			public static class gather extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gather(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gather(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gather position(Long position)
				If True Then
					Return CType(MyBase.position(position), gather)
				End If
				public gather getPointer(Long i)
				If True Then
					Return (New gather(CType(Me, Pointer))).position(position + i)
				End If

																						public gather()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_pad)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class pad extends DeclarableCustomOp
			public static class pad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public pad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public pad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public pad position(Long position)
				If True Then
					Return CType(MyBase.position(position), pad)
				End If
				public pad getPointer(Long i)
				If True Then
					Return (New pad(CType(Me, Pointer))).position(position + i)
				End If

																						public pad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' creates identity 2D matrix or batch of identical 2D identity matrices
			''' 
			''' Input array:
			''' provide some array - in any case operation simply neglects it
			''' 
			''' Input float argument (if passed):
			''' TArgs[0] - type of elements of output array, default value is 5 (float)
			''' 
			''' Input integer arguments:
			''' IArgs[0]       - order of output identity matrix, 99 -> 'c'-order, 102 -> 'f'-order
			''' IArgs[1]       - the number of rows in output inner-most 2D identity matrix
			''' IArgs[2]       - optional, the number of columns in output inner-most 2D identity matrix, if this argument is not provided then it is taken to be equal to number of rows
			''' IArgs[3,4,...] - optional, shape of batch, output matrix will have leading batch dimensions of this shape
			''' </summary>
	'         #if NOT_EXCLUDED(OP_eye)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class eye extends DeclarableCustomOp
			public static class eye extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public eye(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public eye(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public eye position(Long position)
				If True Then
					Return CType(MyBase.position(position), eye)
				End If
				public eye getPointer(Long i)
				If True Then
					Return (New eye(CType(Me, Pointer))).position(position + i)
				End If

																						public eye()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_gather_nd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class gather_nd extends DeclarableCustomOp
			public static class gather_nd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public gather_nd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public gather_nd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public gather_nd position(Long position)
				If True Then
					Return CType(MyBase.position(position), gather_nd)
				End If
				public gather_nd getPointer(Long i)
				If True Then
					Return (New gather_nd(CType(Me, Pointer))).position(position + i)
				End If

																						public gather_nd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reverse_sequence)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reverse_sequence extends DeclarableCustomOp
			public static class reverse_sequence extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reverse_sequence(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reverse_sequence(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reverse_sequence position(Long position)
				If True Then
					Return CType(MyBase.position(position), reverse_sequence)
				End If
				public reverse_sequence getPointer(Long i)
				If True Then
					Return (New reverse_sequence(CType(Me, Pointer))).position(position + i)
				End If

																						public reverse_sequence()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_trace)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class trace extends DeclarableCustomOp
			public static class trace extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public trace(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public trace(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public trace position(Long position)
				If True Then
					Return CType(MyBase.position(position), trace)
				End If
				public trace getPointer(Long i)
				If True Then
					Return (New trace(CType(Me, Pointer))).position(position + i)
				End If

																						public trace()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_random_shuffle)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_shuffle extends DeclarableOp
			public static class random_shuffle extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_shuffle(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_shuffle(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_shuffle position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_shuffle)
				End If
				public random_shuffle getPointer(Long i)
				If True Then
					Return (New random_shuffle(CType(Me, Pointer))).position(position + i)
				End If

														public random_shuffle()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' clip a list of given tensors with given average norm when needed
			''' 
			''' Input:
			'''    a list of tensors (at least one)
			''' 
			''' Input floating point argument:
			'''    clip_norm - a value that used as threshold value and norm to be used
			''' 
			''' return a list of clipped tensors
			'''  and global_norm as scalar tensor at the end
			''' </summary>
	'         #if NOT_EXCLUDED(OP_clip_by_global_norm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class clip_by_global_norm extends DeclarableCustomOp
			public static class clip_by_global_norm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public clip_by_global_norm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public clip_by_global_norm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public clip_by_global_norm position(Long position)
				If True Then
					Return CType(MyBase.position(position), clip_by_global_norm)
				End If
				public clip_by_global_norm getPointer(Long i)
				If True Then
					Return (New clip_by_global_norm(CType(Me, Pointer))).position(position + i)
				End If

																						public clip_by_global_norm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tri extends DeclarableCustomOp
			public static class tri extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tri(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tri(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tri position(Long position)
				If True Then
					Return CType(MyBase.position(position), tri)
				End If
				public tri getPointer(Long i)
				If True Then
					Return (New tri(CType(Me, Pointer))).position(position + i)
				End If

																						public tri()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class triu extends DeclarableCustomOp
			public static class triu extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public triu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public triu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public triu position(Long position)
				If True Then
					Return CType(MyBase.position(position), triu)
				End If
				public triu getPointer(Long i)
				If True Then
					Return (New triu(CType(Me, Pointer))).position(position + i)
				End If

																						public triu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class triu_bp extends DeclarableCustomOp
			public static class triu_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public triu_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public triu_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public triu_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), triu_bp)
				End If
				public triu_bp getPointer(Long i)
				If True Then
					Return (New triu_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public triu_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

	'         #if NOT_EXCLUDED(OP_mirror_pad)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mirror_pad extends DeclarableCustomOp
			public static class mirror_pad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mirror_pad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mirror_pad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mirror_pad position(Long position)
				If True Then
					Return CType(MyBase.position(position), mirror_pad)
				End If
				public mirror_pad getPointer(Long i)
				If True Then
					Return (New mirror_pad(CType(Me, Pointer))).position(position + i)
				End If

																						public mirror_pad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_cumsum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cumsum_bp extends DeclarableCustomOp
			public static class cumsum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cumsum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cumsum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cumsum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), cumsum_bp)
				End If
				public cumsum_bp getPointer(Long i)
				If True Then
					Return (New cumsum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public cumsum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_cumprod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cumprod_bp extends DeclarableCustomOp
			public static class cumprod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cumprod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cumprod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cumprod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), cumprod_bp)
				End If
				public cumprod_bp getPointer(Long i)
				If True Then
					Return (New cumprod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public cumprod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


	'         #if NOT_EXCLUDED(OP_flatten)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class flatten extends DeclarableCustomOp
			public static class flatten extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public flatten(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public flatten(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public flatten position(Long position)
				If True Then
					Return CType(MyBase.position(position), flatten)
				End If
				public flatten getPointer(Long i)
				If True Then
					Return (New flatten(CType(Me, Pointer))).position(position + i)
				End If

																						public flatten()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' returns histogram (as 1D array) with fixed bins width
			''' 
			''' Input arrays:
			''' - input array with elements to be binned into output histogram
			''' - range array with first element being bottom limit and second element being top limit of histogram,
			'''     please note that input_value <= range[0] will be mapped to histogram[0], input_value >= range[1] will be mapped to histogram[-1]
			''' 
			''' Input integer arguments:
			'''    nbins (optional) - number of histogram bins, default value is 100
			''' </summary>
	'         #if NOT_EXCLUDED(OP_histogram_fixed_width)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class histogram_fixed_width extends DeclarableCustomOp
			public static class histogram_fixed_width extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public histogram_fixed_width(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public histogram_fixed_width(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public histogram_fixed_width position(Long position)
				If True Then
					Return CType(MyBase.position(position), histogram_fixed_width)
				End If
				public histogram_fixed_width getPointer(Long i)
				If True Then
					Return (New histogram_fixed_width(CType(Me, Pointer))).position(position + i)
				End If

																						public histogram_fixed_width()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' standardizes input array to be zero mean unit variance along the given axis
			''' 
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_standardize)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class standardize extends DeclarableOp
					public static class standardize extends DeclarableOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public standardize(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public standardize(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public standardize position(Long position)
						If True Then
							Return CType(MyBase.position(position), standardize)
						End If
						public standardize getPointer(Long i)
						If True Then
							Return (New standardize(CType(Me, Pointer))).position(position + i)
						End If

																						public standardize()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class standardize_bp extends DeclarableCustomOp
					public static class standardize_bp extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public standardize_bp(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public standardize_bp(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public standardize_bp position(Long position)
						If True Then
							Return CType(MyBase.position(position), standardize_bp)
						End If
						public standardize_bp getPointer(Long i)
						If True Then
							Return (New standardize_bp(CType(Me, Pointer))).position(position + i)
						End If

																						public standardize_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

			''' <summary>
			''' This operation calculates hash code, optionally along dimension
			''' </summary>
	'         #if NOT_EXCLUDED(OP_hashcode)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hashcode extends DeclarableCustomOp
				public static class hashcode extends DeclarableCustomOp
				If True Then
					''' <summary>
					''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
					public hashcode(Pointer p)
					If True Then
						MyBase(p)
					End If
					''' <summary>
					''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
					public hashcode(Long size)
					If True Then
						MyBase(DirectCast(Nothing, Pointer))
						allocateArray(size)
					End If
					private native void allocateArray(Long size)
					public hashcode position(Long position)
					If True Then
						Return CType(MyBase.position(position), hashcode)
					End If
					public hashcode getPointer(Long i)
					If True Then
						Return (New hashcode(CType(Me, Pointer))).position(position + i)
					End If

																						public hashcode()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
				End If
	'         #endif

			''' <summary>
			''' This operation calculates number of entries per bin
			''' </summary>
	'         #if NOT_EXCLUDED(OP_histogram)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class histogram extends DeclarableCustomOp
			public static class histogram extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public histogram(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public histogram(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public histogram position(Long position)
				If True Then
					Return CType(MyBase.position(position), histogram)
				End If
				public histogram getPointer(Long i)
				If True Then
					Return (New histogram(CType(Me, Pointer))).position(position + i)
				End If

																						public histogram()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/parity_ops.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_PARITY_H
	' #define LIBND4J_HEADERS_PARITY_H

	' #include <ops/declarable/headers/common.h>
			''' <summary>
			''' This operation returns index of max element in a given NDArray (optionally: along given dimension(s))
			''' Expected input:
			''' 0: N-dimensional array
			''' 1: optional axis vector
			''' 
			''' Int args:
			''' 0: optional axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_argmax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class argmax extends DeclarableCustomOp
			public static class argmax extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public argmax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public argmax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public argmax position(Long position)
				If True Then
					Return CType(MyBase.position(position), argmax)
				End If
				public argmax getPointer(Long i)
				If True Then
					Return (New argmax(CType(Me, Pointer))).position(position + i)
				End If

																						public argmax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns index of min element in a given NDArray (optionally: along given dimension(s))
			''' Expected input:
			''' 0: N-dimensional array
			''' 1: optional axis vector
			''' 
			''' Int args:
			''' 0: optional axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_argmin)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class argmin extends DeclarableCustomOp
			public static class argmin extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public argmin(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public argmin(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public argmin position(Long position)
				If True Then
					Return CType(MyBase.position(position), argmin)
				End If
				public argmin getPointer(Long i)
				If True Then
					Return (New argmin(CType(Me, Pointer))).position(position + i)
				End If

																						public argmin()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns index of absolute max element in a given NDArray (optionally: along given dimension(s))
			''' Expected input:
			''' 0: N-dimensional array
			''' 1: optional axis vector
			''' 
			''' Int args:
			''' 0: optional axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_argamax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class argamax extends DeclarableCustomOp
			public static class argamax extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public argamax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public argamax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public argamax position(Long position)
				If True Then
					Return CType(MyBase.position(position), argamax)
				End If
				public argamax getPointer(Long i)
				If True Then
					Return (New argamax(CType(Me, Pointer))).position(position + i)
				End If

																						public argamax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns index of absolute min element in a given NDArray (optionally: along given dimension(s))
			''' Expected input:
			''' 0: N-dimensional array
			''' 1: optional axis vector
			''' 
			''' Int args:
			''' 0: optional axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_argamin)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class argamin extends DeclarableCustomOp
			public static class argamin extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public argamin(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public argamin(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public argamin position(Long position)
				If True Then
					Return CType(MyBase.position(position), argamin)
				End If
				public argamin getPointer(Long i)
				If True Then
					Return (New argamin(CType(Me, Pointer))).position(position + i)
				End If

																						public argamin()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation provides various normalization modes:
			''' 0: frobenius
			''' 1: euclidean (norm2)
			''' 2: norm1
			''' 3: norm2
			''' 4: inf-norm
			''' 5: p-norm
			''' 
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' 
			''' Int args:
			''' 0...: axis
			''' 
			''' T args:
			''' 0: norm mode
			''' 1: p for p-norm
			''' </summary>
	'         #if NOT_EXCLUDED(OP_norm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class norm extends DeclarableReductionOp
			public static class norm extends DeclarableReductionOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public norm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public norm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public norm position(Long position)
				If True Then
					Return CType(MyBase.position(position), norm)
				End If
				public norm getPointer(Long i)
				If True Then
					Return (New norm(CType(Me, Pointer))).position(position + i)
				End If

																						public norm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' Inserts elements provided by diagonal array into the main diagonal of innermost matrices of input array
			''' 
			''' Input arrays:
			'''  0: input array, considered as batch of matrices
			'''  1: diagonal array containing elements to be inserted into input array,
			'''     following rank condition should be satisfied: diagonal_rank = input_rank - 1,
			'''     the shapes of diagonal and input arrays must be equal except last dimension of input array,
			'''     for example if input_shape = [A,B,C,D] then diagonal_shape = [A,B,C],
			'''     also last dimension of diagonal array should be equal to smaller of last and last but one input dimensions
			'''     that is: diagonal_shape[-1] = min(input_shape[-1], input_shape[-2])
			''' 
			''' Output array:
			'''  0: has the same shape as input, corresponding diagonal elements are substituted
			''' </summary>
	'         #if NOT_EXCLUDED(OP_matrix_set_diag)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_set_diag extends DeclarableOp
			public static class matrix_set_diag extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_set_diag(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_set_diag(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_set_diag position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_set_diag)
				End If
				public matrix_set_diag getPointer(Long i)
				If True Then
					Return (New matrix_set_diag(CType(Me, Pointer))).position(position + i)
				End If

																						public matrix_set_diag()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Inserts elements provided by diagonal array into the main diagonal of innermost matrices of output array,
			''' rest output elements are set to zeros
			''' 
			''' Input array:
			'''    diagonal: array containing elements to be inserted into output array,
			'''              following rank condition is present: diagonal_rank = ouput_rank - 1
			''' 
			''' Output array:
			'''   0: is considered as batch of matrices, if for example diagonal array has shape [A,B,C] then output array has shape [A,B,C,C]
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_diag extends DeclarableCustomOp
			public static class matrix_diag extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_diag(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_diag(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_diag position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_diag)
				End If
				public matrix_diag getPointer(Long i)
				If True Then
					Return (New matrix_diag(CType(Me, Pointer))).position(position + i)
				End If

																						public matrix_diag()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

			''' <summary>
			''' This op calculates regularized incomplete beta integral Ix(a, b).
			''' Implementation is based on two algorithms depending on input values of a and b:
			''' - when a and b are both >  maxValue (3000.), then Gauss-Legendre quadrature method is applied
			''' - when a and b are both <= maxValue (3000.), then modified Lentz's algorithm for continued fractions is applied
			''' 
			''' Input arrays:
			'''    a: defines power t^{a-1}, must be > 0, type float.
			'''    b: defines power (1-t)^{b-1}, must be > 0, type float.
			'''    x: defines upper limit of integration, must be within (0 <= x <= 1) range, type float.
			''' 
			''' Output array:
			'''    0: values of  regularized incomplete beta integral that corresponds to variable upper limit x, type float
			''' 
			''' Three input and one output arrays must have the same shape
			''' </summary>
	'         #if NOT_EXCLUDED(OP_betainc)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class betainc extends DeclarableOp
			public static class betainc extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public betainc(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public betainc(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public betainc position(Long position)
				If True Then
					Return CType(MyBase.position(position), betainc)
				End If
				public betainc getPointer(Long i)
				If True Then
					Return (New betainc(CType(Me, Pointer))).position(position + i)
				End If

																						public betainc()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation is added for compatibility purposes mostly.
			''' PLEASE NOTE: Please consider using Add instead
			''' Expected arguments:
			''' 0: N-dimensional input
			''' 1: bias vector
			''' </summary>
	'         #if NOT_EXCLUDED(OP_biasadd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class biasadd extends DeclarableCustomOp
			public static class biasadd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public biasadd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public biasadd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public biasadd position(Long position)
				If True Then
					Return CType(MyBase.position(position), biasadd)
				End If
				public biasadd getPointer(Long i)
				If True Then
					Return (New biasadd(CType(Me, Pointer))).position(position + i)
				End If

																						public biasadd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class biasadd_bp extends DeclarableCustomOp
			public static class biasadd_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public biasadd_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public biasadd_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public biasadd_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), biasadd_bp)
				End If
				public biasadd_bp getPointer(Long i)
				If True Then
					Return (New biasadd_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public biasadd_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Returns a diagonal tensor with a given diagonal values. Given a diagonal, this operation returns a tensor with the diagonal and everything else padded with zeros.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_diag)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class diag extends DeclarableCustomOp
			public static class diag extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public diag(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public diag(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public diag position(Long position)
				If True Then
					Return CType(MyBase.position(position), diag)
				End If
				public diag getPointer(Long i)
				If True Then
					Return (New diag(CType(Me, Pointer))).position(position + i)
				End If

																						public diag()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Returns a diagonal tensor with a given diagonal values. Given a diagonal, this operation returns a tensor with the diagonal and everything else padded with zeros.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_diag_part)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class diag_part extends DeclarableCustomOp
			public static class diag_part extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public diag_part(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public diag_part(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public diag_part position(Long position)
				If True Then
					Return CType(MyBase.position(position), diag_part)
				End If
				public diag_part getPointer(Long i)
				If True Then
					Return (New diag_part(CType(Me, Pointer))).position(position + i)
				End If

																						public diag_part()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Returns a diagonal vector for any submatricies with in a given tensor.
			''' It is an op inverse to matrix_set_giag.
			''' Using input tensor as batched 2D diagonals flat them to vector (1D) with diagonal values.
			''' 
			''' Input : batched tensor with rank >=2
			''' Output: tensor with rank lesser by 1 from input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_matrix_diag_part)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_diag_part extends DeclarableCustomOp
			public static class matrix_diag_part extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_diag_part(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_diag_part(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_diag_part position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_diag_part)
				End If
				public matrix_diag_part getPointer(Long i)
				If True Then
					Return (New matrix_diag_part(CType(Me, Pointer))).position(position + i)
				End If

																						public matrix_diag_part()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' QR decomposition: A = QR, where Q is ortogonal (Q * QT = I) and R is upper triangular.
			''' For A (MxN) Q is M x M and R is (NxN). 
			''' 
			''' Input : 
			'''    0 - float (or complex float) tensor with shape {.,..,...,M,N} - batch of float matricies
			''' 
			''' Output: 
			'''    0 - float tensor with shape {.,..,...,MxN} - batch of ortogonal matricies {Qs}
			'''    1 - float tensor with shape {.,..,...,NxN} - batch of upper triangular matricies {Rs}
			''' </summary>
	'         #if NOT_EXCLUDED(OP_qr)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class qr extends DeclarableCustomOp
			public static class qr extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public qr(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public qr(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public qr position(Long position)
				If True Then
					Return CType(MyBase.position(position), qr)
				End If
				public qr getPointer(Long i)
				If True Then
					Return (New qr(CType(Me, Pointer))).position(position + i)
				End If

																						public qr()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation takes 2 arrays: original values, and values to be excluded. And returns 2 arrays: values left after exclusion, and indices in original array for surivals.
			''' Expected arguments:
			''' 0: vector with original values
			''' 1: vector with values to exclude
			''' </summary>
	'         #if NOT_EXCLUDED(OP_listdiff)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class listdiff extends DeclarableCustomOp
			public static class listdiff extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public listdiff(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public listdiff(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public listdiff position(Long position)
				If True Then
					Return CType(MyBase.position(position), listdiff)
				End If
				public listdiff getPointer(Long i)
				If True Then
					Return (New listdiff(CType(Me, Pointer))).position(position + i)
				End If

																						public listdiff()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Add operation to specific inputs wrt indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_add)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_add extends DeclarableOp
			public static class scatter_add extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_add(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_add(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_add position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_add)
				End If
				public scatter_add getPointer(Long i)
				If True Then
					Return (New scatter_add(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_add()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Subtract operation to specific inputs wrt indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_sub)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_sub extends DeclarableOp
			public static class scatter_sub extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_sub(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_sub(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_sub position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_sub)
				End If
				public scatter_sub getPointer(Long i)
				If True Then
					Return (New scatter_sub(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_sub()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Multiply operation to specific inputs wrt indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_mul)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_mul extends DeclarableOp
			public static class scatter_mul extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_mul(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_mul(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_mul position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_mul)
				End If
				public scatter_mul getPointer(Long i)
				If True Then
					Return (New scatter_mul(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_mul()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Divide operation to specific inputs wrt indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_div)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_div extends DeclarableOp
			public static class scatter_div extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_div(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_div(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_div position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_div)
				End If
				public scatter_div getPointer(Long i)
				If True Then
					Return (New scatter_div(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_div()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Assign operation to specific inputs wrt indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_upd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_upd extends DeclarableOp
			public static class scatter_upd extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_upd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_upd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_upd position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_upd)
				End If
				public scatter_upd getPointer(Long i)
				If True Then
					Return (New scatter_upd(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_upd()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Max operation to specific inputs through given indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_max)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_max extends DeclarableOp
			public static class scatter_max extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_max(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_max(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_max position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_max)
				End If
				public scatter_max getPointer(Long i)
				If True Then
					Return (New scatter_max(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_max()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies Min operation to specific inputs through given indices
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing indexes for first dimension of input
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_min)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_min extends DeclarableOp
			public static class scatter_min extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_min(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_min(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_min position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_min)
				End If
				public scatter_min getPointer(Long i)
				If True Then
					Return (New scatter_min(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_min()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation scatter "updates" elements into new output array according to given "indices"
			''' Expected arguments:
			''' indices: array containing elements/slices indexes of output array to put "updates" elements into, the rest output elements will be zeros
			''' updates: array containing elements to be inserted into output array
			''' shape: contains shape of output array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_nd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_nd extends DeclarableCustomOp
			public static class scatter_nd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_nd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_nd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_nd position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_nd)
				End If
				public scatter_nd getPointer(Long i)
				If True Then
					Return (New scatter_nd(CType(Me, Pointer))).position(position + i)
				End If

																						public scatter_nd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation scatter "updates" elements into input array along given "indices"
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing elements/slices indexes of input array to put "updates" elements into
			''' updates: array containing elements to be inserted into input array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_nd_update)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_nd_update extends DeclarableOp
			public static class scatter_nd_update extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_nd_update(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_nd_update(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_nd_update position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_nd_update)
				End If
				public scatter_nd_update getPointer(Long i)
				If True Then
					Return (New scatter_nd_update(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_nd_update()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation adds "updates" elements to input array along given "indices"
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing elements/slices indexes of input array to add "updates" elements to
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_add)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_nd_add extends DeclarableOp
			public static class scatter_nd_add extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_nd_add(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_nd_add(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_nd_add position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_nd_add)
				End If
				public scatter_nd_add getPointer(Long i)
				If True Then
					Return (New scatter_nd_add(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_nd_add()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation subtract "updates" elements from input array along given "indices"
			''' Expected arguments:
			''' input: array to be updated
			''' indices: array containing elements/slices indexes of input array to subtract "updates" elements from
			''' updates: array containing elements to be interfered with input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_scatter_sub)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class scatter_nd_sub extends DeclarableOp
			public static class scatter_nd_sub extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public scatter_nd_sub(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public scatter_nd_sub(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public scatter_nd_sub position(Long position)
				If True Then
					Return CType(MyBase.position(position), scatter_nd_sub)
				End If
				public scatter_nd_sub getPointer(Long i)
				If True Then
					Return (New scatter_nd_sub(CType(Me, Pointer))).position(position + i)
				End If

														public scatter_nd_sub()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation takes input's shape, and returns new NDArray filled with specified value
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' T args:
			''' 0: scalar value, used to fill NDArray
			''' </summary>
	'         #if NOT_EXCLUDED(OP_fill_as)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class fill_as extends DeclarableOp
			public static class fill_as extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public fill_as(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public fill_as(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public fill_as position(Long position)
				If True Then
					Return CType(MyBase.position(position), fill_as)
				End If
				public fill_as getPointer(Long i)
				If True Then
					Return (New fill_as(CType(Me, Pointer))).position(position + i)
				End If

																						public fill_as()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies element-wise rint (round to integral value) operation
			''' </summary>
	'         #if NOT_EXCLUDED(OP_rint)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rint extends DeclarableOp
			public static class rint extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rint(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rint(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rint position(Long position)
				If True Then
					Return CType(MyBase.position(position), rint)
				End If
				public rint getPointer(Long i)
				If True Then
					Return (New rint(CType(Me, Pointer))).position(position + i)
				End If

														public rint()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns unique elements from input array as vector, and their original indices in input array
			''' Expected input:
			''' input: N-dimensional array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unique)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unique extends DeclarableCustomOp
			public static class unique extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unique(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unique(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unique position(Long position)
				If True Then
					Return CType(MyBase.position(position), unique)
				End If
				public unique getPointer(Long i)
				If True Then
					Return (New unique(CType(Me, Pointer))).position(position + i)
				End If

																						public unique()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns 3 1D arrays for given 1D array with unique element count and indexes
			''' input:
			'''     0 - 1D array
			''' 
			''' output:
			'''     0 - 1D array with unique values
			'''     1 - 1D array with ids for values in array above
			'''     2 - 1D array with counts for values in array above
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unique_with_counts)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unique_with_counts extends DeclarableCustomOp
			public static class unique_with_counts extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unique_with_counts(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unique_with_counts(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unique_with_counts position(Long position)
				If True Then
					Return CType(MyBase.position(position), unique_with_counts)
				End If
				public unique_with_counts getPointer(Long i)
				If True Then
					Return (New unique_with_counts(CType(Me, Pointer))).position(position + i)
				End If

																						public unique_with_counts()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation splits input NDArray into multiple TADs along given dimensions
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' Int args:
			''' 0..: TAD axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_tear)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tear extends DeclarableCustomOp
			public static class tear extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tear(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tear(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tear position(Long position)
				If True Then
					Return CType(MyBase.position(position), tear)
				End If
				public tear getPointer(Long i)
				If True Then
					Return (New tear(CType(Me, Pointer))).position(position + i)
				End If

																						public tear()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op does the same as tear, just uses different input format:
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unstack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unstack extends DeclarableCustomOp
			public static class unstack extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unstack(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unstack(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unstack position(Long position)
				If True Then
					Return CType(MyBase.position(position), unstack)
				End If
				public unstack getPointer(Long i)
				If True Then
					Return (New unstack(CType(Me, Pointer))).position(position + i)
				End If

																						public unstack()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation extracts a strided (optionally) slice from a tensor,
			''' </summary>
	'         #if NOT_EXCLUDED(OP_strided_slice)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class strided_slice extends DeclarableCustomOp
			public static class strided_slice extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public strided_slice(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public strided_slice(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public strided_slice position(Long position)
				If True Then
					Return CType(MyBase.position(position), strided_slice)
				End If
				public strided_slice getPointer(Long i)
				If True Then
					Return (New strided_slice(CType(Me, Pointer))).position(position + i)
				End If

																						public strided_slice()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If ' TODO: new op type needed. that returns VIEW
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class strided_slice_bp extends DeclarableCustomOp
			public static class strided_slice_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public strided_slice_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public strided_slice_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public strided_slice_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), strided_slice_bp)
				End If
				public strided_slice_bp getPointer(Long i)
				If True Then
					Return (New strided_slice_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public strided_slice_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation extracts a slice from a tensor.
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_slice)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class slice extends DeclarableCustomOp
			public static class slice extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public slice(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public slice(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public slice position(Long position)
				If True Then
					Return CType(MyBase.position(position), slice)
				End If
				public slice getPointer(Long i)
				If True Then
					Return (New slice(CType(Me, Pointer))).position(position + i)
				End If

																						public slice()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class slice_bp extends DeclarableCustomOp
			public static class slice_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public slice_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public slice_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public slice_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), slice_bp)
				End If
				public slice_bp getPointer(Long i)
				If True Then
					Return (New slice_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public slice_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation generate sequences. Basically from......to, with step used as increment.
			''' Expected arguments:
			''' start: optional scalar with starting value
			''' stop: optional scalar with end value
			''' step: optional scalar witn step value
			''' 
			''' Int args: (optional)
			''' 0: optional scalar with starting value
			''' 1: optional scalar with end value
			''' 1: optional scalar witn step value
			''' 
			''' T args: (optional)
			''' 0: optional scalar with starting value
			''' 1: optional scalar with end value
			''' 1: optional scalar witn step value
			''' </summary>
	'         #if NOT_EXCLUDED(OP_range)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class range extends DeclarableCustomOp
			public static class range extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public range(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public range(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public range position(Long position)
				If True Then
					Return CType(MyBase.position(position), range)
				End If
				public range getPointer(Long i)
				If True Then
					Return (New range(CType(Me, Pointer))).position(position + i)
				End If

																						public range()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation return one-hot encoded n-dimensional array
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' T args:
			''' 0: 'on' value
			''' 1: 'off' value
			''' 
			''' Int args:
			''' 0: depth
			''' 1: axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_onehot)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class onehot extends DeclarableCustomOp
			public static class onehot extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public onehot(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public onehot(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public onehot position(Long position)
				If True Then
					Return CType(MyBase.position(position), onehot)
				End If
				public onehot getPointer(Long i)
				If True Then
					Return (New onehot(CType(Me, Pointer))).position(position + i)
				End If

																						public onehot()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This operation calculate the confusion matrix for a
			''' pair of prediction and label 1-D arrays.
			''' Expected arguments:
			''' Input arrays:
			'''   0 - predictions: 1-D array
			'''   1 - labels: 1-D array
			'''   2 - weights : optional
			''' Int args:
			'''   0 - num_classes: optional
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_confusion_matrix)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class confusion_matrix extends DeclarableCustomOp
			public static class confusion_matrix extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public confusion_matrix(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public confusion_matrix(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public confusion_matrix position(Long position)
				If True Then
					Return CType(MyBase.position(position), confusion_matrix)
				End If
				public confusion_matrix getPointer(Long i)
				If True Then
					Return (New confusion_matrix(CType(Me, Pointer))).position(position + i)
				End If

																						public confusion_matrix()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation stacks a list of rank tensors into one rank-(R+1) tensor.
			''' Expected arguments:
			''' 0...: N-Dimensional arrays to stack
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_stack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class stack extends DeclarableCustomOp
			public static class stack extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public stack(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public stack(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public stack position(Long position)
				If True Then
					Return CType(MyBase.position(position), stack)
				End If
				public stack getPointer(Long i)
				If True Then
					Return (New stack(CType(Me, Pointer))).position(position + i)
				End If

																						public stack()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation returns length of input array
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' TODO: make this operation reduction, to allow TAD -> size
			''' </summary>
	'         #if NOT_EXCLUDED(OP_size)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class size extends DeclarableCustomOp
			public static class size extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public size(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public size(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public size position(Long position)
				If True Then
					Return CType(MyBase.position(position), size)
				End If
				public size getPointer(Long i)
				If True Then
					Return (New size(CType(Me, Pointer))).position(position + i)
				End If

																						public size()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If ' add DeclarableScalarOp?
	'         #endif


			''' <summary>
			''' This operation returns rank of input array as scalar value.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rank extends DeclarableCustomOp
			public static class rank extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rank(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rank(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rank position(Long position)
				If True Then
					Return CType(MyBase.position(position), rank)
				End If
				public rank getPointer(Long i)
				If True Then
					Return (New rank(CType(Me, Pointer))).position(position + i)
				End If

																						public rank()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If ' ^
	'         #endif


	'         #if NOT_EXCLUDED(OP_broadcastgradientargs)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class broadcastgradientargs extends DeclarableOp
			public static class broadcastgradientargs extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public broadcastgradientargs(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public broadcastgradientargs(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public broadcastgradientargs position(Long position)
				If True Then
					Return CType(MyBase.position(position), broadcastgradientargs)
				End If
				public broadcastgradientargs getPointer(Long i)
				If True Then
					Return (New broadcastgradientargs(CType(Me, Pointer))).position(position + i)
				End If

														public broadcastgradientargs()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation takes input's shape, and returns new NDArray filled with zeros
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_zeros_as)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class zeros_as extends DeclarableCustomOp
			public static class zeros_as extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public zeros_as(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public zeros_as(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public zeros_as position(Long position)
				If True Then
					Return CType(MyBase.position(position), zeros_as)
				End If
				public zeros_as getPointer(Long i)
				If True Then
					Return (New zeros_as(CType(Me, Pointer))).position(position + i)
				End If

																						public zeros_as()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation takes input's shape, and returns new NDArray filled with ones
			''' Expected arguments:
			''' input: N-dimensional array
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_ones_as)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class ones_as extends DeclarableCustomOp
			public static class ones_as extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ones_as(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ones_as(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ones_as position(Long position)
				If True Then
					Return CType(MyBase.position(position), ones_as)
				End If
				public ones_as getPointer(Long i)
				If True Then
					Return (New ones_as(CType(Me, Pointer))).position(position + i)
				End If

																						public ones_as()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation applies element-wise pow(x, 2) to the given input
			''' Expected arguments:
			''' input: N-Dimensional array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_square)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class square extends DeclarableOp
			public static class square extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public square(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public square(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public square position(Long position)
				If True Then
					Return CType(MyBase.position(position), square)
				End If
				public square getPointer(Long i)
				If True Then
					Return (New square(CType(Me, Pointer))).position(position + i)
				End If

														public square()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates Hurwitz zeta function zeta(x, q) = sum_{n=0}^{inf} (q + n)^{-x}
			''' Implementation is based on Euler-Maclaurin summation formula
			''' 
			'''   Input arrays:
			'''   x: define power {-x}, must be > 1, type float.
			'''   q: define summand in denominator, must be > 0, type float.
			''' 
			''' Output array:
			'''    0: corresponding values of Hurwitz zeta function
			''' 
			''' Two input and one output arrays must have the same shape
			''' </summary>
	'         #if NOT_EXCLUDED(OP_zeta)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class zeta extends DeclarableOp
			public static class zeta extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public zeta(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public zeta(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public zeta position(Long position)
				If True Then
					Return CType(MyBase.position(position), zeta)
				End If
				public zeta getPointer(Long i)
				If True Then
					Return (New zeta(CType(Me, Pointer))).position(position + i)
				End If

																						public zeta()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates polygamma function psi^(n)(x). Implementation is based on serial representation written in
			''' terms of the Hurwitz zeta function: polygamma = (-1)^{n+1} * n! * zeta(n+1, x).
			''' 
			''' Input arrays:
			'''    0: n - define derivative order (n+1), type integer (however currently is implemented as float casted to integer)
			'''    1: x - abscissa points where to evaluate the polygamma function, type float
			''' 
			''' Output array:
			'''    0: values of polygamma function at corresponding x, type float
			''' 
			''' Two input and one output arrays have the same shape
			''' </summary>
	'         #if NOT_EXCLUDED(OP_polygamma)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class polygamma extends DeclarableOp
			public static class polygamma extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public polygamma(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public polygamma(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public polygamma position(Long position)
				If True Then
					Return CType(MyBase.position(position), polygamma)
				End If
				public polygamma getPointer(Long i)
				If True Then
					Return (New polygamma(CType(Me, Pointer))).position(position + i)
				End If

																						public polygamma()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates lgamma function lgamma(x) = log(Gamma(x))
		   ''' 
		   ''' Input arrays:
		   '''    0: x - input matrix
		   ''' 
		   ''' Output array:
		   '''    0: log of Gamma(x)
		   ''' 
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_lgamma)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lgamma extends DeclarableOp
			public static class lgamma extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lgamma(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lgamma(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lgamma position(Long position)
				If True Then
					Return CType(MyBase.position(position), lgamma)
				End If
				public lgamma getPointer(Long i)
				If True Then
					Return (New lgamma(CType(Me, Pointer))).position(position + i)
				End If

														public lgamma()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates digamma function psi(x) = derivative of log(Gamma(x))
			''' 
			''' Input arrays:
			'''    0: x - abscissa points where to evaluate the digamma function, type float
			''' 
			''' Output array:
			'''    0: values of digamma function at corresponding x, type float
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_digamma)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class digamma extends DeclarableOp
			public static class digamma extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public digamma(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public digamma(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public digamma position(Long position)
				If True Then
					Return CType(MyBase.position(position), digamma)
				End If
				public digamma getPointer(Long i)
				If True Then
					Return (New digamma(CType(Me, Pointer))).position(position + i)
				End If

																						public digamma()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation takes shape as first argument, and returns new NDArray filled with specific scalar value.
			''' Input arrays:
			''' 0 - shape vector
			''' 1 - optional scalar NDArray
			''' 
			''' T arguments:
			''' 0 - optional scalar value
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_fill)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class fill extends DeclarableCustomOp
			public static class fill extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public fill(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public fill(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public fill position(Long position)
				If True Then
					Return CType(MyBase.position(position), fill)
				End If
				public fill getPointer(Long i)
				If True Then
					Return (New fill(CType(Me, Pointer))).position(position + i)
				End If

																						public fill()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation splits given NDArray into chunks of specific size, along given dimension
			''' Input arrays:
			''' 0 - input array
			''' 1 - array of sizes
			''' 2 - optional axis
			''' 
			''' Integer arguments:
			''' 0 - optional axis
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_split_v)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class split_v extends DeclarableCustomOp
			public static class split_v extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public split_v(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public split_v(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public split_v position(Long position)
				If True Then
					Return CType(MyBase.position(position), split_v)
				End If
				public split_v getPointer(Long i)
				If True Then
					Return (New split_v(CType(Me, Pointer))).position(position + i)
				End If

																						public split_v()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation splits given NDArray into chunks of specific size, along given dimension
			''' 0 - input array
			''' 1 - optional axis
			''' 
			''' Integer arguments:
			''' 0 - number of splits
			''' 1 - optional axis
			''' </summary>
	'         #if NOT_EXCLUDED(OP_split)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class split extends DeclarableCustomOp
			public static class split extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public split(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public split(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public split position(Long position)
				If True Then
					Return CType(MyBase.position(position), split)
				End If
				public split getPointer(Long i)
				If True Then
					Return (New split(CType(Me, Pointer))).position(position + i)
				End If

																						public split()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This operation adjusts image hue by delta
			''' Input arrays:
			''' 0 - input array with rank >= 3, must have at least one dimension equal 3, that is dimension containing channels.
			''' 1 - optional argument, input scalar-array containing delta
			''' 
			''' T arguments:
			''' 0 - optional argument, delta value
			''' 
			''' Int arguments:
			''' 0 - optional argument, corresponds to dimension with 3 channels
			''' </summary>
	'         #if NOT_EXCLUDED(OP_adjust_hue)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class adjust_hue extends DeclarableOp
			public static class adjust_hue extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public adjust_hue(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public adjust_hue(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public adjust_hue position(Long position)
				If True Then
					Return CType(MyBase.position(position), adjust_hue)
				End If
				public adjust_hue getPointer(Long i)
				If True Then
					Return (New adjust_hue(CType(Me, Pointer))).position(position + i)
				End If

																						public adjust_hue()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation adjusts image saturation by delta
			''' Input arrays:
			''' 0 - input array with rank >= 3, must have at least one dimension equal 3, that is dimension containing channels.
			''' 1 - optional argument, input scalar-array containing saturation factor
			''' 
			''' T arguments:
			''' 0 - optional argument, saturation factor
			''' 
			''' Int arguments:
			''' 0 - optional argument, corresponds to dimension with 3 channels
			''' </summary>
	'         #if NOT_EXCLUDED(OP_adjust_saturation)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class adjust_saturation extends DeclarableOp
			public static class adjust_saturation extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public adjust_saturation(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public adjust_saturation(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public adjust_saturation position(Long position)
				If True Then
					Return CType(MyBase.position(position), adjust_saturation)
				End If
				public adjust_saturation getPointer(Long i)
				If True Then
					Return (New adjust_saturation(CType(Me, Pointer))).position(position + i)
				End If

																						public adjust_saturation()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation adjusts image contrast by given factor ( z = (x - mean) * factor + mean )
			''' Input arrays:
			''' 0 - input array with rank >= 3, must have last one dimension equal 3, that is dimension containing channels.
			''' 1 - optional argument, input scalar-array containing saturation contrast factor
			''' 
			''' T arguments:
			''' 0 - optional argument, contrast factor
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_adjust_contrast)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class adjust_contrast extends DeclarableOp
			public static class adjust_contrast extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public adjust_contrast(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public adjust_contrast(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public adjust_contrast position(Long position)
				If True Then
					Return CType(MyBase.position(position), adjust_contrast)
				End If
				public adjust_contrast getPointer(Long i)
				If True Then
					Return (New adjust_contrast(CType(Me, Pointer))).position(position + i)
				End If

																						public adjust_contrast()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class adjust_contrast_v2 extends DeclarableOp
			public static class adjust_contrast_v2 extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public adjust_contrast_v2(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public adjust_contrast_v2(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public adjust_contrast_v2 position(Long position)
				If True Then
					Return CType(MyBase.position(position), adjust_contrast_v2)
				End If
				public adjust_contrast_v2 getPointer(Long i)
				If True Then
					Return (New adjust_contrast_v2(CType(Me, Pointer))).position(position + i)
				End If

																						public adjust_contrast_v2()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif




			''' <summary>
			''' This operation rearranges data from depth into blocks of spatial data. This is the reverse transformation
			''' of space_to_depth op. This op output is a copy of the input tensor where values from the depth dimension
			''' are moved in spatial blocks to the height and width dimensions. Int attr 0 indicates the input
			''' block size and how the data is moved.
			''' Input:
			'''     0 - 4D tensor on given type
			''' Output:
			'''     0 - 4D tensor of given type and proper shape
			''' 
			''' Int arguments:
			'''     0 - block size
			'''     1 - output data format: 0 ("NHWC"): shape{ batch, height, width, channels }
			'''                             1 ("NCHW"): shape{ batch, channels, height, width }
			'''                             2 ("NCHW_VECT_C"): int8 shape{ batch, channels / 4, height, width, 4 }
			'''                             optional (default 0)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_depth_to_space)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class depth_to_space extends DeclarableCustomOp
			public static class depth_to_space extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public depth_to_space(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public depth_to_space(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public depth_to_space position(Long position)
				If True Then
					Return CType(MyBase.position(position), depth_to_space)
				End If
				public depth_to_space getPointer(Long i)
				If True Then
					Return (New depth_to_space(CType(Me, Pointer))).position(position + i)
				End If

																						public depth_to_space()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation rearranges blocks of spatial data, into depth.This op output is a copy of the input tensor
			''' where values from the height and width dimensions are moved to the depth dimension. Int attr 0 indicates
			''' the input block size.
			''' 
			''' Input:
			'''     - 4D tensor of given type
			''' Output:
			'''     - 4D tensor
			''' 
			''' Int arguments:
			'''     0 - block size
			'''     1 - output data format: 0 ("NHWC"): shape{ batch, height, width, channels }
			'''                             1 ("NCHW"): shape{ batch, channels, height, width }
			'''                             2 ("NCHW_VECT_C"): int8 shape{ batch, channels / 4, height, width, 4 }
			'''                             optional (default 0)
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_space_to_depth)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class space_to_depth extends DeclarableCustomOp
			public static class space_to_depth extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public space_to_depth(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public space_to_depth(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public space_to_depth position(Long position)
				If True Then
					Return CType(MyBase.position(position), space_to_depth)
				End If
				public space_to_depth getPointer(Long i)
				If True Then
					Return (New space_to_depth(CType(Me, Pointer))).position(position + i)
				End If

																						public space_to_depth()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates cross-product between input arguments
			''' Input arguments
			''' 0 - vector or tensor A
			''' 1 - vector or tensor B
			''' </summary>
	'         #if NOT_EXCLUDED(OP_cross)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cross extends DeclarableOp
			public static class cross extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cross(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cross(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cross position(Long position)
				If True Then
					Return CType(MyBase.position(position), cross)
				End If
				public cross getPointer(Long i)
				If True Then
					Return (New cross(CType(Me, Pointer))).position(position + i)
				End If

														public cross()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Zero-pads and then rearranges (permutes) blocks of spatial data into batch. More specifically, this op
			''' outputs a copy of the input tensor where values from the height and width dimensions are moved to the
			''' batch dimension. After the zero-padding, both height and width of the input must be divisible by the block
			''' size.
			''' 
			''' Inputs:
			'''  0 - input tensor
			'''  1 - 2D paddings tensor (shape {M, 2})
			''' 
			'''  Output:
			'''    - result tensor
			''' 
			'''  Int args:
			'''      0 - block size (M)
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_space_to_batch)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class space_to_batch extends DeclarableCustomOp
			public static class space_to_batch extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public space_to_batch(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public space_to_batch(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public space_to_batch position(Long position)
				If True Then
					Return CType(MyBase.position(position), space_to_batch)
				End If
				public space_to_batch getPointer(Long i)
				If True Then
					Return (New space_to_batch(CType(Me, Pointer))).position(position + i)
				End If

																						public space_to_batch()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'        
	'         * This operation divides "spatial" dimensions [1, ..., M] of the input into a grid of blocks of shape
	'         * block_shape, and interleaves these blocks with the "batch" dimension (0) such that in the output,
	'         * the spatial dimensions [1, ..., M] correspond to the position within the grid, and the batch dimension
	'         * combines both the position within a spatial block and the original batch position. Prior to division into
	'         * blocks, the spatial dimensions of the input are optionally zero padded according to paddings.
	'         *
	'         * Inputs:
	'         *      0 - input (N-D tensor)
	'         *      1 - block_shape - int 1D tensor with M length
	'         *      2 - paddings - int 2D tensor with shape {M, 2}
	'         *
	'         * Output:
	'         *      - N-D tensor with the same type as input 0.
	'         *
	'         * 
	'         #if NOT_EXCLUDED(OP_space_to_batch_nd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class space_to_batch_nd extends DeclarableCustomOp
			public static class space_to_batch_nd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public space_to_batch_nd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public space_to_batch_nd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public space_to_batch_nd position(Long position)
				If True Then
					Return CType(MyBase.position(position), space_to_batch_nd)
				End If
				public space_to_batch_nd getPointer(Long i)
				If True Then
					Return (New space_to_batch_nd(CType(Me, Pointer))).position(position + i)
				End If

																						public space_to_batch_nd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' 
			''' 
	'         #if NOT_EXCLUDED(OP_batch_to_space)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class batch_to_space extends DeclarableCustomOp
			public static class batch_to_space extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public batch_to_space(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public batch_to_space(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public batch_to_space position(Long position)
				If True Then
					Return CType(MyBase.position(position), batch_to_space)
				End If
				public batch_to_space getPointer(Long i)
				If True Then
					Return (New batch_to_space(CType(Me, Pointer))).position(position + i)
				End If

																						public batch_to_space()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_batch_to_space_nd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class batch_to_space_nd extends DeclarableCustomOp
			public static class batch_to_space_nd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public batch_to_space_nd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public batch_to_space_nd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public batch_to_space_nd position(Long position)
				If True Then
					Return CType(MyBase.position(position), batch_to_space_nd)
				End If
				public batch_to_space_nd getPointer(Long i)
				If True Then
					Return (New batch_to_space_nd(CType(Me, Pointer))).position(position + i)
				End If

																						public batch_to_space_nd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' top_k operation returns a vector of k top values for
			'''  given NDArray as tensor with default boolean (true)
			'''  as sort for result index array
			'''  will be sorted by the values in descending order.
			'''  The first parameter is a NDArray for working.
			'''  The second is k (default 1) - optional
			'''  The third is boolean value(default is true) (0 - as is, 1 - sorted by value) optional
			''' </summary>
	'         #if NOT_EXCLUDED(OP_top_k)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class top_k extends DeclarableCustomOp
			public static class top_k extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public top_k(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public top_k(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public top_k position(Long position)
				If True Then
					Return CType(MyBase.position(position), top_k)
				End If
				public top_k getPointer(Long i)
				If True Then
					Return (New top_k(CType(Me, Pointer))).position(position + i)
				End If

																						public top_k()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' in_top_k operation returns a vector of k boolean values for
			'''  given NDArray as 2D matrix of predicted in the NDArray k top values
			'''  The first parameter is a NDArray of predicted values (2d array).
			'''  The second is NDArray as vector of indeces k top values will be search.
			'''  The third is k
			''' </summary>
	'         #if NOT_EXCLUDED(OP_in_top_k)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class in_top_k extends DeclarableCustomOp
			public static class in_top_k extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public in_top_k(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public in_top_k(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public in_top_k position(Long position)
				If True Then
					Return CType(MyBase.position(position), in_top_k)
				End If
				public in_top_k getPointer(Long i)
				If True Then
					Return (New in_top_k(CType(Me, Pointer))).position(position + i)
				End If

																						public in_top_k()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' moments operation calculate a mean and variation for given NDArray
			''' with reduce a result according to axis array given.
			''' For full axis the result is both mean and variance of all members in array.
			''' Otherwise there are two NDArrays with means and variances for
			''' Axes can be put as the second NDArray or as int vector.
			''' 
			''' the optional flag "keep_dims" can be set as T param
			''' </summary>
	'         #if NOT_EXCLUDED(OP_moments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class moments extends DeclarableCustomOp
			public static class moments extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public moments(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public moments(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public moments position(Long position)
				If True Then
					Return CType(MyBase.position(position), moments)
				End If
				public moments getPointer(Long i)
				If True Then
					Return (New moments(CType(Me, Pointer))).position(position + i)
				End If

																						public moments()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' embedding_lookup - search for submatrices in given matrix and retunts them
			''' accordingly to index array given.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_embedding_lookup)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class embedding_lookup extends DeclarableCustomOp
			public static class embedding_lookup extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public embedding_lookup(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public embedding_lookup(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public embedding_lookup position(Long position)
				If True Then
					Return CType(MyBase.position(position), embedding_lookup)
				End If
				public embedding_lookup getPointer(Long i)
				If True Then
					Return (New embedding_lookup(CType(Me, Pointer))).position(position + i)
				End If

																						public embedding_lookup()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' dynamic_partition - partition a input tensor onto num_partitions
			''' accordingly to index array given.
			''' 
			''' the first param - NDArray to be partitioned.
			''' the second param - index array
			''' the third param (integer param) - num or partitions.
			''' 
			''' returns a num of NDArrays as output
			''' </summary>
	'         #if NOT_EXCLUDED(OP_dynamic_partition)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dynamic_partition extends DeclarableCustomOp
			public static class dynamic_partition extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dynamic_partition(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dynamic_partition(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dynamic_partition position(Long position)
				If True Then
					Return CType(MyBase.position(position), dynamic_partition)
				End If
				public dynamic_partition getPointer(Long i)
				If True Then
					Return (New dynamic_partition(CType(Me, Pointer))).position(position + i)
				End If

																						public dynamic_partition()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_dynamic_partition_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dynamic_partition_bp extends DeclarableCustomOp
			public static class dynamic_partition_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dynamic_partition_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dynamic_partition_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dynamic_partition_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), dynamic_partition_bp)
				End If
				public dynamic_partition_bp getPointer(Long i)
				If True Then
					Return (New dynamic_partition_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public dynamic_partition_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' dynamic_stitch - merge partitions from the second param a input tensor
			''' into a single tensor accordingly to index array given.
			''' 
			''' the first param - index array
			''' the second params - tensors to be merged
			''' 
			''' returns a num of NDArrays as output
			''' 
			''' the operation is inversion od dynamic_partition
			''' </summary>
	'         #if NOT_EXCLUDED(OP_dynamic_stitch)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dynamic_stitch extends DeclarableCustomOp
			public static class dynamic_stitch extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dynamic_stitch(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dynamic_stitch(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dynamic_stitch position(Long position)
				If True Then
					Return CType(MyBase.position(position), dynamic_stitch)
				End If
				public dynamic_stitch getPointer(Long i)
				If True Then
					Return (New dynamic_stitch(CType(Me, Pointer))).position(position + i)
				End If

																						public dynamic_stitch()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' zero_fraction op.
			''' compute a fraction of zeros in given array
			''' 
			''' input param - an array (tensor)
			''' output value - a real number with given type (e.g. float or double)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_zero_fraction)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class zero_fraction extends DeclarableCustomOp
			public static class zero_fraction extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public zero_fraction(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public zero_fraction(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public zero_fraction position(Long position)
				If True Then
					Return CType(MyBase.position(position), zero_fraction)
				End If
				public zero_fraction getPointer(Long i)
				If True Then
					Return (New zero_fraction(CType(Me, Pointer))).position(position + i)
				End If

																						public zero_fraction()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' xw_plus_b op.
			''' multiply two first matrices and add third vector to each row of result
			''' 
			''' input params:
			'''   - 2D matrix NxM
			'''   - 2D matrix MxN
			'''   - 1D vector with N elements
			''' output value - 2D matrix NxN as multiply of matrixes and add vector
			''' Int args:
			'''      0 - optional switcher of weights format, if int arg == 1 - mkldnn, else mmul
			''' </summary>
	'         #if NOT_EXCLUDED(OP_xw_plus_b)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class xw_plus_b extends DeclarableCustomOp
					public static class xw_plus_b extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public xw_plus_b(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public xw_plus_b(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public xw_plus_b position(Long position)
						If True Then
							Return CType(MyBase.position(position), xw_plus_b)
						End If
						public xw_plus_b getPointer(Long i)
						If True Then
							Return (New xw_plus_b(CType(Me, Pointer))).position(position + i)
						End If

																						public xw_plus_b()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class xw_plus_b_bp extends DeclarableCustomOp
					public static class xw_plus_b_bp extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public xw_plus_b_bp(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public xw_plus_b_bp(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public xw_plus_b_bp position(Long position)
						If True Then
							Return CType(MyBase.position(position), xw_plus_b_bp)
						End If
						public xw_plus_b_bp getPointer(Long i)
						If True Then
							Return (New xw_plus_b_bp(CType(Me, Pointer))).position(position + i)
						End If

																						public xw_plus_b_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

			''' <summary>
			''' This operation is missed due it simplicy.
			''' Input and output params are the same after operation.
			''' Input - NDArray, output - NDArray with the same shape.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_stop_gradient)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class stop_gradient extends DeclarableOp
			public static class stop_gradient extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public stop_gradient(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public stop_gradient(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public stop_gradient position(Long position)
				If True Then
					Return CType(MyBase.position(position), stop_gradient)
				End If
				public stop_gradient getPointer(Long i)
				If True Then
					Return (New stop_gradient(CType(Me, Pointer))).position(position + i)
				End If

														public stop_gradient()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_parallel_stack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class parallel_stack extends DeclarableCustomOp
			public static class parallel_stack extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public parallel_stack(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public parallel_stack(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public parallel_stack position(Long position)
				If True Then
					Return CType(MyBase.position(position), parallel_stack)
				End If
				public parallel_stack getPointer(Long i)
				If True Then
					Return (New parallel_stack(CType(Me, Pointer))).position(position + i)
				End If

																						public parallel_stack()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' normalize_moments operation normalize already calculated mean and variation
			''' accordingly to shift and count.
			''' input params:
			'''  - count of data
			'''  - tensor with mean
			'''  - tensor with variance (the same shape as before)
			''' 
			'''  - optional floating point param shift.
			''' 
			'''  returns a normalized pair mean and variance with the same shapes as input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_normalize_moments)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class normalize_moments extends DeclarableCustomOp
			public static class normalize_moments extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public normalize_moments(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public normalize_moments(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public normalize_moments position(Long position)
				If True Then
					Return CType(MyBase.position(position), normalize_moments)
				End If
				public normalize_moments getPointer(Long i)
				If True Then
					Return (New normalize_moments(CType(Me, Pointer))).position(position + i)
				End If

																						public normalize_moments()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' sufficient_statistics operation return calculated mean and variation with data count.
			''' this operation is invert for moments
			''' accordingly to shift and count.
			''' input params:
			'''  - input tensor
			'''  - axes vector
			''' 
			''' 
			'''  - optional floating point param shift.
			'''  - optional int (as bool) keep_dimension
			''' 
			'''  returns four tensors:
			'''     - scalar tensor (data count)
			'''     - sum elements of input (accross axises)
			'''     - sum of squares of input (accross axises)
			'''     - shift (if was given by input floating param)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_sufficient_statistics)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sufficient_statistics extends DeclarableCustomOp
			public static class sufficient_statistics extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sufficient_statistics(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sufficient_statistics(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sufficient_statistics position(Long position)
				If True Then
					Return CType(MyBase.position(position), sufficient_statistics)
				End If
				public sufficient_statistics getPointer(Long i)
				If True Then
					Return (New sufficient_statistics(CType(Me, Pointer))).position(position + i)
				End If

																						public sufficient_statistics()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates weighted logarithmic loss of input
			''' Input arguments
			'''  0 - target
			'''  1 - input
			'''  2 - weights (scalar or vector with same as last dimension)
			''' 
			'''  return value - a tensor with the same shape as target or input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_weighted_cross_entropy_with_logits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class weighted_cross_entropy_with_logits extends DeclarableOp
			public static class weighted_cross_entropy_with_logits extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public weighted_cross_entropy_with_logits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public weighted_cross_entropy_with_logits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public weighted_cross_entropy_with_logits position(Long position)
				If True Then
					Return CType(MyBase.position(position), weighted_cross_entropy_with_logits)
				End If
				public weighted_cross_entropy_with_logits getPointer(Long i)
				If True Then
					Return (New weighted_cross_entropy_with_logits(CType(Me, Pointer))).position(position + i)
				End If

														public weighted_cross_entropy_with_logits()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates dropout of input
			''' Input arguments
			'''  0 - input tensor
			'''  1 - noise_shape - (vector with shape to reduce) - optional
			''' 
			'''  int parameter - seed for random numbers
			'''  T parameter - probability (should be between 0 and 1)
			'''  return value - a tensor with the same shape as target or input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_dropout)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dropout extends DeclarableOp
			public static class dropout extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dropout(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dropout(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dropout position(Long position)
				If True Then
					Return CType(MyBase.position(position), dropout)
				End If
				public dropout getPointer(Long i)
				If True Then
					Return (New dropout(CType(Me, Pointer))).position(position + i)
				End If

																						public dropout()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_dropout_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dropout_bp extends DeclarableOp
			public static class dropout_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public dropout_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public dropout_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public dropout_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), dropout_bp)
				End If
				public dropout_bp getPointer(Long i)
				If True Then
					Return (New dropout_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public dropout_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'          Calculates alpha weighted dropout
	'            T params:
	'                0 - drop probability
	'                1 - alpha value
	'                2 - alpha' value
	'                3 - beta value
	'         
	'         #if NOT_EXCLUDED(OP_alpha_dropout_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class alpha_dropout_bp extends DeclarableOp
			public static class alpha_dropout_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public alpha_dropout_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public alpha_dropout_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public alpha_dropout_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), alpha_dropout_bp)
				End If
				public alpha_dropout_bp getPointer(Long i)
				If True Then
					Return (New alpha_dropout_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public alpha_dropout_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' bincount operation return a vector with element counted.
			''' 
			''' input params:
			'''  - input tensor - only int part are accepted
			'''  - weights - the same shape tensor with integer weights for element (optional)
			'''  default weight - 1,1,1..,1 for all values in the tensor
			''' 
			'''  optional ints:
			'''  - min_length - zero or greater
			'''  - max_length - between min_length and max(input) + 1
			''' 
			'''  returns four tensors:
			'''     - vector tensor with length to min(max_len, max(input) + 1) with count
			'''  of values in indexed place
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bincount)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bincount extends DeclarableCustomOp
			public static class bincount extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public bincount(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public bincount(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public bincount position(Long position)
				If True Then
					Return CType(MyBase.position(position), bincount)
				End If
				public bincount getPointer(Long i)
				If True Then
					Return (New bincount(CType(Me, Pointer))).position(position + i)
				End If

																						public bincount()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' broadcast_dynamic_shape op.
			''' 
			''' input params:
			'''    0 - the first shape (vector with shape)
			'''    1 - the second shape (vector with shape)
			''' 
			''' return value:
			'''    vector with broadcasted shape
			''' </summary>
	'         #if NOT_EXCLUDED(OP_broadcast_dynamic_shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class broadcast_dynamic_shape extends DeclarableCustomOp
			public static class broadcast_dynamic_shape extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public broadcast_dynamic_shape(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public broadcast_dynamic_shape(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public broadcast_dynamic_shape position(Long position)
				If True Then
					Return CType(MyBase.position(position), broadcast_dynamic_shape)
				End If
				public broadcast_dynamic_shape getPointer(Long i)
				If True Then
					Return (New broadcast_dynamic_shape(CType(Me, Pointer))).position(position + i)
				End If

																						public broadcast_dynamic_shape()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' matrix_determinant op.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M)
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: *) with determinant for all
			''' M x M matricies
			''' </summary>
	'         #if NOT_EXCLUDED(OP_matrix_determinant)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_determinant extends DeclarableCustomOp
			public static class matrix_determinant extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_determinant(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_determinant(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_determinant position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_determinant)
				End If
				public matrix_determinant getPointer(Long i)
				If True Then
					Return (New matrix_determinant(CType(Me, Pointer))).position(position + i)
				End If

																						public matrix_determinant()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' log_matrix_determinant op.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M)
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: *) with log determinant for all
			''' M x M matricies
			''' </summary>

	'         #if NOT_EXCLUDED(OP_log_matrix_determinant)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_matrix_determinant extends DeclarableCustomOp
			public static class log_matrix_determinant extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_matrix_determinant(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_matrix_determinant(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_matrix_determinant position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_matrix_determinant)
				End If
				public log_matrix_determinant getPointer(Long i)
				If True Then
					Return (New log_matrix_determinant(CType(Me, Pointer))).position(position + i)
				End If

																						public log_matrix_determinant()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' logdet op. Logarithm of the determinant of hermitian positive matricies.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M)
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: *) with log determinant for all
			''' M x M matricies
			''' </summary>

	'         #if NOT_EXCLUDED(OP_logdet)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class logdet extends DeclarableCustomOp
			public static class logdet extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public logdet(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public logdet(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public logdet position(Long position)
				If True Then
					Return CType(MyBase.position(position), logdet)
				End If
				public logdet getPointer(Long i)
				If True Then
					Return (New logdet(CType(Me, Pointer))).position(position + i)
				End If

																						public logdet()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' matrix_solve_ls op (lstsq) - solves one or more linear least-squares problems.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * N) - left parts of equations
			'''    1 - the tensor with dimension (x * y * z * ::: * M * K) - right parts of equations
			''' 
			''' float args:
			'''    0 - l2_regularizer (default 0. and only for 0 implemented)
			''' 
			''' boolean args:
			'''    0 - fast - default is true (optional) - use Cholesky decomposition instead QR decomposition of matricies.
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: * N * K) with solutions
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lstsq)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lstsq extends DeclarableCustomOp
			public static class lstsq extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lstsq(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lstsq(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lstsq position(Long position)
				If True Then
					Return CType(MyBase.position(position), lstsq)
				End If
				public lstsq getPointer(Long i)
				If True Then
					Return (New lstsq(CType(Me, Pointer))).position(position + i)
				End If

																						public lstsq()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         solve_ls - analog of lstsq op with another solution approach
	'         *
	'         * input params:
	'         *    0 - the tensor with dimension (x * y * z * ::: * M * N) - left parts of equations
	'         *    1 - the tensor with dimension (x * y * z * ::: * M * K) - right parts of equations
	'         *
	'         * float args:
	'         *    0 - l2_regularizer (default 0. and only for 0 implemented)
	'         *
	'         * boolean args:
	'         *    0 - fast - default is true (optional) - use Cholesky decomposition instead QR decomposition of matricies.
	'         *
	'         * return value:
	'         *    tensor with dimension (x * y * z * ::: * N * K) with solutions
	'         *
	'         * Note: if fast is false - then l2_regularizer arg is ignored and used lstsq method due QR decomposition
	'         * 
	'         #if NOT_EXCLUDED(OP_solve_ls)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class solve_ls extends DeclarableCustomOp
					public static class solve_ls extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public solve_ls(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public solve_ls(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public solve_ls position(Long position)
						If True Then
							Return CType(MyBase.position(position), solve_ls)
						End If
						public solve_ls getPointer(Long i)
						If True Then
							Return (New solve_ls(CType(Me, Pointer))).position(position + i)
						End If

																						public solve_ls()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

			''' <summary>
			''' matrix_inverse op. - make inverse for all 2D square matricies found in the input tensor
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M)
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: * M * M) with inverse M x M matricies in it
			''' </summary>
	'         #if NOT_EXCLUDED(OP_matrix_inverse)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_inverse extends DeclarableOp
			public static class matrix_inverse extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_inverse(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_inverse(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_inverse position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_inverse)
				End If
				public matrix_inverse getPointer(Long i)
				If True Then
					Return (New matrix_inverse(CType(Me, Pointer))).position(position + i)
				End If

														public matrix_inverse()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' triangular_solve op. - reverse Gaussian method for solve systems of linear equations.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M) - left parts of equations
			'''    1 - the tensor with dimension (x * y * z * ::: * M * K) - right parts of equations
			''' 
			''' boolean args:
			'''    0 - lower - default is true (optional) - left part is lower triangular matrix
			'''    1 - adjoint - default is false (optional) - indicate input matrix or its adjoint (hermitian addition) should be used
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: * M * K) with solutions
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_triangular_solve)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class triangular_solve extends DeclarableCustomOp
			public static class triangular_solve extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public triangular_solve(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public triangular_solve(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public triangular_solve position(Long position)
				If True Then
					Return CType(MyBase.position(position), triangular_solve)
				End If
				public triangular_solve getPointer(Long i)
				If True Then
					Return (New triangular_solve(CType(Me, Pointer))).position(position + i)
				End If

																						public triangular_solve()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' solve op. - solve systems of linear equations - general method.
			''' 
			''' input params:
			'''    0 - the tensor with dimension (x * y * z * ::: * M * M) - left parts of equations
			'''    1 - the tensor with dimension (x * y * z * ::: * M * K) - right parts of equations
			''' 
			''' boolean args:
			'''    0 - adjoint - default is false (optional) - indicate input matrix or its adjoint (hermitian addition) should be used
			''' 
			''' return value:
			'''    tensor with dimension (x * y * z * ::: * M * K) with solutions
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_solve)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class solve extends DeclarableCustomOp
			public static class solve extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public solve(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public solve(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public solve position(Long position)
				If True Then
					Return CType(MyBase.position(position), solve)
				End If
				public solve getPointer(Long i)
				If True Then
					Return (New solve(CType(Me, Pointer))).position(position + i)
				End If

																						public solve()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' lu op. - make LUP decomposition of given batch of 2D square matricies
			''' 
			''' input params:
			'''    0 - float tensor with dimension (x * y * z * ::: * M * M)
			''' 
			''' return value:
			'''    0 - float tensor with dimension (x * y * z * ::: * M * M) with LU M x M matricies in it
			'''    1 - int (32 or 64) batched vector of permutations with length M - shape (x * y * z * ::: * M)
			''' 
			''' int argument:
			'''    0 - data type of output permutaion vector (int32 or int64), optional, default INT32
			''' </summary>

	'         #if NOT_EXCLUDED(OP_matrix_inverse)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lu extends DeclarableCustomOp
			public static class lu extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lu(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lu(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lu position(Long position)
				If True Then
					Return CType(MyBase.position(position), lu)
				End If
				public lu getPointer(Long i)
				If True Then
					Return (New lu(CType(Me, Pointer))).position(position + i)
				End If

																						public lu()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' sequence_mask op. - make mask for given tensor filled by (j > x[i_1, i_2,...,i_n]) -> z[i_1, i_2,...,i_n,j]
			''' 
			''' input params:
			'''    0 - the ND-tensor filled by integer-like values
			''' 
			''' optional int param - maxlength (maxlength >= max(x)). By default maxlength = max(x).
			''' return value:
			'''    (N+1)D tensor filled by 0 and 1 accordingly the mask
			''' </summary>
	'         #if NOT_EXCLUDED(OP_sequence_mask)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sequence_mask extends DeclarableCustomOp
			public static class sequence_mask extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sequence_mask(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sequence_mask(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sequence_mask position(Long position)
				If True Then
					Return CType(MyBase.position(position), sequence_mask)
				End If
				public sequence_mask getPointer(Long i)
				If True Then
					Return (New sequence_mask(CType(Me, Pointer))).position(position + i)
				End If

																						public sequence_mask()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
			''' <summary>
			''' segment_max op. - make a tensor filled by max values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with max values according to indices sets.
			''' </summary>

	'         #if NOT_EXCLUDED(OP_segment_max)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_max extends DeclarableCustomOp
			public static class segment_max extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_max(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_max(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_max position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_max)
				End If
				public segment_max getPointer(Long i)
				If True Then
					Return (New segment_max(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_max()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_segment_max_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_max_bp extends DeclarableCustomOp
			public static class segment_max_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_max_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_max_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_max_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_max_bp)
				End If
				public segment_max_bp getPointer(Long i)
				If True Then
					Return (New segment_max_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_max_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' segment_min op. - make a tensor filled by min values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with min values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_segment_min)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_min extends DeclarableCustomOp
			public static class segment_min extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_min(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_min(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_min position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_min)
				End If
				public segment_min getPointer(Long i)
				If True Then
					Return (New segment_min(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_min()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_segment_min_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_min_bp extends DeclarableCustomOp
			public static class segment_min_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_min_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_min_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_min_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_min_bp)
				End If
				public segment_min_bp getPointer(Long i)
				If True Then
					Return (New segment_min_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_min_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' segment_sum op. - make a tensor filled by sum of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with sum of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_segment_sum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_sum extends DeclarableCustomOp
			public static class segment_sum extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_sum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_sum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_sum position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_sum)
				End If
				public segment_sum getPointer(Long i)
				If True Then
					Return (New segment_sum(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_sum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_segment_sum_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_sum_bp extends DeclarableCustomOp
			public static class segment_sum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_sum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_sum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_sum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_sum_bp)
				End If
				public segment_sum_bp getPointer(Long i)
				If True Then
					Return (New segment_sum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_sum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' segment_prod op. - make a tensor filled by product of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with product of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_segment_prod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_prod extends DeclarableCustomOp
			public static class segment_prod extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_prod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_prod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_prod position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_prod)
				End If
				public segment_prod getPointer(Long i)
				If True Then
					Return (New segment_prod(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_prod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_segment_prod_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_prod_bp extends DeclarableCustomOp
			public static class segment_prod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_prod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_prod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_prod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_prod_bp)
				End If
				public segment_prod_bp getPointer(Long i)
				If True Then
					Return (New segment_prod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_prod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
			''' <summary>
			''' segment_mean op. - make a tensor filled by average of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with average of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_segment_mean)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_mean extends DeclarableCustomOp
			public static class segment_mean extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_mean(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_mean(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_mean position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_mean)
				End If
				public segment_mean getPointer(Long i)
				If True Then
					Return (New segment_mean(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_mean()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_segment_mean_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class segment_mean_bp extends DeclarableCustomOp
			public static class segment_mean_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public segment_mean_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public segment_mean_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public segment_mean_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), segment_mean_bp)
				End If
				public segment_mean_bp getPointer(Long i)
				If True Then
					Return (New segment_mean_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public segment_mean_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_max op. - make a tensor filled by max values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' return value:
			'''    tensor with max values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_max)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_max extends DeclarableCustomOp
			public static class unsorted_segment_max extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_max(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_max(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_max position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_max)
				End If
				public unsorted_segment_max getPointer(Long i)
				If True Then
					Return (New unsorted_segment_max(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_max()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_max_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_max_bp extends DeclarableCustomOp
			public static class unsorted_segment_max_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_max_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_max_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_max_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_max_bp)
				End If
				public unsorted_segment_max_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_max_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_max_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_min op. - make a tensor filled by min values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' integer param:
			'''    0 - num of segments
			''' 
			''' return value:
			'''    tensor with min values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_min_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_min extends DeclarableCustomOp
			public static class unsorted_segment_min extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_min(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_min(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_min position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_min)
				End If
				public unsorted_segment_min getPointer(Long i)
				If True Then
					Return (New unsorted_segment_min(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_min()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_min_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_min_bp extends DeclarableCustomOp
			public static class unsorted_segment_min_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_min_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_min_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_min_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_min_bp)
				End If
				public unsorted_segment_min_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_min_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_min_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_sum op. - make a tensor filled by sum of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' integer param:
			'''    0 - num of segments
			''' 
			''' return value:
			'''    tensor with sum of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_sum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_sum extends DeclarableCustomOp
			public static class unsorted_segment_sum extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_sum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_sum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_sum position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_sum)
				End If
				public unsorted_segment_sum getPointer(Long i)
				If True Then
					Return (New unsorted_segment_sum(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_sum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_sum_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_sum_bp extends DeclarableCustomOp
			public static class unsorted_segment_sum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_sum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_sum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_sum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_sum_bp)
				End If
				public unsorted_segment_sum_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_sum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_sum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_prod op. - make a tensor filled by product of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' integer param:
			'''    0 - num of segments
			''' 
			''' return value:
			'''    tensor with product of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_prod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_prod extends DeclarableCustomOp
			public static class unsorted_segment_prod extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_prod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_prod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_prod position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_prod)
				End If
				public unsorted_segment_prod getPointer(Long i)
				If True Then
					Return (New unsorted_segment_prod(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_prod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_prod_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_prod_bp extends DeclarableCustomOp
			public static class unsorted_segment_prod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_prod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_prod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_prod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_prod_bp)
				End If
				public unsorted_segment_prod_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_prod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_prod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_mean op. - make a tensor filled by average of values according to index tensor given.
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' integer param:
			'''    0 - num of segments
			''' 
			''' return value:
			'''    tensor with average of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_mean)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_mean extends DeclarableCustomOp
			public static class unsorted_segment_mean extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_mean(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_mean(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_mean position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_mean)
				End If
				public unsorted_segment_mean getPointer(Long i)
				If True Then
					Return (New unsorted_segment_mean(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_mean()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_mean_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_mean_bp extends DeclarableCustomOp
			public static class unsorted_segment_mean_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_mean_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_mean_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_mean_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_mean_bp)
				End If
				public unsorted_segment_mean_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_mean_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_mean_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' unsorted_segment_sqrt_n op. - computes the sum along segments of a tensor divided by the sqrt(N).
			''' 
			''' input params:
			'''    0 - the tensor with data;
			'''    1 - the tensor with indices.
			''' 
			''' integer param:
			'''    0 - num of segments
			''' 
			''' return value:
			'''    tensor with average of values according to indices sets.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_unsorted_segment_sqrt)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_sqrt_n extends DeclarableCustomOp
			public static class unsorted_segment_sqrt_n extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_sqrt_n(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_sqrt_n(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_sqrt_n position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_sqrt_n)
				End If
				public unsorted_segment_sqrt_n getPointer(Long i)
				If True Then
					Return (New unsorted_segment_sqrt_n(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_sqrt_n()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_unsorted_segment_sqrt_n_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class unsorted_segment_sqrt_n_bp extends DeclarableCustomOp
			public static class unsorted_segment_sqrt_n_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public unsorted_segment_sqrt_n_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public unsorted_segment_sqrt_n_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public unsorted_segment_sqrt_n_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), unsorted_segment_sqrt_n_bp)
				End If
				public unsorted_segment_sqrt_n_bp getPointer(Long i)
				If True Then
					Return (New unsorted_segment_sqrt_n_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public unsorted_segment_sqrt_n_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' extract_image_patches op - Extract patches from images and put them in the "depth" output dimension.
			''' 
			''' input params:
			'''    0 - images tensor (4D)
			''' 
			''' int params:
			'''    0 - ksize_rows
			'''    1 - ksize_cols
			'''    2 - strides_rows
			'''    3 - strides_cols
			'''    4 - rates_rows
			'''    5 - rates_cols
			'''    6 - padding_type - 0 - equiv 'VALID', 1 - 'SAME'
			''' </summary>
	'         #if NOT_EXCLUDED(OP_extract_image_patches)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class extract_image_patches extends DeclarableCustomOp
			public static class extract_image_patches extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public extract_image_patches(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public extract_image_patches(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public extract_image_patches position(Long position)
				If True Then
					Return CType(MyBase.position(position), extract_image_patches)
				End If
				public extract_image_patches getPointer(Long i)
				If True Then
					Return (New extract_image_patches(CType(Me, Pointer))).position(position + i)
				End If

																						public extract_image_patches()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' draw_bounding_boxes op - modified input image with given colors exept given boxes.
			''' 
			''' input params:
			'''    0 - images tensor (4D) with shape {batch, width, height, channels}, where channes is 1 (BW image),
			''' 3 (RGB) or 4 (RGBA)
			'''    1 - boxes tensor (3D) with shape {batch, number_of_boxes, 4} where last dimension encoded as
			''' (y_min, x_min, y_max, x_max), all values in between 0. and 1.
			'''    2 - colours tensor (2D) with shape {number_of_boxes, channels} -- bordering color set (palette)
			''' 
			''' output:
			'''    0 - 4D tensor with same shape as images (input 0)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_draw_bounding_boxes)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class draw_bounding_boxes extends DeclarableOp
			public static class draw_bounding_boxes extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public draw_bounding_boxes(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public draw_bounding_boxes(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public draw_bounding_boxes position(Long position)
				If True Then
					Return CType(MyBase.position(position), draw_bounding_boxes)
				End If
				public draw_bounding_boxes getPointer(Long i)
				If True Then
					Return (New draw_bounding_boxes(CType(Me, Pointer))).position(position + i)
				End If

														public draw_bounding_boxes()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' roll - op porting from numpy (https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.roll.html)
			''' 
			''' input params:
			'''    0 - NDArray
			''' 
			''' int params:
			'''    0 - shift
			'''    1 - axe 1
			'''    2 - axe 2
			'''    ...
			'''    N - axe N
			''' 
			'''    All axes are optional and should be between 0 and input->rankOf(). Of course, all axes can be repeated.
			''' 
			''' output:
			'''    0 - NDArray with the same shape as input.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_roll)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class roll extends DeclarableOp
			public static class roll extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public roll(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public roll(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public roll position(Long position)
				If True Then
					Return CType(MyBase.position(position), roll)
				End If
				public roll getPointer(Long i)
				If True Then
					Return (New roll(CType(Me, Pointer))).position(position + i)
				End If

																						public roll()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' lin_space - op porting from TF (https://www.tensorflow.org/api_docs/python/tf/lin_space)
			''' 
			''' optional input params:
			'''    0 - startVal - NDArray scalar (float point)
			'''    1 - finishVal - NDArray scalar (float point)
			'''    2 - numOfElements - NDArray scalar (integer)
			''' Optional:
			''' T args
			'''    0 - startVal
			'''    1 - finishVal]
			'''    2 - numOfElements
			''' output:
			'''    0 - 1D NDArray with the same type as input and length as given with numOfElements param.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lin_space)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lin_space extends DeclarableCustomOp
			public static class lin_space extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lin_space(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lin_space(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lin_space position(Long position)
				If True Then
					Return CType(MyBase.position(position), lin_space)
				End If
				public lin_space getPointer(Long i)
				If True Then
					Return (New lin_space(CType(Me, Pointer))).position(position + i)
				End If

																						public lin_space()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' reduction_sum - tf.reduction_sum operation
			''' 
			''' input params:
			'''    0 - NDArray
			''' 
			''' T_ARG param (optional):
			''' 0 - keep_dims != 0.
			''' 
			''' int params (optional):
			'''    0 - axe 1
			'''    1 - axe 2
			'''    ...
			'''    N-1 axe N
			''' 
			'''    All axes are optional and should be between 0 and input->rankOf() - 1
			''' 
			''' output:
			'''    0 - NDArray with reduces shape accordingly to axes (the scalar in default case).
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_sum)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_sum extends DeclarableCustomOp
			public static class reduce_sum extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_sum(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_sum(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_sum position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_sum)
				End If
				public reduce_sum getPointer(Long i)
				If True Then
					Return (New reduce_sum(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_sum()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reduce_sum_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_sum_bp extends DeclarableCustomOp
			public static class reduce_sum_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_sum_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_sum_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_sum_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_sum_bp)
				End If
				public reduce_sum_bp getPointer(Long i)
				If True Then
					Return (New reduce_sum_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_sum_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' reduction_prod - tf.reduction_prod operation
			''' 
			''' input params:
			'''    0 - NDArray
			''' 
			''' T_ARG param (optional):
			''' 0 - keep_dims != 0.
			''' 
			''' int params (optional):
			'''    0 - axe 1
			'''    1 - axe 2
			'''    ...
			'''    N-1 axe N
			''' 
			'''    All axes are optional and should be between 0 and input->rankOf() - 1
			''' 
			''' output:
			'''    0 - NDArray with reduces shape accordingly to axes (the scalar in default case).
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_prod)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_prod extends DeclarableCustomOp
			public static class reduce_prod extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_prod(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_prod(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_prod position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_prod)
				End If
				public reduce_prod getPointer(Long i)
				If True Then
					Return (New reduce_prod(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_prod()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reduce_prod_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_prod_bp extends DeclarableCustomOp
			public static class reduce_prod_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_prod_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_prod_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_prod_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_prod_bp)
				End If
				public reduce_prod_bp getPointer(Long i)
				If True Then
					Return (New reduce_prod_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_prod_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates min of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate mins for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate min along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated mins
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_min)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_min extends DeclarableCustomOp
			public static class reduce_min extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_min(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_min(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_min position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_min)
				End If
				public reduce_min getPointer(Long i)
				If True Then
					Return (New reduce_min(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_min()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_min_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_min_bp extends DeclarableCustomOp
			public static class reduce_min_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_min_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_min_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_min_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_min_bp)
				End If
				public reduce_min_bp getPointer(Long i)
				If True Then
					Return (New reduce_min_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_min_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates max of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate maxes for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate max along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated maxes
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_max)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_max extends DeclarableCustomOp
			public static class reduce_max extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_max(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_max(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_max position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_max)
				End If
				public reduce_max getPointer(Long i)
				If True Then
					Return (New reduce_max(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_max()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_max_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_max_bp extends DeclarableCustomOp
			public static class reduce_max_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_max_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_max_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_max_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_max_bp)
				End If
				public reduce_max_bp getPointer(Long i)
				If True Then
					Return (New reduce_max_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_max_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates norm1 of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate norm1 for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate norm1 along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated norm1
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_norm1)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm1 extends DeclarableCustomOp
			public static class reduce_norm1 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm1(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm1(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm1 position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm1)
				End If
				public reduce_norm1 getPointer(Long i)
				If True Then
					Return (New reduce_norm1(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm1()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_norm1_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm1_bp extends DeclarableCustomOp
			public static class reduce_norm1_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm1_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm1_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm1_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm1_bp)
				End If
				public reduce_norm1_bp getPointer(Long i)
				If True Then
					Return (New reduce_norm1_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm1_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates norm2 of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate norm2 for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate norm2 along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated norm2
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_norm2)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm2 extends DeclarableCustomOp
			public static class reduce_norm2 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm2(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm2(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm2 position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm2)
				End If
				public reduce_norm2 getPointer(Long i)
				If True Then
					Return (New reduce_norm2(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm2()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_norm2_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm2_bp extends DeclarableCustomOp
			public static class reduce_norm2_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm2_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm2_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm2_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm2_bp)
				End If
				public reduce_norm2_bp getPointer(Long i)
				If True Then
					Return (New reduce_norm2_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm2_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		   ''' <summary>
		   ''' This op calculates squared norm of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate squared norm for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate squared norm along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated norm
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_sqnorm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_sqnorm extends DeclarableCustomOp
			public static class reduce_sqnorm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_sqnorm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_sqnorm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_sqnorm position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_sqnorm)
				End If
				public reduce_sqnorm getPointer(Long i)
				If True Then
					Return (New reduce_sqnorm(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_sqnorm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_sqnorm_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_sqnorm_bp extends DeclarableCustomOp
			public static class reduce_sqnorm_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_sqnorm_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_sqnorm_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_sqnorm_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_sqnorm_bp)
				End If
				public reduce_sqnorm_bp getPointer(Long i)
				If True Then
					Return (New reduce_sqnorm_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_sqnorm_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' This op calculates norm max of elements along given dimensions
		   ''' 
		   ''' input array:
		   '''    x: tensor to calculate norm max for
		   ''' 
		   ''' float arguments:
		   '''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
		   ''' 
		   ''' int arguments:
		   '''    list of integers - dimensions to calculate norm max along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
		   ''' 
		   ''' output array:
		   '''    reduced tensor with calculated norm
		   ''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_norm_max)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm_max extends DeclarableCustomOp
			public static class reduce_norm_max extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm_max(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm_max(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm_max position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm_max)
				End If
				public reduce_norm_max getPointer(Long i)
				If True Then
					Return (New reduce_norm_max(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm_max()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_reduce_norm_max_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_norm_max_bp extends DeclarableCustomOp
			public static class reduce_norm_max_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_norm_max_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_norm_max_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_norm_max_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_norm_max_bp)
				End If
				public reduce_norm_max_bp getPointer(Long i)
				If True Then
					Return (New reduce_norm_max_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_norm_max_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op calculates mean of elements along given dimensions
			''' 
			''' input array:
			'''    x: tensor to calculate mean for
			''' 
			''' float arguments:
			'''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
			''' 
			''' int arguments:
			'''    list of integers - dimensions to calculate mean along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
			''' 
			''' output array:
			'''    reduced tensor with calculated means
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_mean)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_mean extends DeclarableCustomOp
			public static class reduce_mean extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_mean(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_mean(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_mean position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_mean)
				End If
				public reduce_mean getPointer(Long i)
				If True Then
					Return (New reduce_mean(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_mean()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reduce_mean_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_mean_bp extends DeclarableCustomOp
			public static class reduce_mean_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_mean_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_mean_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_mean_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_mean_bp)
				End If
				public reduce_mean_bp getPointer(Long i)
				If True Then
					Return (New reduce_mean_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_mean_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
																					'         #endif
			''' <summary>
			''' This op calculates sample variance of elements along given dimensions
			''' 
			''' input array:
			'''    x: tensor to calculate mean for
			''' 
			''' float arguments:
			'''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
			'''   biasCorrected -  if non zero, then bias correction will be applied, default value is zero
			''' 
			''' int arguments:
			'''    list of integers - dimensions to calculate mean along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
			''' 
			''' output array:
			'''    reduced tensor with calculated means
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_variance extends DeclarableCustomOp
			public static class reduce_variance extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_variance(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_variance(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_variance position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_variance)
				End If
				public reduce_variance getPointer(Long i)
				If True Then
					Return (New reduce_variance(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_variance()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_variance_bp extends DeclarableCustomOp
			public static class reduce_variance_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_variance_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_variance_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_variance_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_variance_bp)
				End If
				public reduce_variance_bp getPointer(Long i)
				If True Then
					Return (New reduce_variance_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_variance_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
																					''' <summary>
																					''' This op calculates sample standard deviation of elements along given dimensions
																					''' 
																					''' input array:
																					'''    x: tensor to calculate mean for
																					''' 
																					''' float arguments:
																					'''   keepDims: if non zero, then keep reduced dimensions with length = 1, default value is zero
																					'''   biasCorrected - if non zero, then bias correction will be applied, default value is zero
																					''' 
																					''' int arguments:
																					'''    list of integers - dimensions to calculate mean along, default corresponds to empty list in which case calculation is performed for all dimensions and scalar is returned
																					''' 
																					''' output array:
																					'''    reduced tensor with calculated means
																					''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_stdev extends DeclarableCustomOp
			public static class reduce_stdev extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_stdev(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_stdev(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_stdev position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_stdev)
				End If
				public reduce_stdev getPointer(Long i)
				If True Then
					Return (New reduce_stdev(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_stdev()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_stdev_bp extends DeclarableCustomOp
			public static class reduce_stdev_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_stdev_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_stdev_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_stdev_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_stdev_bp)
				End If
				public reduce_stdev_bp getPointer(Long i)
				If True Then
					Return (New reduce_stdev_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_stdev_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
																					''' <summary>
																					''' This op calculates backprop dot for two tensors along given dimensions
																					''' 
																					''' input array:
																					'''    x: tensor to calculate dot for
																					'''    y: tensor to calculate dot for
																					'''    z: tensor with gradient output of the FF dot for x and y
																					''' 
																					''' int arguments:
																					'''   list of integers - dimensions to calculate dot along,
																					'''   default corresponds to empty list in which case calculation
																					'''   is performed for all dimensions and scalar is returned.
																					''' 
																					''' output array:
																					'''   the tensor with calculated backproped dots
																					''' 
																					''' </summary>

	'         #if NOT_EXCLUDED(OP_reduce_dot_bp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_dot_bp extends DeclarableCustomOp
			public static class reduce_dot_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_dot_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_dot_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_dot_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_dot_bp)
				End If
				public reduce_dot_bp getPointer(Long i)
				If True Then
					Return (New reduce_dot_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_dot_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
			''' <summary>
			''' reduce_logsumexp - tf.reduce_logsumexe operation
			''' 
			''' input params:
			'''    0 - NDArray (input)
			'''    1 - 1D NDArray (axis) (optional) - integer array
			''' 
			''' T_ARG param (optional):
			''' 0 - keep_dims != 0.
			''' 
			''' int params (optional):
			'''    0 - axe 1
			'''    1 - axe 2
			'''    ...
			'''    N-1 axe N
			''' 
			'''  CAUTION: All axes are optional and should be between 0 and input->rankOf() - 1
			'''  and put either with second param or as integers but not both
			''' 
			''' output:
			'''    0 - NDArray with reduces shape accordingly to axes (the scalar in default case).
			''' </summary>
	'         #if NOT_EXCLUDED(OP_reduce_logsumexp)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reduce_logsumexp extends DeclarableCustomOp
			public static class reduce_logsumexp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reduce_logsumexp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reduce_logsumexp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reduce_logsumexp position(Long position)
				If True Then
					Return CType(MyBase.position(position), reduce_logsumexp)
				End If
				public reduce_logsumexp getPointer(Long i)
				If True Then
					Return (New reduce_logsumexp(CType(Me, Pointer))).position(position + i)
				End If

																						public reduce_logsumexp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		   ''' <summary>
		   ''' Copy a tensor setting everything outside a central band in each innermost matrix
		   ''' 
		   ''' input array:
		   '''    x: given tensor with shape {..., M, N} - as vector (matrix) of matricies MxN
		   ''' 
		   ''' int arguments:
		   '''   lower band
		   '''   upper band
		   ''' 
		   ''' output array:
		   '''   matrix with given bands between lower and upper diagonals
		   ''' 
		   ''' </summary>

	'         #if NOT_EXCLUDED(OP_matrix_band_part)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matrix_band_part extends DeclarableOp
			public static class matrix_band_part extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matrix_band_part(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matrix_band_part(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matrix_band_part position(Long position)
				If True Then
					Return CType(MyBase.position(position), matrix_band_part)
				End If
				public matrix_band_part getPointer(Long i)
				If True Then
					Return (New matrix_band_part(CType(Me, Pointer))).position(position + i)
				End If

																						public matrix_band_part()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


	'         #if NOT_EXCLUDED(OP_Assert)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class Assert extends DeclarableOp
			public static class Assert extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public Assert(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public Assert(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public Assert position(Long position)
				If True Then
					Return CType(MyBase.position(position), Assert)
				End If
				public Assert getPointer(Long i)
				If True Then
					Return (New Assert(CType(Me, Pointer))).position(position + i)
				End If

														public Assert()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' image.non_max_suppression ops.
			''' input:
			'''     0 - boxes - 2D-tensor with shape (num_boxes, 4) by float type
			'''     1 - scales - 1D-tensor with shape (num_boxes) by float type
			'''     2 - output_size - 0D-tensor by int type (optional)
			''' float args:
			'''     0 - overlap_threshold - threshold value for overlap checks (optional, by default 0.5)
			'''     1 - score_threshold - the threshold for deciding when to remove boxes based on score (optional, by default -inf)
			''' int args:
			'''     0 - output_size - as arg 2 used for same target. Eigher this or arg 2 should be provided.
			''' 
			''' output:
			'''     - vector with size M, where M <= output_size by int type
			''' 
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_image_non_max_suppression)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class non_max_suppression extends DeclarableCustomOp
			public static class non_max_suppression extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public non_max_suppression(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public non_max_suppression(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public non_max_suppression position(Long position)
				If True Then
					Return CType(MyBase.position(position), non_max_suppression)
				End If
				public non_max_suppression getPointer(Long i)
				If True Then
					Return (New non_max_suppression(CType(Me, Pointer))).position(position + i)
				End If

																						public non_max_suppression()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'         #if NOT_EXCLUDED(OP_image_non_max_suppression_v3)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class non_max_suppression_v3 extends DeclarableCustomOp
					public static class non_max_suppression_v3 extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public non_max_suppression_v3(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public non_max_suppression_v3(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public non_max_suppression_v3 position(Long position)
						If True Then
							Return CType(MyBase.position(position), non_max_suppression_v3)
						End If
						public non_max_suppression_v3 getPointer(Long i)
						If True Then
							Return (New non_max_suppression_v3(CType(Me, Pointer))).position(position + i)
						End If

																						public non_max_suppression_v3()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

	'        
	'         * image.non_max_suppression_overlaps op.
	'         * input:
	'         *     0 - boxes - 2D-tensor with shape (num_boxes, 4) by float type
	'         *     1 - scales - 1D-tensor with shape (num_boxes) by float type
	'         *     2 - output_size - 0D-tensor by int type (optional)
	'         * float args:
	'         *     0 - overlap_threshold - threshold value for overlap checks (optional, by default 0.5)
	'         *     1 - score_threshold - the threshold for deciding when to remove boxes based on score (optional, by default -inf)
	'         * int args:
	'         *     0 - output_size - as arg 2 used for same target. Eigher this or arg 2 should be provided.
	'         *
	'         * output:
	'         *     0 - 1D integer tensor with shape [M], epresenting the selected indices from the overlaps tensor, where M <= max_output_size
	'         * 
	'         #if NOT_EXCLUDED(OP_image_non_max_suppression_overlaps)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class non_max_suppression_overlaps extends DeclarableCustomOp
			public static class non_max_suppression_overlaps extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public non_max_suppression_overlaps(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public non_max_suppression_overlaps(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public non_max_suppression_overlaps position(Long position)
				If True Then
					Return CType(MyBase.position(position), non_max_suppression_overlaps)
				End If
				public non_max_suppression_overlaps getPointer(Long i)
				If True Then
					Return (New non_max_suppression_overlaps(CType(Me, Pointer))).position(position + i)
				End If

																						public non_max_suppression_overlaps()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'        
	'         * cholesky op - decomposite positive square symetric matrix (or matricies when rank > 2).
	'         * input:
	'         *     0 - matricies - tensor with shape (..., N, N) by float type
	'         *
	'         * output - lower triangular matrix (matricies when rank > 2) with the same shape as input.
	'         * 
	'         #if NOT_EXCLUDED(OP_cholesky)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cholesky extends DeclarableOp
			public static class cholesky extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cholesky(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cholesky(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cholesky position(Long position)
				If True Then
					Return CType(MyBase.position(position), cholesky)
				End If
				public cholesky getPointer(Long i)
				If True Then
					Return (New cholesky(CType(Me, Pointer))).position(position + i)
				End If

														public cholesky()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'        
	'         * nth_element - apply nth_element for last dimension of input tensor
	'         * input array:
	'         *     0 - input array
	'         *     1 - scalar tensor with n for operation. n should be less than last dimension
	'         *
	'         * output:
	'         *    0 - NDArray with the same shape as input
	'         
	'         #if NOT_EXCLUDED(OP_nth_element)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class nth_element extends DeclarableCustomOp
			public static class nth_element extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public nth_element(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public nth_element(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public nth_element position(Long position)
				If True Then
					Return CType(MyBase.position(position), nth_element)
				End If
				public nth_element getPointer(Long i)
				If True Then
					Return (New nth_element(CType(Me, Pointer))).position(position + i)
				End If

																						public nth_element()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op checks for Inf/NaN values within input array, and throws exception if there's at least one
			''' </summary>
	'         #if NOT_EXCLUDED(OP_check_numerics)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class check_numerics extends DeclarableCustomOp
			public static class check_numerics extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public check_numerics(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public check_numerics(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public check_numerics position(Long position)
				If True Then
					Return CType(MyBase.position(position), check_numerics)
				End If
				public check_numerics getPointer(Long i)
				If True Then
					Return (New check_numerics(CType(Me, Pointer))).position(position + i)
				End If

																						public check_numerics()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	''' <summary>
	''' fake_quant_with_min_max_vals - tf.quantization.fake_quant_with_min_max_vars
	'''         
	''' input params:
	'''    0 - NDArray (input)
	'''    1 - 0D Tensor - min value
	'''    2 - 0D Tensor - max value
	'''         
	''' int params (optional):
	'''    0 - num_bits (allowed interval [2, 16], default 8)
	'''    1 - narrow_range (default False)
	'''         
	''' output:
	'''    0 - NDArray with the same shape as input
	''' </summary>
	'         #if NOT_EXCLUDED(OP_fake_quant_with_min_max_vars)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class fake_quant_with_min_max_vars extends DeclarableOp
			public static class fake_quant_with_min_max_vars extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public fake_quant_with_min_max_vars(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public fake_quant_with_min_max_vars(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public fake_quant_with_min_max_vars position(Long position)
				If True Then
					Return CType(MyBase.position(position), fake_quant_with_min_max_vars)
				End If
				public fake_quant_with_min_max_vars getPointer(Long i)
				If True Then
					Return (New fake_quant_with_min_max_vars(CType(Me, Pointer))).position(position + i)
				End If

																						public fake_quant_with_min_max_vars()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	''' <summary>
	''' fake_quant_with_min_max_vals_per_channel - tf.quantization.fake_quant_with_min_max_vars_per_channel
	'''         
	''' input params:
	'''    0 - NDArray (input) - at least 2D.
	'''    1 - 1D Tensor - min values (min length equals to last dim of input)
	'''    2 - 1D Tensor - max value (length equals to min)
	'''         
	''' int params (optional):
	'''    0 - num_bits (allowed interval [2, 16], default 8)
	'''    1 - narrow_range (default False)
	'''         
	''' output:
	'''    0 - NDArray with the same shape as input
	''' </summary>
	'         #if NOT_EXCLUDED(OP_fake_quant_with_min_max_vars_per_channel)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class fake_quant_with_min_max_vars_per_channel extends DeclarableOp
					public static class fake_quant_with_min_max_vars_per_channel extends DeclarableOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public fake_quant_with_min_max_vars_per_channel(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public fake_quant_with_min_max_vars_per_channel(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public fake_quant_with_min_max_vars_per_channel position(Long position)
						If True Then
							Return CType(MyBase.position(position), fake_quant_with_min_max_vars_per_channel)
						End If
						public fake_quant_with_min_max_vars_per_channel getPointer(Long i)
						If True Then
							Return (New fake_quant_with_min_max_vars_per_channel(CType(Me, Pointer))).position(position + i)
						End If

																						public fake_quant_with_min_max_vars_per_channel()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

			''' <summary>
			''' compare_and_bitpack - Compare values of input to threshold and pack resulting bits into a uint8
			''' 
			''' input params:
			'''    0 - NDArray (input). Note: last dimension should be divisibly by 8
			'''    1 - 0D Tensor - threshold to compare against. Note: when input is bool type, the threshold is ignored
			''' 
			''' 
			''' output:
			'''    0 - NDArray with the shape as {input.dim0,...input.dimLast/8} and type uint8
			''' </summary>
	'         #if NOT_EXCLUDED(OP_compare_and_bitpack)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class compare_and_bitpack extends DeclarableCustomOp
			public static class compare_and_bitpack extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public compare_and_bitpack(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public compare_and_bitpack(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public compare_and_bitpack position(Long position)
				If True Then
					Return CType(MyBase.position(position), compare_and_bitpack)
				End If
				public compare_and_bitpack getPointer(Long i)
				If True Then
					Return (New compare_and_bitpack(CType(Me, Pointer))).position(position + i)
				End If

																						public compare_and_bitpack()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' eig - Compute the eigenvalues and eigenvectors of a square matrix
			''' 
			''' input params:
			'''    0 - NDArray (input). input should be a square matrix 
			''' 
			''' 
			''' output:
			'''    0 - NDArray for eigenvalues with the shape as {input.dim0, 2} , type: the same as input
			'''    1 - NDArray for eigenvectors with the shape as {input.dim0, input.dim0, 2} , type: the same as input
			''' </summary>
	'         #if NOT_EXCLUDED(OP_eig)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class eig extends DeclarableCustomOp
			public static class eig extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public eig(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public eig(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public eig position(Long position)
				If True Then
					Return CType(MyBase.position(position), eig)
				End If
				public eig getPointer(Long i)
				If True Then
					Return (New eig(CType(Me, Pointer))).position(position + i)
				End If

																						public eig()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif




	' #endif


	' Parsed from ops/declarable/headers/shape.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_SHAPE_H
	' #define LIBND4J_HEADERS_SHAPE_H

	' #include <ops/declarable/headers/common.h>
	'         #if NOT_EXCLUDED(OP_permute)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class permute extends DeclarableCustomOp
			public static class permute extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public permute(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public permute(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public permute position(Long position)
				If True Then
					Return CType(MyBase.position(position), permute)
				End If
				public permute getPointer(Long i)
				If True Then
					Return (New permute(CType(Me, Pointer))).position(position + i)
				End If

																						public permute()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reshapeas)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reshapeas extends DeclarableCustomOp
			public static class reshapeas extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reshapeas(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reshapeas(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reshapeas position(Long position)
				If True Then
					Return CType(MyBase.position(position), reshapeas)
				End If
				public reshapeas getPointer(Long i)
				If True Then
					Return (New reshapeas(CType(Me, Pointer))).position(position + i)
				End If

																						public reshapeas()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_transpose)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class transpose extends DeclarableCustomOp
			public static class transpose extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public transpose(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public transpose(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public transpose position(Long position)
				If True Then
					Return CType(MyBase.position(position), transpose)
				End If
				public transpose getPointer(Long i)
				If True Then
					Return (New transpose(CType(Me, Pointer))).position(position + i)
				End If

																						public transpose()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_shape_of)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class shape_of extends DeclarableCustomOp
			public static class shape_of extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public shape_of(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public shape_of(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public shape_of position(Long position)
				If True Then
					Return CType(MyBase.position(position), shape_of)
				End If
				public shape_of getPointer(Long i)
				If True Then
					Return (New shape_of(CType(Me, Pointer))).position(position + i)
				End If

																						public shape_of()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_shapes_of)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class shapes_of extends DeclarableCustomOp
			public static class shapes_of extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public shapes_of(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public shapes_of(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public shapes_of position(Long position)
				If True Then
					Return CType(MyBase.position(position), shapes_of)
				End If
				public shapes_of getPointer(Long i)
				If True Then
					Return (New shapes_of(CType(Me, Pointer))).position(position + i)
				End If

																						public shapes_of()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_squeeze)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class squeeze extends DeclarableCustomOp
			public static class squeeze extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public squeeze(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public squeeze(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public squeeze position(Long position)
				If True Then
					Return CType(MyBase.position(position), squeeze)
				End If
				public squeeze getPointer(Long i)
				If True Then
					Return (New squeeze(CType(Me, Pointer))).position(position + i)
				End If

																						public squeeze()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_expand_dims)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class expand_dims extends DeclarableCustomOp
			public static class expand_dims extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public expand_dims(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public expand_dims(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public expand_dims position(Long position)
				If True Then
					Return CType(MyBase.position(position), expand_dims)
				End If
				public expand_dims getPointer(Long i)
				If True Then
					Return (New expand_dims(CType(Me, Pointer))).position(position + i)
				End If

																						public expand_dims()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_flatten_2d)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class flatten_2d extends DeclarableCustomOp
				public static class flatten_2d extends DeclarableCustomOp
				If True Then
					''' <summary>
					''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
					public flatten_2d(Pointer p)
					If True Then
						MyBase(p)
					End If
					''' <summary>
					''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
					public flatten_2d(Long size)
					If True Then
						MyBase(DirectCast(Nothing, Pointer))
						allocateArray(size)
					End If
					private native void allocateArray(Long size)
					public flatten_2d position(Long position)
					If True Then
						Return CType(MyBase.position(position), flatten_2d)
					End If
					public flatten_2d getPointer(Long i)
					If True Then
						Return (New flatten_2d(CType(Me, Pointer))).position(position + i)
					End If

																						public flatten_2d()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
				End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_reshape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class reshape extends DeclarableCustomOp
			public static class reshape extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public reshape(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public reshape(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public reshape position(Long position)
				If True Then
					Return CType(MyBase.position(position), reshape)
				End If
				public reshape getPointer(Long i)
				If True Then
					Return (New reshape(CType(Me, Pointer))).position(position + i)
				End If

																						public reshape()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_size_at)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class size_at extends DeclarableCustomOp
			public static class size_at extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public size_at(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public size_at(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public size_at position(Long position)
				If True Then
					Return CType(MyBase.position(position), size_at)
				End If
				public size_at getPointer(Long i)
				If True Then
					Return (New size_at(CType(Me, Pointer))).position(position + i)
				End If

																						public size_at()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op changes order of given array to specified order.
			''' In other words: C/F order switch
			''' 
			''' Int args:
			''' 0 - isForder. set to 1 for F order output, or 0 for C order output
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_order)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class order extends DeclarableCustomOp
			public static class order extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public order(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public order(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public order position(Long position)
				If True Then
					Return CType(MyBase.position(position), order)
				End If
				public order getPointer(Long i)
				If True Then
					Return (New order(CType(Me, Pointer))).position(position + i)
				End If

																						public order()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op boosts specified input up to specified shape
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_tile_to_shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tile_to_shape extends DeclarableCustomOp
			public static class tile_to_shape extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tile_to_shape(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tile_to_shape(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tile_to_shape position(Long position)
				If True Then
					Return CType(MyBase.position(position), tile_to_shape)
				End If
				public tile_to_shape getPointer(Long i)
				If True Then
					Return (New tile_to_shape(CType(Me, Pointer))).position(position + i)
				End If

																						public tile_to_shape()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tile_to_shape_bp extends DeclarableCustomOp
			public static class tile_to_shape_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tile_to_shape_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tile_to_shape_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tile_to_shape_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), tile_to_shape_bp)
				End If
				public tile_to_shape_bp getPointer(Long i)
				If True Then
					Return (New tile_to_shape_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public tile_to_shape_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op broadcast given input up to given shape
			''' 
			''' inputs:
			'''  input array - array to be broadcasted to given shape
			'''  shape array - array containing shape be broadcasted to
			''' </summary>
	'         #if NOT_EXCLUDED(OP_broadcast_to)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class broadcast_to extends DeclarableCustomOp
			public static class broadcast_to extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public broadcast_to(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public broadcast_to(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public broadcast_to position(Long position)
				If True Then
					Return CType(MyBase.position(position), broadcast_to)
				End If
				public broadcast_to getPointer(Long i)
				If True Then
					Return (New broadcast_to(CType(Me, Pointer))).position(position + i)
				End If

																						public broadcast_to()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


	'         #if NOT_EXCLUDED(OP_evaluate_reduction_shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class evaluate_reduction_shape extends DeclarableCustomOp
			public static class evaluate_reduction_shape extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public evaluate_reduction_shape(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public evaluate_reduction_shape(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public evaluate_reduction_shape position(Long position)
				If True Then
					Return CType(MyBase.position(position), evaluate_reduction_shape)
				End If
				public evaluate_reduction_shape getPointer(Long i)
				If True Then
					Return (New evaluate_reduction_shape(CType(Me, Pointer))).position(position + i)
				End If

																						public evaluate_reduction_shape()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation creates new array
			''' Input:
			'''    array with shape values
			''' 
			''' IArgs:
			'''    order value
			'''    data type value
			''' 
			''' BArgs:
			'''    initialization option
			''' </summary>
	'         #if NOT_EXCLUDED(OP_create)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class create extends DeclarableCustomOp
			public static class create extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public create(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public create(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public create position(Long position)
				If True Then
					Return CType(MyBase.position(position), create)
				End If
				public create getPointer(Long i)
				If True Then
					Return (New create(CType(Me, Pointer))).position(position + i)
				End If

																						public create()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/random.h

	'
	' *  ******************************************************************************
	' *  *
	' *  *
	' *  * This program and the accompanying materials are made available under the
	' *  * terms of the Apache License, Version 2.0 which is available at
	' *  * https://www.apache.org/licenses/LICENSE-2.0.
	' *  *
	' *  * See the NOTICE file distributed with this work for additional
	' *  * information regarding copyright ownership.
	' *  * Unless required by applicable law or agreed to in writing, software
	' *  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' *  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' *  * License for the specific language governing permissions and limitations
	' *  * under the License.
	' *  *
	' *  * SPDX-License-Identifier: Apache-2.0
	' *  *****************************************************************************
	' 

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_RANDOM_H
	' #define LIBND4J_HEADERS_RANDOM_H

	' #include <ops/declarable/headers/common.h>
	'         #if NOT_EXCLUDED(OP_set_seed)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class set_seed extends DeclarableCustomOp
			public static class set_seed extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public set_seed(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public set_seed(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public set_seed position(Long position)
				If True Then
					Return CType(MyBase.position(position), set_seed)
				End If
				public set_seed getPointer(Long i)
				If True Then
					Return (New set_seed(CType(Me, Pointer))).position(position + i)
				End If

																						public set_seed()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_get_seed)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class get_seed extends DeclarableCustomOp
			public static class get_seed extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public get_seed(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public get_seed(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public get_seed position(Long position)
				If True Then
					Return CType(MyBase.position(position), get_seed)
				End If
				public get_seed getPointer(Long i)
				If True Then
					Return (New get_seed(CType(Me, Pointer))).position(position + i)
				End If

																						public get_seed()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'        
	'         * random_uniform distribution for types int32,int64, float16, float and double
	'         * by default dtype is float32
	'         *
	'         * input:
	'         *    0 - shape of output (1D int tensor)
	'         *    1 - min val (0D of output type) - optional (0 as default)
	'         *    2 - max val (0D of output type) - optional (inf as default)
	'         *
	'         * output:
	'         *    0 - uniformly distributed values of given type (between min and max)
	'         
	'         #if NOT_EXCLUDED(OP_randomuniform)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class randomuniform extends DeclarableCustomOp
			public static class randomuniform extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public randomuniform(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public randomuniform(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public randomuniform position(Long position)
				If True Then
					Return CType(MyBase.position(position), randomuniform)
				End If
				public randomuniform getPointer(Long i)
				If True Then
					Return (New randomuniform(CType(Me, Pointer))).position(position + i)
				End If

																						public randomuniform()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
	'        
	'         * multinomial (categorical) random generator draws samples from a multinomial distribution
	'         *
	'         * Input array:
	'         *    0 - 2D ndarray with unnormalized log-probabilities with shape [batch_size (N), num_classes (K)]
	'         *    1 - array with one int value of samples number, number of independent samples to draw for each experiment 1,N.
	'         * Int arguments:
	'         *    0 - optional argument, corresponds to dimension with batch_size
	'         *    1 - optional argument, integer type to use for the output. Default int64.
	'         *
	'         * Output array:
	'         *    0 - 2D ndarray with the drawn samples of shape [batch_size, num_samples]
	'         
	'         #if NOT_EXCLUDED(OP_random_multinomial)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_multinomial extends DeclarableCustomOp
			public static class random_multinomial extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_multinomial(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_multinomial(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_multinomial position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_multinomial)
				End If
				public random_multinomial getPointer(Long i)
				If True Then
					Return (New random_multinomial(CType(Me, Pointer))).position(position + i)
				End If

																						public random_multinomial()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_random_normal)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_normal extends DeclarableCustomOp
			public static class random_normal extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_normal(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_normal(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_normal position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_normal)
				End If
				public random_normal getPointer(Long i)
				If True Then
					Return (New random_normal(CType(Me, Pointer))).position(position + i)
				End If

																						public random_normal()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_random_bernoulli)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_bernoulli extends DeclarableCustomOp
			public static class random_bernoulli extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_bernoulli(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_bernoulli(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_bernoulli position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_bernoulli)
				End If
				public random_bernoulli getPointer(Long i)
				If True Then
					Return (New random_bernoulli(CType(Me, Pointer))).position(position + i)
				End If

																						public random_bernoulli()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_random_exponential)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_exponential extends DeclarableCustomOp
			public static class random_exponential extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_exponential(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_exponential(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_exponential position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_exponential)
				End If
				public random_exponential getPointer(Long i)
				If True Then
					Return (New random_exponential(CType(Me, Pointer))).position(position + i)
				End If

																						public random_exponential()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_random_crop)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_crop extends DeclarableCustomOp
			public static class random_crop extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_crop(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_crop(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_crop position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_crop)
				End If
				public random_crop getPointer(Long i)
				If True Then
					Return (New random_crop(CType(Me, Pointer))).position(position + i)
				End If

																						public random_crop()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' random_gamma op.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_random_gamma)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_gamma extends DeclarableCustomOp
			public static class random_gamma extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_gamma(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_gamma(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_gamma position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_gamma)
				End If
				public random_gamma getPointer(Long i)
				If True Then
					Return (New random_gamma(CType(Me, Pointer))).position(position + i)
				End If

																						public random_gamma()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' random_poisson op.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_random_poisson)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class random_poisson extends DeclarableCustomOp
			public static class random_poisson extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public random_poisson(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public random_poisson(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public random_poisson position(Long position)
				If True Then
					Return CType(MyBase.position(position), random_poisson)
				End If
				public random_poisson getPointer(Long i)
				If True Then
					Return (New random_poisson(CType(Me, Pointer))).position(position + i)
				End If

																						public random_poisson()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif




	' #endif

	' Parsed from ops/declarable/headers/nn.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_NN_H
	' #define LIBND4J_HEADERS_NN_H

	' #include <ops/declarable/headers/common.h>

	'         #if NOT_EXCLUDED(OP_softmax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax extends DeclarableOp
			public static class softmax extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax)
				End If
				public softmax getPointer(Long i)
				If True Then
					Return (New softmax(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax_bp extends DeclarableOp
			public static class softmax_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax_bp)
				End If
				public softmax_bp getPointer(Long i)
				If True Then
					Return (New softmax_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Local response normalization implementation as TF.
			''' input: 4D array
			''' 
			''' T args:
			''' 
			''' 0: bias
			''' 1: alpha
			''' 2: beta
			''' 
			''' Int arg: depth - optional local radius
			''' 
			''' output - 4D array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lrn)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lrn extends DeclarableOp
			public static class lrn extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lrn(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lrn(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lrn position(Long position)
				If True Then
					Return CType(MyBase.position(position), lrn)
				End If
				public lrn getPointer(Long i)
				If True Then
					Return (New lrn(CType(Me, Pointer))).position(position + i)
				End If

																						public lrn()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Local response normalization - backprop variant.
			''' input:
			'''  0 - 4D array of data
			'''  1 - epsilon - 4D array of approximation
			''' 
			''' T args:
			''' 
			''' 0: bias
			''' 1: alpha
			''' 2: beta
			''' 
			''' Int arg: depth - optional local radius
			''' 
			''' output - next approximation as 4D array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_lrn)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class lrn_bp extends DeclarableOp
			public static class lrn_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public lrn_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public lrn_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public lrn_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), lrn_bp)
				End If
				public lrn_bp getPointer(Long i)
				If True Then
					Return (New lrn_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public lrn_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' Batch normalization implementation.
			''' Reference: https://arxiv.org/abs/1502.03167v3
			''' 
			''' Expected arguments:
			''' input: input array (any number of dimensions)
			''' mean:
			''' variance:
			''' gamma:
			''' beta:
			''' 
			''' Int args:
			''' 0: apply scale
			''' 1: apply offset
			''' 
			''' 
			''' T args:
			''' 0: epsilon
			''' </summary>
	'         #if NOT_EXCLUDED(OP_batchnorm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class batchnorm extends DeclarableCustomOp
			public static class batchnorm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public batchnorm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public batchnorm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public batchnorm position(Long position)
				If True Then
					Return CType(MyBase.position(position), batchnorm)
				End If
				public batchnorm getPointer(Long i)
				If True Then
					Return (New batchnorm(CType(Me, Pointer))).position(position + i)
				End If

																						public batchnorm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' back prop in batch normalization
			''' 
			''' Expected arguments:
			''' input: input array (any number of dimensions)
			''' mean:
			''' variance:
			''' gamma: optional
			''' beta: optional
			''' dLdOut: next epsilon
			''' 
			''' Int args:
			''' 0: apply scale
			''' 1: apply offset
			''' 
			''' T args:
			''' 0: epsilon
			''' 
			''' output arrays:
			''' dL/dInput
			''' dL/dMean
			''' dL/dVariance
			''' dL/dGamma, optional
			''' dL/dBeta, optional
			''' </summary>
	'         #if NOT_EXCLUDED(OP_batchnorm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class batchnorm_bp extends DeclarableCustomOp
			public static class batchnorm_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public batchnorm_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public batchnorm_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public batchnorm_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), batchnorm_bp)
				End If
				public batchnorm_bp getPointer(Long i)
				If True Then
					Return (New batchnorm_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public batchnorm_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This operation updates parameters with provided gradients, wrt learning rate
			''' Expected arguments:
			''' x: parameters, any shape
			''' y: gradients. same shape as x
			''' lr: optional, learning rate
			''' 
			''' T args:
			''' 0: optional, learning rate
			''' </summary>
	'         #if NOT_EXCLUDED(OP_apply_sgd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class apply_sgd extends DeclarableOp
			public static class apply_sgd extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public apply_sgd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public apply_sgd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public apply_sgd position(Long position)
				If True Then
					Return CType(MyBase.position(position), apply_sgd)
				End If
				public apply_sgd getPointer(Long i)
				If True Then
					Return (New apply_sgd(CType(Me, Pointer))).position(position + i)
				End If

																						public apply_sgd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation performs batch normalization of layer, it is based on following article https://arxiv.org/abs/1502.03167.
			''' Expected arguments:
			''' x: input 4D array of shape [bS,iH,iW,iD] (data format = NHWC) or [bS,iD,iH,iW] (data format = NCHW), where
			'''    bS - batch size
			'''    iH - input height
			'''    iW - input width
			'''    iD - input depth (or number of channels)
			''' scale:  1D input array of scale factors, shape [iD]
			''' offset: 1D input array of offsets (shifts), shape [iD]
			''' mean: 1D input array of population mean used for inference, shape [iD], this array is required only if isTraining = false
			''' variance: 1D input array of population mean used for inference, shape [iD], this array is required only if isTraining = false
			''' 
			''' T input arguments:
			''' 0: epsilon, it is optional argument, default value is 0.001, this is small number to be added to the variance of x
			''' 
			''' integer input arguments:
			''' 0: dataFormat, may have two values: zero -> NHWC, unity -> NCHW
			''' 1: isTraining, may have two values: zero -> inference, unity -> training
			''' </summary>
	'         #if NOT_EXCLUDED(OP_fused_batch_norm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class fused_batch_norm extends DeclarableCustomOp
			public static class fused_batch_norm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public fused_batch_norm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public fused_batch_norm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public fused_batch_norm position(Long position)
				If True Then
					Return CType(MyBase.position(position), fused_batch_norm)
				End If
				public fused_batch_norm getPointer(Long i)
				If True Then
					Return (New fused_batch_norm(CType(Me, Pointer))).position(position + i)
				End If

																						public fused_batch_norm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_log_softmax)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_softmax extends DeclarableOp
			public static class log_softmax extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_softmax(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_softmax(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_softmax position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_softmax)
				End If
				public log_softmax getPointer(Long i)
				If True Then
					Return (New log_softmax(CType(Me, Pointer))).position(position + i)
				End If

																						public log_softmax()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_softmax_bp extends DeclarableOp
			public static class log_softmax_bp extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_softmax_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_softmax_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_softmax_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_softmax_bp)
				End If
				public log_softmax_bp getPointer(Long i)
				If True Then
					Return (New log_softmax_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public log_softmax_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' relu_layer = relu(x*w + b)
			''' </summary>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class relu_layer extends DeclarableCustomOp
			public static class relu_layer extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public relu_layer(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public relu_layer(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public relu_layer position(Long position)
				If True Then
					Return CType(MyBase.position(position), relu_layer)
				End If
				public relu_layer getPointer(Long i)
				If True Then
					Return (New relu_layer(CType(Me, Pointer))).position(position + i)
				End If

																						public relu_layer()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If

			''' <summary>
			''' applies layer normalization to input
			''' y = g * standardize(x) + b
			''' 
			''' see sd::ops::standardize
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_layer_norm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class layer_norm extends DeclarableOp
					public static class layer_norm extends DeclarableOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public layer_norm(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public layer_norm(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public layer_norm position(Long position)
						If True Then
							Return CType(MyBase.position(position), layer_norm)
						End If
						public layer_norm getPointer(Long i)
						If True Then
							Return (New layer_norm(CType(Me, Pointer))).position(position + i)
						End If

																						public layer_norm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class layer_norm_bp extends DeclarableCustomOp
					public static class layer_norm_bp extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public layer_norm_bp(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public layer_norm_bp(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public layer_norm_bp position(Long position)
						If True Then
							Return CType(MyBase.position(position), layer_norm_bp)
						End If
						public layer_norm_bp getPointer(Long i)
						If True Then
							Return (New layer_norm_bp(CType(Me, Pointer))).position(position + i)
						End If

																						public layer_norm_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif

			''' <summary>
			''' This operation performs dot product attention on the given timeseries input with the given queries
			''' out = sum(similarity(k_i, q) * v_i)
			''' 
			''' similarity(k, q) = softmax(k * q) where x * q is the dot product of x and q
			''' 
			''' Optionally with normalization step:
			''' similarity(k, q) = softmax(k * q / sqrt(size(q))
			''' 
			''' See also "Attention is all you need" (https://arxiv.org/abs/1706.03762, p. 4, eq. 1)
			''' 
			''' Note: This supports multiple queries at once, if only one query is available the queries vector still has to
			''' be 3D but can have queryCount = 1
			''' 
			''' Note: keys and values usually is the same array. If you want to use it as the same array, simply pass it for
			''' both.
			''' 
			''' Expected arguments:
			''' q: input 3D array "queries" of shape [batchSize, featureKeys, queryCount] or 4D array of shape [batchSize, numHeads, featureKeys, queryCount]
			''' k: input 3D array "keys" of shape [batchSize, featureKeys, timesteps] or 4D array of shape [batchSize, numHeads, featureKeys, timesteps]
			''' v: input 3D array "values" of shape [batchSize, featureValues, timesteps] or 4D array of shape [batchSize, numHeads, featureValues, timesteps]
			''' mask: OPTIONAL; array that defines which values should be skipped of shape [batchSize, timesteps]
			''' 
			''' integer input arguments:
			''' 0: normalization, may have two values: zero -> do not apply normalization, one -> apply normalization
			''' 1: withWeights, may have two values: zero -> do not return weights, one -> return weights
			''' 
			''' Output Arrays:
			''' 0: Attention result arrays of shape [batchSize, featureValues, queryCount] or [batchSize, numHeads, featureValues, queryCount]
			''' 1: OPTIONAL; Attention weights of shape [batchSize, timesteps, queryCount] or [batchSize, numHeads, timesteps, queryCount]
			''' </summary>
	'         #if NOT_EXCLUDED(OP_dot_product_attention)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dot_product_attention extends DeclarableCustomOp
					public static class dot_product_attention extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public dot_product_attention(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public dot_product_attention(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public dot_product_attention position(Long position)
						If True Then
							Return CType(MyBase.position(position), dot_product_attention)
						End If
						public dot_product_attention getPointer(Long i)
						If True Then
							Return (New dot_product_attention(CType(Me, Pointer))).position(position + i)
						End If

																						public dot_product_attention()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class dot_product_attention_bp extends DeclarableCustomOp
					public static class dot_product_attention_bp extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public dot_product_attention_bp(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public dot_product_attention_bp(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public dot_product_attention_bp position(Long position)
						If True Then
							Return CType(MyBase.position(position), dot_product_attention_bp)
						End If
						public dot_product_attention_bp getPointer(Long i)
						If True Then
							Return (New dot_product_attention_bp(CType(Me, Pointer))).position(position + i)
						End If

																						public dot_product_attention_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif


			''' <summary>
			''' This performs multi-headed dot product attention on the given timeseries input
			''' out = concat(head_1, head_2, ..., head_n) * Wo
			''' head_i = dot_product_attention(Wq_i*q, Wk_i*k, Wv_i*v)
			''' 
			''' Optionally with normalization when calculating the attention for each head.
			''' 
			''' See also "Attention is all you need" (https://arxiv.org/abs/1706.03762, pp. 4,5, "3.2.2 Multi-Head Attention")
			''' 
			''' This makes use of dot_product_attention OP support for rank 4 inputs.
			''' 
			''' Expected arguments:
			''' q: input 3D array "queries" of shape [batchSize, featureKeys, queryCount]
			''' k: input 3D array "keys" of shape [batchSize, featureKeys, timesteps]
			''' v: input 3D array "values" of shape [batchSize, featureValues, timesteps]
			''' Wq: input query projection weights of shape [numHeads, projectedKeys, featureKeys]
			''' Wk: input key projection weights of shape [numHeads, projectedKeys, featureKeys]
			''' Wv: input value projection weights of shape [numHeads, projectedValues, featureValues]
			''' Wo: output projection weights of shape [numHeads * projectedValues, outSize]
			''' mask: OPTIONAL; array that defines which values should be skipped of shape [batchSize, timesteps]
			''' 
			''' integer input arguments:
			''' 0: normalization, may have two values: zero -> do not apply normalization, one -> apply normalization
			''' 1: withWeights, may have two values: zero -> do not return weights, one -> return weights
			''' 
			''' Output Arrays:
			''' 0: Attention result arrays of shape [batchSize, outSize, queryCount]
			''' 1: OPTIONAL; Attention weights of shape [batchSize, numHeads, timesteps, queryCount]
			''' </summary>
	'         #if NOT_EXCLUDED(OP_multi_head_dot_product_attention)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class multi_head_dot_product_attention extends DeclarableCustomOp
					public static class multi_head_dot_product_attention extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public multi_head_dot_product_attention(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public multi_head_dot_product_attention(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public multi_head_dot_product_attention position(Long position)
						If True Then
							Return CType(MyBase.position(position), multi_head_dot_product_attention)
						End If
						public multi_head_dot_product_attention getPointer(Long i)
						If True Then
							Return (New multi_head_dot_product_attention(CType(Me, Pointer))).position(position + i)
						End If

																						public multi_head_dot_product_attention()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class multi_head_dot_product_attention_bp extends DeclarableCustomOp
					public static class multi_head_dot_product_attention_bp extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public multi_head_dot_product_attention_bp(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public multi_head_dot_product_attention_bp(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public multi_head_dot_product_attention_bp position(Long position)
						If True Then
							Return CType(MyBase.position(position), multi_head_dot_product_attention_bp)
						End If
						public multi_head_dot_product_attention_bp getPointer(Long i)
						If True Then
							Return (New multi_head_dot_product_attention_bp(CType(Me, Pointer))).position(position + i)
						End If

																						public multi_head_dot_product_attention_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/blas.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'
	' #ifndef LIBND4J_HEADERS_BLAS_H
	' #define LIBND4J_HEADERS_BLAS_H

	' #include <ops/declarable/headers/common.h>

			''' <summary>
			''' This op is general matmum implementation. Depending on inputs dimensionality output result might be different.
			''' matrix x matrix = BLAS gemm
			''' vector x matrix = BLAS gemm
			''' vector x vector = BLAS dot
			''' vector x scalar = element-wise mul
			''' scalar x vector = element-wise mul
			''' 
			''' Optional T arguments:
			''' 0: alpha (where applicable)
			''' 1: beta (where applicable)
			''' 
			''' Optional Integer arguments:
			''' 0: transA (where applicable)
			''' 1: transB (where applicable)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_matmul)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matmul extends DeclarableCustomOp
			public static class matmul extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matmul(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matmul(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matmul position(Long position)
				If True Then
					Return CType(MyBase.position(position), matmul)
				End If
				public matmul getPointer(Long i)
				If True Then
					Return (New matmul(CType(Me, Pointer))).position(position + i)
				End If

																						public matmul()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class matmul_bp extends DeclarableCustomOp
			public static class matmul_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public matmul_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public matmul_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public matmul_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), matmul_bp)
				End If
				public matmul_bp getPointer(Long i)
				If True Then
					Return (New matmul_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public matmul_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' tensorMmul/tensorDot operation
			''' takes 2 ndarrays, and 2 sets of axes
			''' 
			''' Integer argumens map:
			''' IArgs[0] - number of axes along for first array
			''' IArgs[1]... axes values for first array
			''' IArgs[] - number of axes along for second array
			''' IArgs[1]... axes values for second array
			''' </summary>
	'         #if NOT_EXCLUDED(OP_tensormmul)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tensormmul extends DeclarableCustomOp
			public static class tensormmul extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tensormmul(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tensormmul(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tensormmul position(Long position)
				If True Then
					Return CType(MyBase.position(position), tensormmul)
				End If
				public tensormmul getPointer(Long i)
				If True Then
					Return (New tensormmul(CType(Me, Pointer))).position(position + i)
				End If

																						public tensormmul()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class tensormmul_bp extends DeclarableCustomOp
			public static class tensormmul_bp extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public tensormmul_bp(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public tensormmul_bp(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public tensormmul_bp position(Long position)
				If True Then
					Return CType(MyBase.position(position), tensormmul_bp)
				End If
				public tensormmul_bp getPointer(Long i)
				If True Then
					Return (New tensormmul_bp(CType(Me, Pointer))).position(position + i)
				End If

																						public tensormmul_bp()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This op is simple implementation of BLAS AXPY method.
			''' Math is: y += a * x;
			''' </summary>
	'         #if NOT_EXCLUDED(OP_axpy)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class axpy extends DeclarableOp
			public static class axpy extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public axpy(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public axpy(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public axpy position(Long position)
				If True Then
					Return CType(MyBase.position(position), axpy)
				End If
				public axpy getPointer(Long i)
				If True Then
					Return (New axpy(CType(Me, Pointer))).position(position + i)
				End If

																						public axpy()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation implements batched matrix multiplication
			''' Expected arguments:
			''' alpha: vector of T
			''' beta: vector of T
			''' ...: A, B matrices sequentially. i.e: AAAAABBBBB
			''' 
			''' Integer arguments:
			''' transA, transB, M, N, K, ldA, ldB, ldC - usual BLAS gemm arguments
			''' batchCount - number of operations in this batch
			''' 
			''' PLEASE NOTE: M, N, K, ldA, ldB, ldC should be equal for all matrices within batch.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_batched_gemm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class batched_gemm extends DeclarableCustomOp
			public static class batched_gemm extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public batched_gemm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public batched_gemm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public batched_gemm position(Long position)
				If True Then
					Return CType(MyBase.position(position), batched_gemm)
				End If
				public batched_gemm getPointer(Long i)
				If True Then
					Return (New batched_gemm(CType(Me, Pointer))).position(position + i)
				End If

																						public batched_gemm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' performs singular value decomposition (SVD) of one or more matrices, evaluates the SVD of each inner-most 2D matrix in input array:
			''' x[..., :, :] = u[..., :, :] * s[...,:] * transpose(v[..., :, :])
			''' 
			''' Input array:
			''' x[..., Rows, Cols], the necessary condition is: rank of x >= 2
			''' 
			''' Outputs arrays:
			''' s[..., diagSize] - array with singular values which are stored in decreasing order, diagSize is smaller among Rows and Cols
			''' u[..., Rows, Rows] if IArgs[1] is true, else u[..., Rows, diagSize] - array with right singular vectors
			''' v[..., Cols, Cols] if IArgs[1] is true, else v[..., Cols, diagSize] - array with left singular vectors
			''' 
			''' Integer arguments:
			''' IArgs[0] - bool, whether to calculate u and v, s is calculated in any case
			''' IArgs[1] - bool, whether to calculate full-sized u and v
			''' IArgs[2] - the number of cols or rows which determines what algorithm to use. More precisely:
			'''            if diagSize < IArgs[2] then Jacobi algorithm is used, in opposite case the Divide-And-Conquer is applied
			'''            Recommended value is 16.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_svd)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class svd extends DeclarableCustomOp
			public static class svd extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public svd(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public svd(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public svd position(Long position)
				If True Then
					Return CType(MyBase.position(position), svd)
				End If
				public svd getPointer(Long i)
				If True Then
					Return (New svd(CType(Me, Pointer))).position(position + i)
				End If

																						public svd()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' calculates square root of matrix such that
			''' x[..., M, M] = z[..., M, M] x z[..., M, M]
			''' 
			''' Input array:
			''' x[..., M, M],  the necessary condition is: rank of x >= 2 and equality of last two dimensions
			''' 
			''' Outputs arrays:
			''' z - same shape as x
			''' </summary>
	'         #if NOT_EXCLUDED(OP_sqrtm)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sqrtm extends DeclarableOp
			public static class sqrtm extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sqrtm(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sqrtm(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sqrtm position(Long position)
				If True Then
					Return CType(MyBase.position(position), sqrtm)
				End If
				public sqrtm getPointer(Long i)
				If True Then
					Return (New sqrtm(CType(Me, Pointer))).position(position + i)
				End If

																						public sqrtm()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/tests.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'
	' #include <ops/declarable/headers/common.h>
	'         #if NOT_EXCLUDED(OP_test_output_reshape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class test_output_reshape extends DeclarableOp
			public static class test_output_reshape extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public test_output_reshape(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public test_output_reshape(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public test_output_reshape position(Long position)
				If True Then
					Return CType(MyBase.position(position), test_output_reshape)
				End If
				public test_output_reshape getPointer(Long i)
				If True Then
					Return (New test_output_reshape(CType(Me, Pointer))).position(position + i)
				End If

														public test_output_reshape()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_test_scalar)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class test_scalar extends DeclarableCustomOp
			public static class test_scalar extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public test_scalar(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public test_scalar(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public test_scalar position(Long position)
				If True Then
					Return CType(MyBase.position(position), test_scalar)
				End If
				public test_scalar getPointer(Long i)
				If True Then
					Return (New test_scalar(CType(Me, Pointer))).position(position + i)
				End If

																						public test_scalar()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_testreduction)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class testreduction extends DeclarableReductionOp
			public static class testreduction extends DeclarableReductionOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public testreduction(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public testreduction(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public testreduction position(Long position)
				If True Then
					Return CType(MyBase.position(position), testreduction)
				End If
				public testreduction getPointer(Long i)
				If True Then
					Return (New testreduction(CType(Me, Pointer))).position(position + i)
				End If

																						public testreduction()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_noop)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class noop extends DeclarableOp
			public static class noop extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public noop(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public noop(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public noop position(Long position)
				If True Then
					Return CType(MyBase.position(position), noop)
				End If
				public noop getPointer(Long i)
				If True Then
					Return (New noop(CType(Me, Pointer))).position(position + i)
				End If

														public noop()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_testop2i2o)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class testop2i2o extends DeclarableOp
			public static class testop2i2o extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public testop2i2o(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public testop2i2o(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public testop2i2o position(Long position)
				If True Then
					Return CType(MyBase.position(position), testop2i2o)
				End If
				public testop2i2o getPointer(Long i)
				If True Then
					Return (New testop2i2o(CType(Me, Pointer))).position(position + i)
				End If

														public testop2i2o()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

	'         #if NOT_EXCLUDED(OP_testcustom)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class testcustom extends DeclarableCustomOp
			public static class testcustom extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public testcustom(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public testcustom(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public testcustom position(Long position)
				If True Then
					Return CType(MyBase.position(position), testcustom)
				End If
				public testcustom getPointer(Long i)
				If True Then
					Return (New testcustom(CType(Me, Pointer))).position(position + i)
				End If

																						public testcustom()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' Parsed from ops/declarable/headers/bitwise.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_BITWISE_H
	' #define LIBND4J_HEADERS_BITWISE_H

	' #include <ops/declarable/headers/common.h>
			''' <summary>
			''' This operation toggles individual bits of each element in array
			''' 
			''' PLEASE NOTE: This operation is possible only on integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_toggle_bits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class toggle_bits extends DeclarableOp
			public static class toggle_bits extends DeclarableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public toggle_bits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public toggle_bits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public toggle_bits position(Long position)
				If True Then
					Return CType(MyBase.position(position), toggle_bits)
				End If
				public toggle_bits getPointer(Long i)
				If True Then
					Return (New toggle_bits(CType(Me, Pointer))).position(position + i)
				End If

														public toggle_bits()
														If True Then
															MyBase(DirectCast(Nothing, Pointer))
															allocate()
														End If
														private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
														public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This operation shift individual bits of each element in array to the left: <<
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_shift_bits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class shift_bits extends BroadcastableOp
			public static class shift_bits extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public shift_bits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public shift_bits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public shift_bits position(Long position)
				If True Then
					Return CType(MyBase.position(position), shift_bits)
				End If
				public shift_bits getPointer(Long i)
				If True Then
					Return (New shift_bits(CType(Me, Pointer))).position(position + i)
				End If

																						public shift_bits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation shift individual bits of each element in array to the right: >>
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_rshift_bits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class rshift_bits extends BroadcastableOp
			public static class rshift_bits extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public rshift_bits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public rshift_bits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public rshift_bits position(Long position)
				If True Then
					Return CType(MyBase.position(position), rshift_bits)
				End If
				public rshift_bits getPointer(Long i)
				If True Then
					Return (New rshift_bits(CType(Me, Pointer))).position(position + i)
				End If

																						public rshift_bits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation shift individual bits of each element in array, shifting to the left
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_cyclic_shift_bits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cyclic_shift_bits extends BroadcastableOp
			public static class cyclic_shift_bits extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cyclic_shift_bits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cyclic_shift_bits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cyclic_shift_bits position(Long position)
				If True Then
					Return CType(MyBase.position(position), cyclic_shift_bits)
				End If
				public cyclic_shift_bits getPointer(Long i)
				If True Then
					Return (New cyclic_shift_bits(CType(Me, Pointer))).position(position + i)
				End If

																						public cyclic_shift_bits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation shift individual bits of each element in array, shifting to the right
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_cyclic_rshift_bits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cyclic_rshift_bits extends BroadcastableOp
			public static class cyclic_rshift_bits extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cyclic_rshift_bits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cyclic_rshift_bits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cyclic_rshift_bits position(Long position)
				If True Then
					Return CType(MyBase.position(position), cyclic_rshift_bits)
				End If
				public cyclic_rshift_bits getPointer(Long i)
				If True Then
					Return (New cyclic_rshift_bits(CType(Me, Pointer))).position(position + i)
				End If

																						public cyclic_rshift_bits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation applies bitwise AND
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bitwise_and)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bitwise_and extends BroadcastableOp
			public static class bitwise_and extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public bitwise_and(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public bitwise_and(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public bitwise_and position(Long position)
				If True Then
					Return CType(MyBase.position(position), bitwise_and)
				End If
				public bitwise_and getPointer(Long i)
				If True Then
					Return (New bitwise_and(CType(Me, Pointer))).position(position + i)
				End If

																						public bitwise_and()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation applies bitwise OR
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bitwise_or)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bitwise_or extends BroadcastableOp
			public static class bitwise_or extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public bitwise_or(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public bitwise_or(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public bitwise_or position(Long position)
				If True Then
					Return CType(MyBase.position(position), bitwise_or)
				End If
				public bitwise_or getPointer(Long i)
				If True Then
					Return (New bitwise_or(CType(Me, Pointer))).position(position + i)
				End If

																						public bitwise_or()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation applies bitwise XOR
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bitwise_xor)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bitwise_xor extends BroadcastableOp
			public static class bitwise_xor extends BroadcastableOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public bitwise_xor(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public bitwise_xor(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public bitwise_xor position(Long position)
				If True Then
					Return CType(MyBase.position(position), bitwise_xor)
				End If
				public bitwise_xor getPointer(Long i)
				If True Then
					Return (New bitwise_xor(CType(Me, Pointer))).position(position + i)
				End If

																						public bitwise_xor()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
			End If
	'         #endif

			''' <summary>
			''' This operation returns hamming distance based on bits
			''' 
			''' PLEASE NOTE: This operation is applicable only to integer data types
			''' 
			''' \tparam T
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bits_hamming_distance)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bits_hamming_distance extends DeclarableCustomOp
			public static class bits_hamming_distance extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public bits_hamming_distance(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public bits_hamming_distance(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public bits_hamming_distance position(Long position)
				If True Then
					Return CType(MyBase.position(position), bits_hamming_distance)
				End If
				public bits_hamming_distance getPointer(Long i)
				If True Then
					Return (New bits_hamming_distance(CType(Me, Pointer))).position(position + i)
				End If

																						public bits_hamming_distance()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	' Parsed from ops/declarable/headers/loss.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_LOSS_H
	' #define LIBND4J_HEADERS_LOSS_H

	' #include <ops/declarable/headers/common.h>

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of hinge loss function max(0, 1 - labels*logits)
		''' 
		''' Input arrays: 
		'''    0: logits - logits, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
		'''    2: labels - ground truth vales, expected to be 0. or 1., type float.
		'''       Must have the same shape as logits.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as logits.
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as logits or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_hinge_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hinge_loss extends DeclarableCustomOp
			public static class hinge_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hinge_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hinge_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hinge_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), hinge_loss)
				End If
				public hinge_loss getPointer(Long i)
				If True Then
					Return (New hinge_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public hinge_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class hinge_loss_grad extends DeclarableCustomOp
			public static class hinge_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public hinge_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public hinge_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public hinge_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), hinge_loss_grad)
				End If
				public hinge_loss_grad getPointer(Long i)
				If True Then
					Return (New hinge_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public hinge_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of Huber loss function:
		'''    0.5 * (labels-predictions)^2                                if |labels-predictions| <= delta
		'''    0.5 * delta^2 + delta * (|labels-predictions| - delta)      if |labels-predictions| >  delta
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels, and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as predictions
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		'''  Input float arguments:
		'''    0: point where the huber loss function changes from a quadratic to linear.
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as predictions or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_huber_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class huber_loss extends DeclarableCustomOp
			public static class huber_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public huber_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public huber_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public huber_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), huber_loss)
				End If
				public huber_loss getPointer(Long i)
				If True Then
					Return (New huber_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public huber_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class huber_loss_grad extends DeclarableCustomOp
			public static class huber_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public huber_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public huber_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public huber_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), huber_loss_grad)
				End If
				public huber_loss_grad getPointer(Long i)
				If True Then
					Return (New huber_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public huber_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of logarithmic loss function ( y_i * log(p_i) + (1 - y_i) * log(1 - p_i) )
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels, and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as predictions
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		'''  Input float arguments:
		'''    0: a small increment to add to avoid taking a log of zero. 
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as predictions or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_log_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_loss extends DeclarableCustomOp
			public static class log_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_loss)
				End If
				public log_loss getPointer(Long i)
				If True Then
					Return (New log_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public log_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_loss_grad extends DeclarableCustomOp
			public static class log_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_loss_grad)
				End If
				public log_loss_grad getPointer(Long i)
				If True Then
					Return (New log_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public log_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' l2_loss op.
			''' compute a l2 norm for given array.
			''' 
			''' input param - an array (tensor)
			''' output value - a real number with given type (e.g. float or double)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_l2_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class l2_loss extends DeclarableCustomOp
			public static class l2_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public l2_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public l2_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public l2_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), l2_loss)
				End If
				public l2_loss getPointer(Long i)
				If True Then
					Return (New l2_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public l2_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


			''' <summary>
			''' This op calculates logarithmic loss of poisson distributed input.
			''' Input arrays:
			'''    0: log_predictions - must be already pre-transformed to log(x)
			'''    1: weights - is used for weighting (multiplying) of loss values, type float.
			'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
			'''    2: labels - ground truth vales, expected to be 0. or 1., type float.
			'''       Must have the same shape as logits.
			''' 
			'''  Input integer arguments:
			'''    0: type of reduction to apply to loss
			'''       0 - "none", unreduced weighted losses with the same shape as logits.
			'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
			'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
			'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
			'''    1: optional - boolean value compute_full_loss: 0 (default) or 1 (compute)
			''' 
			''' Output array:
			'''    0: loss values, type float.
			'''       Can be an array with the same shape as log_predictions or just single scalar, depending on reduction mode (see input integer argument)
			''' </summary>
	'         #if NOT_EXCLUDED(OP_log_poisson_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_poisson_loss extends DeclarableCustomOp
			public static class log_poisson_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_poisson_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_poisson_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_poisson_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_poisson_loss)
				End If
				public log_poisson_loss getPointer(Long i)
				If True Then
					Return (New log_poisson_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public log_poisson_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class log_poisson_loss_grad extends DeclarableCustomOp
			public static class log_poisson_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public log_poisson_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public log_poisson_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public log_poisson_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), log_poisson_loss_grad)
				End If
				public log_poisson_loss_grad getPointer(Long i)
				If True Then
					Return (New log_poisson_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public log_poisson_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of pairwise-errors-squared loss function 
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float.
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		''' Output array: 
		'''    0: loss value, it is just single scalar, type float.
		''' </summary>
	'         #if NOT_EXCLUDED(OP_mean_pairwssqerr_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mean_pairwssqerr_loss extends DeclarableCustomOp
			public static class mean_pairwssqerr_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mean_pairwssqerr_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mean_pairwssqerr_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mean_pairwssqerr_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), mean_pairwssqerr_loss)
				End If
				public mean_pairwssqerr_loss getPointer(Long i)
				If True Then
					Return (New mean_pairwssqerr_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public mean_pairwssqerr_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mean_pairwssqerr_loss_grad extends DeclarableCustomOp
			public static class mean_pairwssqerr_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mean_pairwssqerr_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mean_pairwssqerr_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mean_pairwssqerr_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), mean_pairwssqerr_loss_grad)
				End If
				public mean_pairwssqerr_loss_grad getPointer(Long i)
				If True Then
					Return (New mean_pairwssqerr_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public mean_pairwssqerr_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of Sum-of-Squares loss function 1/N * sum_{i}^{N}(predictions_i - labels_i)^2
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as predictions
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as predictions or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_mean_sqerr_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mean_sqerr_loss extends DeclarableCustomOp
			public static class mean_sqerr_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mean_sqerr_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mean_sqerr_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mean_sqerr_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), mean_sqerr_loss)
				End If
				public mean_sqerr_loss getPointer(Long i)
				If True Then
					Return (New mean_sqerr_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public mean_sqerr_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class mean_sqerr_loss_grad extends DeclarableCustomOp
			public static class mean_sqerr_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public mean_sqerr_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public mean_sqerr_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public mean_sqerr_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), mean_sqerr_loss_grad)
				End If
				public mean_sqerr_loss_grad getPointer(Long i)
				If True Then
					Return (New mean_sqerr_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public mean_sqerr_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of sigmoid cross-entropy loss function max(logits, 0.) - logits * labels + log(1. + exp(-abs(logits))); 
		''' 
		''' Input arrays: 
		'''    0: logits - logits, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels, and must be broadcastable to labels.
		'''    2: labels - ground truth vales, expected to be 0. or 1., type float.
		'''       Must have the same shape as logits.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as logits.
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		'''  Input float arguments:
		'''    0: smoothing value, if it is greater than 0 then apply smoothing to the labels (smooth the labels towards 1/2): new_labels = labels * (1 - labelsSmoothing)+ 0.5 * labelsSmoothing
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as logits or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sigm_cross_entropy_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sigm_cross_entropy_loss extends DeclarableCustomOp
			public static class sigm_cross_entropy_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sigm_cross_entropy_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sigm_cross_entropy_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sigm_cross_entropy_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), sigm_cross_entropy_loss)
				End If
				public sigm_cross_entropy_loss getPointer(Long i)
				If True Then
					Return (New sigm_cross_entropy_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public sigm_cross_entropy_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sigm_cross_entropy_loss_grad extends DeclarableCustomOp
			public static class sigm_cross_entropy_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sigm_cross_entropy_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sigm_cross_entropy_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sigm_cross_entropy_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), sigm_cross_entropy_loss_grad)
				End If
				public sigm_cross_entropy_loss_grad getPointer(Long i)
				If True Then
					Return (New sigm_cross_entropy_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public sigm_cross_entropy_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of softmax cross-entropy loss function max(logits, 0.) - logits * labels + log(1. + exp(-abs(logits))); 
		''' 
		''' Input arrays: 
		'''    0: logits - logits, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels, and must be broadcastable to labels.
		'''    2: labels - ground truth vales, expected to be 0. or 1., type float.
		'''       Must have the same shape as logits.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as logits.
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		'''  Input float arguments:
		'''    0: smoothing value, if it is greater than 0 then apply smoothing to the labels (smooth the labels towards 1/numClasses):  new_labels = labels * (1 - labelsSmoothing) + labelsSmoothing / numClasses
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with shape as in logits except last dimension is equal to unity or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_softmax_cross_entropy_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax_cross_entropy_loss extends DeclarableCustomOp
			public static class softmax_cross_entropy_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax_cross_entropy_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax_cross_entropy_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax_cross_entropy_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax_cross_entropy_loss)
				End If
				public softmax_cross_entropy_loss getPointer(Long i)
				If True Then
					Return (New softmax_cross_entropy_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax_cross_entropy_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax_cross_entropy_loss_grad extends DeclarableCustomOp
			public static class softmax_cross_entropy_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax_cross_entropy_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax_cross_entropy_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax_cross_entropy_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax_cross_entropy_loss_grad)
				End If
				public softmax_cross_entropy_loss_grad getPointer(Long i)
				If True Then
					Return (New softmax_cross_entropy_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax_cross_entropy_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of Absolute Difference loss function |predictions - labels|
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float.
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as predictions
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as predictions or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_absolute_difference_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class absolute_difference_loss extends DeclarableCustomOp
			public static class absolute_difference_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public absolute_difference_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public absolute_difference_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public absolute_difference_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), absolute_difference_loss)
				End If
				public absolute_difference_loss getPointer(Long i)
				If True Then
					Return (New absolute_difference_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public absolute_difference_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class absolute_difference_loss_grad extends DeclarableCustomOp
			public static class absolute_difference_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public absolute_difference_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public absolute_difference_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public absolute_difference_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), absolute_difference_loss_grad)
				End If
				public absolute_difference_loss_grad getPointer(Long i)
				If True Then
					Return (New absolute_difference_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public absolute_difference_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif


		'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of cosine-distance loss function 1. - (predictions * labels).reduce_sum_along(dimension)
		''' 
		''' Input arrays: 
		'''    0: predictions - the predicted values, type float
		'''    1: weights - is used for weighting (multiplying) of loss values, type float. 
		'''       Can be single scalar or has the same rank as labels and must be broadcastable to labels.
		'''    2: labels - ground truth vales, type float.
		'''       Must have the same shape as predictions.    
		''' 
		'''  Input integer arguments:
		'''    0: type of reduction to apply to loss
		'''       0 - "none", unreduced weighted losses with the same shape as predictions
		'''       1 - "weighted_sum", output is scalar and equal to sum of all elements of weightedLosses array
		'''       2 - "weighted_mean", output is scalar and equal to sum of all elements of weightedLosses array divided by sum of all elements of weightsBroad array
		'''       3 - "weighted_sum_by_nonzero_weights", output is scalar and equal to scalar sum of all elements of weightedLosses array divided by number of non-zero weights
		'''    1: dimension along which the cosine distance is computed.
		'''   
		''' Output array: 
		'''    0: loss values, type float.
		'''       Can be an array with the same shape as predictions or just single scalar, depending on reduction mode (see input integer argument)
		''' </summary>
	'         #if NOT_EXCLUDED(OP_cosine_distance_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cosine_distance_loss extends DeclarableCustomOp
			public static class cosine_distance_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cosine_distance_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cosine_distance_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cosine_distance_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), cosine_distance_loss)
				End If
				public cosine_distance_loss getPointer(Long i)
				If True Then
					Return (New cosine_distance_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public cosine_distance_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cosine_distance_loss_grad extends DeclarableCustomOp
			public static class cosine_distance_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cosine_distance_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cosine_distance_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cosine_distance_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), cosine_distance_loss_grad)
				End If
				public cosine_distance_loss_grad getPointer(Long i)
				If True Then
					Return (New cosine_distance_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public cosine_distance_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of softmax cross-entropy loss function 
		''' 
		''' Input arrays: 
		'''    0: logits - logits, type float
		'''    1: labels - ground truth vales, expected to be 0. or 1., type float.
		'''       Must have the same shape as logits.    
		''' 
		'''  Input integer arguments:
		'''    0: optional (default is last dimension) dimension with classes
		'''   
		''' Output array: 
		'''    0: loss values, type float. An array with shape resulting from reducing of logits shape along dimension with classes
		''' </summary>
	'         #if NOT_EXCLUDED(OP_softmax_cross_entropy_loss_with_logits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax_cross_entropy_loss_with_logits extends DeclarableCustomOp
			public static class softmax_cross_entropy_loss_with_logits extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax_cross_entropy_loss_with_logits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax_cross_entropy_loss_with_logits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax_cross_entropy_loss_with_logits position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax_cross_entropy_loss_with_logits)
				End If
				public softmax_cross_entropy_loss_with_logits getPointer(Long i)
				If True Then
					Return (New softmax_cross_entropy_loss_with_logits(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax_cross_entropy_loss_with_logits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class softmax_cross_entropy_loss_with_logits_grad extends DeclarableCustomOp
			public static class softmax_cross_entropy_loss_with_logits_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public softmax_cross_entropy_loss_with_logits_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public softmax_cross_entropy_loss_with_logits_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public softmax_cross_entropy_loss_with_logits_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), softmax_cross_entropy_loss_with_logits_grad)
				End If
				public softmax_cross_entropy_loss_with_logits_grad getPointer(Long i)
				If True Then
					Return (New softmax_cross_entropy_loss_with_logits_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public softmax_cross_entropy_loss_with_logits_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			'////////////////////////////////////////////////////////////////////////
		''' <summary>
		''' Implementation of sparse softmax cross-entropy loss function
		''' 
		''' Input arrays:        
		'''    0: labels - ground truth vales, expected to be within range [0, num_classes), type float.
		'''       Must have rank equal logits rank minus 1.
		'''    1: logits - logits, type float
		''' 
		''' Output array: 
		'''    0: loss values, type float. Has the same shape as labels
		''' </summary>
	'         #if NOT_EXCLUDED(OP_sparse_softmax_cross_entropy_loss_with_logits)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sparse_softmax_cross_entropy_loss_with_logits extends DeclarableCustomOp
			public static class sparse_softmax_cross_entropy_loss_with_logits extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sparse_softmax_cross_entropy_loss_with_logits(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sparse_softmax_cross_entropy_loss_with_logits(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sparse_softmax_cross_entropy_loss_with_logits position(Long position)
				If True Then
					Return CType(MyBase.position(position), sparse_softmax_cross_entropy_loss_with_logits)
				End If
				public sparse_softmax_cross_entropy_loss_with_logits getPointer(Long i)
				If True Then
					Return (New sparse_softmax_cross_entropy_loss_with_logits(CType(Me, Pointer))).position(position + i)
				End If

																						public sparse_softmax_cross_entropy_loss_with_logits()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class sparse_softmax_cross_entropy_loss_with_logits_grad extends DeclarableCustomOp
			public static class sparse_softmax_cross_entropy_loss_with_logits_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public sparse_softmax_cross_entropy_loss_with_logits_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public sparse_softmax_cross_entropy_loss_with_logits_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public sparse_softmax_cross_entropy_loss_with_logits_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), sparse_softmax_cross_entropy_loss_with_logits_grad)
				End If
				public sparse_softmax_cross_entropy_loss_with_logits_grad getPointer(Long i)
				If True Then
					Return (New sparse_softmax_cross_entropy_loss_with_logits_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public sparse_softmax_cross_entropy_loss_with_logits_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

		  ''' <summary>
		  ''' Implementation of CTC loss function
		  ''' 
		  ''' Input arrays:
		  '''    0: labels - labels NDArray {BATCH_LEN, MAX_TARGET_LEN}, type integer
		  '''    1: logits - logits NDArray {BATCH_LEN, FRAME_LEN, CLASS_LEN }. It should include a blank label as well, type float
		  '''    NOTE: we expect normalized logits (softmax normalized logarithm values for logits).
		  '''    2: targetLabelLengths - Length of label sequence in labels NDArray {BATCH_LEN}, type integer
		  '''    3: logitsLengths - Length of input sequence in logits NDArray {BATCH_LEN}, type integer
		  ''' 
		  ''' 
		  '''  Input integer arguments:
		  '''    0: blank index - index of the blank label in logits
		  ''' 
		  ''' Output array:
		  '''    0: loss values, type float. NDArray {BATCH_LEN} negative log probabilities of loss
		  ''' </summary>
	'         #if NOT_EXCLUDED(OP_ctc_loss)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class ctc_loss extends DeclarableCustomOp
			public static class ctc_loss extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ctc_loss(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ctc_loss(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ctc_loss position(Long position)
				If True Then
					Return CType(MyBase.position(position), ctc_loss)
				End If
				public ctc_loss getPointer(Long i)
				If True Then
					Return (New ctc_loss(CType(Me, Pointer))).position(position + i)
				End If

																						public ctc_loss()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class ctc_loss_grad extends DeclarableCustomOp
			public static class ctc_loss_grad extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public ctc_loss_grad(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public ctc_loss_grad(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public ctc_loss_grad position(Long position)
				If True Then
					Return CType(MyBase.position(position), ctc_loss_grad)
				End If
				public ctc_loss_grad getPointer(Long i)
				If True Then
					Return (New ctc_loss_grad(CType(Me, Pointer))).position(position + i)
				End If

																						public ctc_loss_grad()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif





	' #endif

	' Parsed from ops/declarable/headers/datatypes.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'
	' #ifndef LIBND4J_HEADERS_DTYPE_H
	' #define LIBND4J_HEADERS_DTYPE_H

	' #include <ops/declarable/headers/common.h>
			''' <summary>
			''' This operation casts elements of input array to double data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_double)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_double extends DeclarableCustomOp
			public static class to_double extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_double(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_double(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_double position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_double)
				End If
				public to_double getPointer(Long i)
				If True Then
					Return (New to_double(CType(Me, Pointer))).position(position + i)
				End If

																						public to_double()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to float16 data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_float16)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_float16 extends DeclarableCustomOp
			public static class to_float16 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_float16(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_float16(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_float16 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_float16)
				End If
				public to_float16 getPointer(Long i)
				If True Then
					Return (New to_float16(CType(Me, Pointer))).position(position + i)
				End If

																						public to_float16()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to float data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_float32)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_float32 extends DeclarableCustomOp
			public static class to_float32 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_float32(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_float32(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_float32 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_float32)
				End If
				public to_float32 getPointer(Long i)
				If True Then
					Return (New to_float32(CType(Me, Pointer))).position(position + i)
				End If

																						public to_float32()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to int32 data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_int32)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_int32 extends DeclarableCustomOp
			public static class to_int32 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_int32(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_int32(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_int32 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_int32)
				End If
				public to_int32 getPointer(Long i)
				If True Then
					Return (New to_int32(CType(Me, Pointer))).position(position + i)
				End If

																						public to_int32()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to int64 (aka long long) data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_int64)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_int64 extends DeclarableCustomOp
			public static class to_int64 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_int64(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_int64(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_int64 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_int64)
				End If
				public to_int64 getPointer(Long i)
				If True Then
					Return (New to_int64(CType(Me, Pointer))).position(position + i)
				End If

																						public to_int64()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to unsinged int32 data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_uint32)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_uint32 extends DeclarableCustomOp
			public static class to_uint32 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_uint32(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_uint32(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_uint32 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_uint32)
				End If
				public to_uint32 getPointer(Long i)
				If True Then
					Return (New to_uint32(CType(Me, Pointer))).position(position + i)
				End If

																						public to_uint32()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to unsigned int64 (aka unsigned long long) data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' </summary>
	'         #if NOT_EXCLUDED(OP_to_uint64)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class to_uint64 extends DeclarableCustomOp
			public static class to_uint64 extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public to_uint64(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public to_uint64(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public to_uint64 position(Long position)
				If True Then
					Return CType(MyBase.position(position), to_uint64)
				End If
				public to_uint64 getPointer(Long i)
				If True Then
					Return (New to_uint64(CType(Me, Pointer))).position(position + i)
				End If

																						public to_uint64()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif

			''' <summary>
			''' This operation casts elements of input array to specified data type
			''' 
			''' PLEASE NOTE: This op is disabled atm, and reserved for future releases.
			''' 
			''' 
			''' Int args:
			''' 0: target DataType
			''' </summary>
	'         #if NOT_EXCLUDED(OP_cast)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class cast extends DeclarableCustomOp
			public static class cast extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public cast(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public cast(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public cast position(Long position)
				If True Then
					Return CType(MyBase.position(position), cast)
				End If
				public cast getPointer(Long i)
				If True Then
					Return (New cast(CType(Me, Pointer))).position(position + i)
				End If

																						public cast()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif
			''' <summary>
			''' This operation change type of input and modified shape of output to conform with given data type
			''' 
			''' all as above op
			''' 
			''' </summary>
	'         #if NOT_EXCLUDED(OP_bitcast)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class bitcast extends DeclarableCustomOp
					public static class bitcast extends DeclarableCustomOp
					If True Then
						''' <summary>
						''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
						public bitcast(Pointer p)
						If True Then
							MyBase(p)
						End If
						''' <summary>
						''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
						public bitcast(Long size)
						If True Then
							MyBase(DirectCast(Nothing, Pointer))
							allocateArray(size)
						End If
						private native void allocateArray(Long size)
						public bitcast position(Long position)
						If True Then
							Return CType(MyBase.position(position), bitcast)
						End If
						public bitcast getPointer(Long i)
						If True Then
							Return (New bitcast(CType(Me, Pointer))).position(position + i)
						End If

																						public bitcast()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
					End If
	'         #endif



	' #endif

	' Parsed from execution/ContextBuffers.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' @author raver119@gmail.com
	'

	' #ifndef LIBND4J_CONTEXTBUFFERS_H
	' #define LIBND4J_CONTEXTBUFFERS_H

	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <execution/ErrorReference.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ContextBuffers extends Pointer
		public static class ContextBuffers extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public ContextBuffers(Pointer p)
			If True Then
				MyBase(p)
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public ContextBuffers(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			private native void allocateArray(Long size)
			public ContextBuffers position(Long position)
			If True Then
				Return CType(MyBase.position(position), ContextBuffers)
			End If
			public ContextBuffers getPointer(Long i)
			If True Then
				Return (New ContextBuffers(CType(Me, Pointer))).position(position + i)
			End If

			public ContextBuffers()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ContextBuffers(@Const @ByRef ContextBuffers other)
			public ContextBuffers( ContextBuffers other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ContextBuffers other);
			private native void allocate( ContextBuffers other)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ContextBuffers(Pointer rPointer, Pointer sPointer, Pointer aPointer, @Cast("bool") boolean isOwner)
			public ContextBuffers(Pointer rPointer, Pointer sPointer, Pointer aPointer, Boolean isOwner)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(rPointer, sPointer, aPointer, isOwner)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(Pointer rPointer, Pointer sPointer, Pointer aPointer, @Cast("bool") boolean isOwner);
			private native void allocate(Pointer rPointer, Pointer sPointer, Pointer aPointer, Boolean isOwner)
			public ContextBuffers(Pointer rPointer, Pointer sPointer, Pointer aPointer)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(rPointer, sPointer, aPointer)
			End If
			private native void allocate(Pointer rPointer, Pointer sPointer, Pointer aPointer)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") ContextBuffers put(@Const @ByRef ContextBuffers other);
			public native @Name("operator =") ContextBuffers put( ContextBuffers other)

			public native void release()

			public native Pointer reductionBuffer()
			public native Pointer scalarBuffer()
			public native Pointer allocationBuffer()

			public native Pointer execStream()
			public native Pointer specialStream()

			public native void setReductionBuffer(Pointer pointer)
			public native void setScalarBuffer(Pointer pointer)
			public native void setAllocationBuffer(Pointer pointer)

			public native ErrorReference errorReference()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void triggerOwnership(@Cast("bool") boolean isOwner);
			public native void triggerOwnership( Boolean isOwner)

			public native Integer deviceId()

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInitialized();
			public native Boolean isInitialized()
		End If



	' #endif //DEV_TESTS_CONTEXTBUFFERS_H


	' Parsed from execution/LaunchContext.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by raver119 on 30.11.17.
	'

	' #ifndef LIBND4J_CUDACONTEXT_H
	' #define LIBND4J_CUDACONTEXT_H


	' #ifdef __CUDABLAS__
	' #endif

	' used for MKLDNN etc
	' #if !defined(__STANDALONE_BUILD__)
	' #include "config.h"
	' #endif

	' #include <system/dll.h>
	' #include <memory>
	' #include <system/op_boilerplate.h>
	' #include <memory/Workspace.h>
	' #include <vector>
	' #include <mutex>
	' #include <execution/ContextBuffers.h>
	' #include <execution/ErrorReference.h>

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class LaunchContext extends Pointer
	public static class LaunchContext extends Pointer
	If True Then
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public LaunchContext(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public LaunchContext position(Long position)
		If True Then
			Return CType(MyBase.position(position), LaunchContext)
		End If
		public LaunchContext getPointer(Long i)
		If True Then
			Return (New LaunchContext(CType(Me, Pointer))).position(position + i)
		End If

	' #ifdef __CUDABLAS__

	' #endif // CUDA
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public LaunchContext(@Cast("Nd4jPointer") Pointer cudaStream, @Cast("Nd4jPointer") Pointer reductionPointer, @Cast("Nd4jPointer") Pointer scalarPointer, @Cast("Nd4jPointer") Pointer allocationPointer)
			public LaunchContext( Pointer cudaStream, Pointer reductionPointer, Pointer scalarPointer, Pointer allocationPointer)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(cudaStream, reductionPointer, scalarPointer, allocationPointer)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jPointer") Pointer cudaStream, @Cast("Nd4jPointer") Pointer reductionPointer, @Cast("Nd4jPointer") Pointer scalarPointer, @Cast("Nd4jPointer") Pointer allocationPointer);
			private native void allocate( Pointer cudaStream, Pointer reductionPointer, Pointer scalarPointer, Pointer allocationPointer)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public LaunchContext(@Cast("Nd4jPointer") Pointer cudaStream)
			public LaunchContext( Pointer cudaStream)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(cudaStream)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("Nd4jPointer") Pointer cudaStream);
			private native void allocate( Pointer cudaStream)
			public LaunchContext()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()
			public native Workspace getWorkspace()
			public native void setWorkspace(Workspace theWorkspace)

			public native Pointer engine()

			public native Integer getDeviceID()
			public native void setDeviceID(Integer deviceID)
			public native ErrorReference errorReference()

	' #ifndef __JAVACPP_HACK__

	' #endif

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isInitialized();
			public native Boolean isInitialized()
			public native void releaseBuffers()


			public native LaunchContext defaultContext()


'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native void swapContextBuffers(@ByRef ContextBuffers buffers);
			public native void swapContextBuffers( ContextBuffers buffers)

	End If




	' #endif //LIBND4J_CUDACONTEXT_H


	' Parsed from array/ShapeDescriptor.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'  @author AbdelRauf 

	' #ifndef DEV_TESTS_SHAPEDESCRIPTOR_H
	' #define DEV_TESTS_SHAPEDESCRIPTOR_H

	' #include <unordered_map>
	' #include <vector>
	' #include <system/dll.h>
	' #include <system/pointercast.h>
	' #include <array/ArrayOptions.h>
	' #include <array/DataType.h>
	' #include <initializer_list>


	public static final Integer SHAPE_DESC_OK = 0
	public static final Integer SHAPE_DESC_INCORRECT_STRIDES = 1 'strides does not match shapes
	public static final Integer SHAPE_DESC_INCORRECT_EWS = 2 'ews neither matches stride nor continuity
	public static final Integer SHAPE_DESC_INCORRECT_RANK = 4 'rank > 32 or shape size and rank does not match

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class ShapeDescriptor extends Pointer
	public static class ShapeDescriptor extends Pointer
	If True Then
		''' <summary>
		''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
		public ShapeDescriptor(Pointer p)
		If True Then
			MyBase(p)
		End If
		''' <summary>
		''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
		public ShapeDescriptor(Long size)
		If True Then
			MyBase(DirectCast(Nothing, Pointer))
			allocateArray(size)
		End If
		private native void allocateArray(Long size)
		public ShapeDescriptor position(Long position)
		If True Then
			Return CType(MyBase.position(position), ShapeDescriptor)
		End If
		public ShapeDescriptor getPointer(Long i)
		If True Then
			Return (New ShapeDescriptor(CType(Me, Pointer))).position(position + i)
		End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Const @ByRef ShapeDescriptor other)
			public ShapeDescriptor( ShapeDescriptor other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor other);
			private native void allocate( ShapeDescriptor other)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("bool") boolean inheritDtype)
			public ShapeDescriptor( LongPointer shapeInfo, Boolean inheritDtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, inheritDtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("bool") boolean inheritDtype);
			private native void allocate( LongPointer shapeInfo, Boolean inheritDtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongPointer shapeInfo)
			public ShapeDescriptor( LongPointer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo);
			private native void allocate( LongPointer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("bool") boolean inheritDtype)
			public ShapeDescriptor( LongBuffer shapeInfo, Boolean inheritDtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, inheritDtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("bool") boolean inheritDtype);
			private native void allocate( LongBuffer shapeInfo, Boolean inheritDtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongBuffer shapeInfo)
			public ShapeDescriptor( LongBuffer shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo);
			private native void allocate( LongBuffer shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("bool") boolean inheritDtype)
			public ShapeDescriptor( Long() shapeInfo, Boolean inheritDtype)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, inheritDtype)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("bool") boolean inheritDtype);
			private native void allocate( Long() shapeInfo, Boolean inheritDtype)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") long[] shapeInfo)
			public ShapeDescriptor( Long() shapeInfo)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo);
			private native void allocate( Long() shapeInfo)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const sd::DataType") int dtypeOverride)
			public ShapeDescriptor( LongPointer shapeInfo, Integer dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const sd::DataType") int dtypeOverride);
			private native void allocate( LongPointer shapeInfo, Integer dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const sd::DataType") int dtypeOverride)
			public ShapeDescriptor( LongBuffer shapeInfo, Integer dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const sd::DataType") int dtypeOverride);
			private native void allocate( LongBuffer shapeInfo, Integer dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const sd::DataType") int dtypeOverride)
			public ShapeDescriptor( Long() shapeInfo, Integer dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const sd::DataType") int dtypeOverride);
			private native void allocate( Long() shapeInfo, Integer dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer dtypeOverride)
			public ShapeDescriptor( LongPointer shapeInfo, LongPointer dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer dtypeOverride);
			private native void allocate( LongPointer shapeInfo, LongPointer dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer dtypeOverride)
			public ShapeDescriptor( LongBuffer shapeInfo, LongBuffer dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer dtypeOverride);
			private native void allocate( LongBuffer shapeInfo, LongBuffer dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] dtypeOverride)
			public ShapeDescriptor( Long() shapeInfo, Long() dtypeOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] dtypeOverride);
			private native void allocate( Long() shapeInfo, Long() dtypeOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer dtypeOverride, @Cast("const Nd4jLong*") LongPointer orderOverride)
			public ShapeDescriptor( LongPointer shapeInfo, LongPointer dtypeOverride, LongPointer orderOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride, orderOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer shapeInfo, @Cast("const Nd4jLong*") LongPointer dtypeOverride, @Cast("const Nd4jLong*") LongPointer orderOverride);
			private native void allocate( LongPointer shapeInfo, LongPointer dtypeOverride, LongPointer orderOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer dtypeOverride, @Cast("const Nd4jLong*") LongBuffer orderOverride)
			public ShapeDescriptor( LongBuffer shapeInfo, LongBuffer dtypeOverride, LongBuffer orderOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride, orderOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer shapeInfo, @Cast("const Nd4jLong*") LongBuffer dtypeOverride, @Cast("const Nd4jLong*") LongBuffer orderOverride);
			private native void allocate( LongBuffer shapeInfo, LongBuffer dtypeOverride, LongBuffer orderOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] dtypeOverride, @Cast("const Nd4jLong*") long[] orderOverride)
			public ShapeDescriptor( Long() shapeInfo, Long() dtypeOverride, Long() orderOverride)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(shapeInfo, dtypeOverride, orderOverride)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] shapeInfo, @Cast("const Nd4jLong*") long[] dtypeOverride, @Cast("const Nd4jLong*") long[] orderOverride);
			private native void allocate( Long() shapeInfo, Long() dtypeOverride, Long() orderOverride)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, @Cast("const Nd4jLong") long length)
			public ShapeDescriptor( Integer type, Long length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, @Cast("const Nd4jLong") long length);
			private native void allocate( Integer type, Long length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongPointer shape, int rank)
			public ShapeDescriptor( Integer type, SByte order, LongPointer shape, Integer rank)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, rank)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongPointer shape, int rank);
			private native void allocate( Integer type, SByte order, LongPointer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongBuffer shape, int rank)
			public ShapeDescriptor( Integer type, SByte order, LongBuffer shape, Integer rank)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, rank)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongBuffer shape, int rank);
			private native void allocate( Integer type, SByte order, LongBuffer shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") long[] shape, int rank)
			public ShapeDescriptor( Integer type, SByte order, Long() shape, Integer rank)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, rank)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") long[] shape, int rank);
			private native void allocate( Integer type, SByte order, Long() shape, Integer rank)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongPointer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape);
			private native void allocate( Integer type, SByte order, @StdVector LongPointer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongBuffer shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape);
			private native void allocate( Integer type, SByte order, @StdVector LongBuffer shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape)
			public ShapeDescriptor( Integer type, SByte order, @StdVector Long() shape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape);
			private native void allocate( Integer type, SByte order, @StdVector Long() shape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("Nd4jLong*") @StdVector LongPointer strides)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongPointer shape, @StdVector LongPointer strides)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("Nd4jLong*") @StdVector LongPointer strides);
			private native void allocate( Integer type, SByte order, @StdVector LongPointer shape, @StdVector LongPointer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("Nd4jLong*") @StdVector LongBuffer strides)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongBuffer shape, @StdVector LongBuffer strides)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("Nd4jLong*") @StdVector LongBuffer strides);
			private native void allocate( Integer type, SByte order, @StdVector LongBuffer shape, @StdVector LongBuffer strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("Nd4jLong*") @StdVector long[] strides)
			public ShapeDescriptor( Integer type, SByte order, @StdVector Long() shape, @StdVector Long() strides)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("Nd4jLong*") @StdVector long[] strides);
			private native void allocate( Integer type, SByte order, @StdVector Long() shape, @StdVector Long() strides)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("Nd4jLong*") @StdVector LongPointer strides, @Cast("const Nd4jLong") long ews)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongPointer shape, @StdVector LongPointer strides, Long ews)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, ews)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("Nd4jLong*") @StdVector LongPointer strides, @Cast("const Nd4jLong") long ews);
			private native void allocate( Integer type, SByte order, @StdVector LongPointer shape, @StdVector LongPointer strides, Long ews)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("Nd4jLong*") @StdVector LongBuffer strides, @Cast("const Nd4jLong") long ews)
			public ShapeDescriptor( Integer type, SByte order, @StdVector LongBuffer shape, @StdVector LongBuffer strides, Long ews)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, ews)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("Nd4jLong*") @StdVector LongBuffer strides, @Cast("const Nd4jLong") long ews);
			private native void allocate( Integer type, SByte order, @StdVector LongBuffer shape, @StdVector LongBuffer strides, Long ews)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("Nd4jLong*") @StdVector long[] strides, @Cast("const Nd4jLong") long ews)
			public ShapeDescriptor( Integer type, SByte order, @StdVector Long() shape, @StdVector Long() strides, Long ews)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, ews)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("Nd4jLong*") @StdVector long[] strides, @Cast("const Nd4jLong") long ews);
			private native void allocate( Integer type, SByte order, @StdVector Long() shape, @StdVector Long() strides, Long ews)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras)
			public ShapeDescriptor( Integer type, SByte order, LongPointer shape, LongPointer strides, Integer rank, Long ews, Long extras)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, rank, ews, extras)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongPointer shape, @Cast("const Nd4jLong*") LongPointer strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
			private native void allocate( Integer type, SByte order, LongPointer shape, LongPointer strides, Integer rank, Long ews, Long extras)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras)
			public ShapeDescriptor( Integer type, SByte order, LongBuffer shape, LongBuffer strides, Integer rank, Long ews, Long extras)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, rank, ews, extras)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") LongBuffer shape, @Cast("const Nd4jLong*") LongBuffer strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
			private native void allocate( Integer type, SByte order, LongBuffer shape, LongBuffer strides, Integer rank, Long ews, Long extras)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public ShapeDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras)
			public ShapeDescriptor( Integer type, SByte order, Long() shape, Long() strides, Integer rank, Long ews, Long extras)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(type, order, shape, strides, rank, ews, extras)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const sd::DataType") int type, byte order, @Cast("const Nd4jLong*") long[] shape, @Cast("const Nd4jLong*") long[] strides, int rank, @Cast("Nd4jLong") long ews, @Cast("Nd4jLong") long extras);
			private native void allocate( Integer type, SByte order, Long() shape, Long() strides, Integer rank, Long ews, Long extras)

			public ShapeDescriptor()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			private native void allocate()

			public native Integer rank()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long ews();
			public native Long ews()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long arrLength();
			public native Long arrLength()
			public native Char order()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("sd::DataType") int dataType();
			public native Integer dataType()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean isEmpty();
			public native Boolean isEmpty()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer shape();
			public native @StdVector LongPointer shape()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") @StdVector LongPointer strides();
			public native @StdVector LongPointer strides()

			'returns minimal allocation length
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long allocLength();
			public native Long allocLength()

			'returns Status for the correctness
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long validate();
			public native Long validate()

			' we use default copy assignment operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") ShapeDescriptor put(@Const @ByRef ShapeDescriptor other);
			public native @Name("operator =") ShapeDescriptor put( ShapeDescriptor other)

			' we use default move assignment operator

			' equal to operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef ShapeDescriptor other);
			public native @Name("operator ==") Boolean Equals( ShapeDescriptor other)

			' less than operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef ShapeDescriptor other);
			public native @Name("operator <") Boolean lessThan( ShapeDescriptor other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong*") LongPointer toShapeInfo();
			public native LongPointer toShapeInfo()



'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor emptyDescriptor(@Cast("const sd::DataType") int type);
			public native ShapeDescriptor emptyDescriptor( Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor scalarDescriptor(@Cast("const sd::DataType") int type);
			public native ShapeDescriptor scalarDescriptor( Integer type)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor vectorDescriptor(@Cast("const Nd4jLong") long length, @Cast("const sd::DataType") int type);
			public native ShapeDescriptor vectorDescriptor( Long length, Integer type)

			'create Descriptor with padded buffer.
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor paddedBufferDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongPointer shape, @Cast("Nd4jLong*") @StdVector LongPointer paddings);
			public native ShapeDescriptor paddedBufferDescriptor( Integer type, SByte order, @StdVector LongPointer shape, @StdVector LongPointer paddings)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor paddedBufferDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector LongBuffer shape, @Cast("Nd4jLong*") @StdVector LongBuffer paddings);
			public native ShapeDescriptor paddedBufferDescriptor( Integer type, SByte order, @StdVector LongBuffer shape, @StdVector LongBuffer paddings)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByVal ShapeDescriptor paddedBufferDescriptor(@Cast("const sd::DataType") int type, byte order, @Cast("Nd4jLong*") @StdVector long[] shape, @Cast("Nd4jLong*") @StdVector long[] paddings);
			public native ShapeDescriptor paddedBufferDescriptor( Integer type, SByte order, @StdVector Long() shape, @StdVector Long() paddings)
	End If


	' #ifndef __JAVACPP_HACK__

	' #endif


	' #endif //DEV_TESTS_SHAPEDESCRIPTOR_H


	' Parsed from array/TadDescriptor.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef DEV_TESTS_TADDESCRIPTOR_H
	' #define DEV_TESTS_TADDESCRIPTOR_H

	' #include "ShapeDescriptor.h"
	' #include <system/dll.h>
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") @NoOffset public static class TadDescriptor extends Pointer
		public static class TadDescriptor extends Pointer
		If True Then
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public TadDescriptor(Pointer p)
			If True Then
				MyBase(p)
			End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") LongPointer originalShape, @Const IntPointer dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( LongPointer originalShape, IntPointer dimensions, Integer length, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer originalShape, @Const IntPointer dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( LongPointer originalShape, IntPointer dimensions, Integer length, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") LongPointer originalShape, @Const IntPointer dimensions, int length)
			public TadDescriptor( LongPointer originalShape, IntPointer dimensions, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongPointer originalShape, @Const IntPointer dimensions, int length);
			private native void allocate( LongPointer originalShape, IntPointer dimensions, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") LongBuffer originalShape, @Const IntBuffer dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( LongBuffer originalShape, IntBuffer dimensions, Integer length, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer originalShape, @Const IntBuffer dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( LongBuffer originalShape, IntBuffer dimensions, Integer length, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") LongBuffer originalShape, @Const IntBuffer dimensions, int length)
			public TadDescriptor( LongBuffer originalShape, IntBuffer dimensions, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") LongBuffer originalShape, @Const IntBuffer dimensions, int length);
			private native void allocate( LongBuffer originalShape, IntBuffer dimensions, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") long[] originalShape, @Const int[] dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( Long() originalShape, Integer() dimensions, Integer length, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] originalShape, @Const int[] dimensions, int length, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( Long() originalShape, Integer() dimensions, Integer length, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Cast("const Nd4jLong*") long[] originalShape, @Const int[] dimensions, int length)
			public TadDescriptor( Long() originalShape, Integer() dimensions, Integer length)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(originalShape, dimensions, length)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Cast("const Nd4jLong*") long[] originalShape, @Const int[] dimensions, int length);
			private native void allocate( Long() originalShape, Integer() dimensions, Integer length)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntPointer dimensions, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( ShapeDescriptor descriptor, IntPointer dimensions, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntPointer dimensions, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( ShapeDescriptor descriptor, IntPointer dimensions, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntPointer dimensions)
			public TadDescriptor( ShapeDescriptor descriptor, IntPointer dimensions)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntPointer dimensions);
			private native void allocate( ShapeDescriptor descriptor, IntPointer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntBuffer dimensions, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( ShapeDescriptor descriptor, IntBuffer dimensions, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntBuffer dimensions, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( ShapeDescriptor descriptor, IntBuffer dimensions, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntBuffer dimensions)
			public TadDescriptor( ShapeDescriptor descriptor, IntBuffer dimensions)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector IntBuffer dimensions);
			private native void allocate( ShapeDescriptor descriptor, IntBuffer dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector int[] dimensions, @Cast("const bool") boolean keepUnitiesInShape)
			public TadDescriptor( ShapeDescriptor descriptor, Integer() dimensions, Boolean keepUnitiesInShape)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions, keepUnitiesInShape)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector int[] dimensions, @Cast("const bool") boolean keepUnitiesInShape);
			private native void allocate( ShapeDescriptor descriptor, Integer() dimensions, Boolean keepUnitiesInShape)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef ShapeDescriptor descriptor, @StdVector int[] dimensions)
			public TadDescriptor( ShapeDescriptor descriptor, Integer() dimensions)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(descriptor, dimensions)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef ShapeDescriptor descriptor, @StdVector int[] dimensions);
			private native void allocate( ShapeDescriptor descriptor, Integer() dimensions)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public TadDescriptor(@Const @ByRef TadDescriptor other)
			public TadDescriptor( TadDescriptor other)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate(other)
			End If
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: private native void allocate(@Const @ByRef TadDescriptor other);
			private native void allocate( TadDescriptor other)

			' we use default copy assignment operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef @Name("operator =") TadDescriptor put(@Const @ByRef TadDescriptor other);
			public native @Name("operator =") TadDescriptor put( TadDescriptor other)

			' we use default move assignment operator

			' equal to operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef TadDescriptor other);
			public native @Name("operator ==") Boolean Equals( TadDescriptor other)

			' less than operator
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef TadDescriptor other);
			public native @Name("operator <") Boolean lessThan( TadDescriptor other)

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @StdVector IntPointer axis();
			public native IntPointer axis()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @ByRef ShapeDescriptor originalShape();
			public native ShapeDescriptor originalShape()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Const @ByRef ShapeDescriptor originalShapeConst();
			public native @ByRef ShapeDescriptor originalShapeConst()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("bool") boolean areUnitiesinShape();
			public native Boolean areUnitiesinShape()
		End If


	' #ifndef __JAVACPP_HACK__

	' #endif


	' #endif //DEV_TESTS_TADDESCRIPTOR_H


	' Parsed from helpers/DebugInfo.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	' Created by GS aka shugeo <sgazeos@gmail.com> on 3/12/19.
	'

	' #ifndef LIBND4J__DEBUG_INFO_HELPER__H
	' #define LIBND4J__DEBUG_INFO_HELPER__H

	' #include <system/pointercast.h>
	' #include <system/op_boilerplate.h>
	' #include <system/Environment.h>
	' #include <helpers/StringUtils.h>
	' #include <string>
	' #include <system/dll.h>
	' #include <math/templatemath.h>

	' #ifdef __CUDACC__

	' #endif
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public static class DebugInfo extends Pointer
		public static class DebugInfo extends Pointer
		If True Then
			''' <summary>
			''' Default native constructor. </summary>
			public DebugInfo()
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocate()
			End If
			''' <summary>
			''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
			public DebugInfo(Long size)
			If True Then
				MyBase(DirectCast(Nothing, Pointer))
				allocateArray(size)
			End If
			''' <summary>
			''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
			public DebugInfo(Pointer p)
			If True Then
				MyBase(p)
			End If
			private native void allocate()
			private native void allocateArray(Long size)
			public DebugInfo position(Long position)
			If True Then
				Return CType(MyBase.position(position), DebugInfo)
			End If
			public DebugInfo getPointer(Long i)
			If True Then
				Return (New DebugInfo(CType(Me, Pointer))).position(position + i)
			End If

		   public native Double _minValue()
		   public native DebugInfo _minValue(Double setter)
		   public native Double _maxValue()
		   public native DebugInfo _maxValue(Double setter)
		   public native Double _meanValue()
		   public native DebugInfo _meanValue(Double setter)
		   public native Double _stdDevValue()
		   public native DebugInfo _stdDevValue(Double setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long _zeroCount();
		   public native Long _zeroCount()
		   public native DebugInfo _zeroCount(Long setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long _positiveCount();
		   public native Long _positiveCount()
		   public native DebugInfo _positiveCount(Long setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long _negativeCount();
		   public native Long _negativeCount()
		   public native DebugInfo _negativeCount(Long setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long _infCount();
		   public native Long _infCount()
		   public native DebugInfo _infCount(Long setter)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native @Cast("Nd4jLong") long _nanCount();
		   public native Long _nanCount()
		   public native DebugInfo _nanCount(Long setter)
		End If

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd") public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef DebugInfo first, @Const @ByRef DebugInfo second);
		Boolean equals( DebugInfo first, @ByRef DebugInfo second)




	' #endif //LIBND4J_DEBUGHELPER_H


	' Parsed from ops/declarable/headers/third_party.h

	' ******************************************************************************
	' *
	' *
	' * This program and the accompanying materials are made available under the
	' * terms of the Apache License, Version 2.0 which is available at
	' * https://www.apache.org/licenses/LICENSE-2.0.
	' *
	' *  See the NOTICE file distributed with this work for additional
	' *  information regarding copyright ownership.
	' * Unless required by applicable law or agreed to in writing, software
	' * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
	' * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
	' * License for the specific language governing permissions and limitations
	' * under the License.
	' *
	' * SPDX-License-Identifier: Apache-2.0
	' *****************************************************************************

	'
	'  @author raver119@gmail.com
	'

	' #ifndef LIBND4J_HEADERS_TPARTY_H
	' #define LIBND4J_HEADERS_TPARTY_H

	' #include <ops/declarable/headers/common.h>
	'         #if NOT_EXCLUDED(OP_firas_sparse)
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @Namespace("sd::ops") public static class firas_sparse extends DeclarableCustomOp
			public static class firas_sparse extends DeclarableCustomOp
			If True Then
				''' <summary>
				''' Pointer cast constructor. Invokes <seealso cref="Pointer.Pointer(Pointer)"/>. </summary>
				public firas_sparse(Pointer p)
				If True Then
					MyBase(p)
				End If
				''' <summary>
				''' Native array allocator. Access with <seealso cref="Pointer.position(Long)"/>. </summary>
				public firas_sparse(Long size)
				If True Then
					MyBase(DirectCast(Nothing, Pointer))
					allocateArray(size)
				End If
				private native void allocateArray(Long size)
				public firas_sparse position(Long position)
				If True Then
					Return CType(MyBase.position(position), firas_sparse)
				End If
				public firas_sparse getPointer(Long i)
				If True Then
					Return (New firas_sparse(CType(Me, Pointer))).position(position + i)
				End If

																						public firas_sparse()
																						If True Then
																							MyBase(DirectCast(Nothing, Pointer))
																							allocate()
																						End If
																						private native void allocate()
'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: public native ShapeList calculateOutputShape(ShapeList inputShape, @ByRef Context block);
																						public native ShapeList calculateOutputShape(ShapeList inputShape, Context block)
			End If
	'         #endif



	' #endif

	End Class

End Namespace