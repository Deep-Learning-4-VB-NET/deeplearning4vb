Imports System
Imports System.Collections.Generic
Imports System.IO
Imports Microsoft.VisualBasic
Imports System.Linq

' Generated by the protocol buffer compiler.  DO NOT EDIT!
' source: tensor.proto

Namespace org.nd4j.ir

	Public NotInheritable Class TensorNamespace
	  Private Sub New()
	  End Sub
	  Public Shared Sub registerAllExtensions(ByVal registry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
	  End Sub

	  Public Shared Sub registerAllExtensions(ByVal registry As org.nd4j.shade.protobuf.ExtensionRegistry)
		registerAllExtensions(CType(registry, org.nd4j.shade.protobuf.ExtensionRegistryLite))
	  End Sub
	  ''' <summary>
	  ''' Protobuf enum {@code org.nd4j.ir.DataType}
	  ''' </summary>
	  Public NotInheritable Class DataType Implements org.nd4j.shade.protobuf.ProtocolMessageEnum
		''' <summary>
		''' <code>UNDEFINED = 0;</code>
		''' </summary>
		Public Shared ReadOnly UNDEFINED As New DataType("UNDEFINED", InnerEnum.UNDEFINED, 0)
		''' <summary>
		''' <pre>
		''' Basic types.
		''' </pre>
		''' 
		''' <code>FLOAT = 1;</code>
		''' </summary>
		Public Shared ReadOnly FLOAT As New DataType("FLOAT", InnerEnum.FLOAT, 1)
		''' <summary>
		''' <pre>
		''' uint8_t
		''' </pre>
		''' 
		''' <code>UINT8 = 2;</code>
		''' </summary>
		Public Shared ReadOnly UINT8 As New DataType("UINT8", InnerEnum.UINT8, 2)
		''' <summary>
		''' <pre>
		''' int8_t
		''' </pre>
		''' 
		''' <code>INT8 = 3;</code>
		''' </summary>
		Public Shared ReadOnly INT8 As New DataType("INT8", InnerEnum.INT8, 3)
		''' <summary>
		''' <pre>
		''' uint16_t
		''' </pre>
		''' 
		''' <code>UINT16 = 4;</code>
		''' </summary>
		Public Shared ReadOnly UINT16 As New DataType("UINT16", InnerEnum.UINT16, 4)
		''' <summary>
		''' <pre>
		''' int16_t
		''' </pre>
		''' 
		''' <code>INT16 = 5;</code>
		''' </summary>
		Public Shared ReadOnly INT16 As New DataType("INT16", InnerEnum.INT16, 5)
		''' <summary>
		''' <pre>
		''' int32_t
		''' </pre>
		''' 
		''' <code>INT32 = 6;</code>
		''' </summary>
		Public Shared ReadOnly INT32 As New DataType("INT32", InnerEnum.INT32, 6)
		''' <summary>
		''' <pre>
		''' int64_t
		''' </pre>
		''' 
		''' <code>INT64 = 7;</code>
		''' </summary>
		Public Shared ReadOnly INT64 As New DataType("INT64", InnerEnum.INT64, 7)
		''' <summary>
		''' <pre>
		''' string
		''' </pre>
		''' 
		''' <code>STRING = 8;</code>
		''' </summary>
		Public Shared ReadOnly [STRING] As New DataType("@STRING", InnerEnum.STRING, 8)
		''' <summary>
		''' <pre>
		''' bool
		''' </pre>
		''' 
		''' <code>BOOL = 9;</code>
		''' </summary>
		Public Shared ReadOnly BOOL As New DataType("BOOL", InnerEnum.BOOL, 9)
		''' <summary>
		''' <pre>
		''' IEEE754 half-precision floating-point format (16 bits wide).
		''' This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
		''' </pre>
		''' 
		''' <code>FLOAT16 = 10;</code>
		''' </summary>
		Public Shared ReadOnly FLOAT16 As New DataType("FLOAT16", InnerEnum.FLOAT16, 10)
		''' <summary>
		''' <code>DOUBLE = 11;</code>
		''' </summary>
		Public Shared ReadOnly [DOUBLE] As New DataType("@DOUBLE", InnerEnum.DOUBLE, 11)
		''' <summary>
		''' <code>UINT32 = 12;</code>
		''' </summary>
		Public Shared ReadOnly UINT32 As New DataType("UINT32", InnerEnum.UINT32, 12)
		''' <summary>
		''' <code>UINT64 = 13;</code>
		''' </summary>
		Public Shared ReadOnly UINT64 As New DataType("UINT64", InnerEnum.UINT64, 13)
		''' <summary>
		''' <pre>
		''' complex with float32 real and imaginary components
		''' </pre>
		''' 
		''' <code>COMPLEX64 = 14;</code>
		''' </summary>
		Public Shared ReadOnly COMPLEX64 As New DataType("COMPLEX64", InnerEnum.COMPLEX64, 14)
		''' <summary>
		''' <pre>
		''' complex with float64 real and imaginary components
		''' </pre>
		''' 
		''' <code>COMPLEX128 = 15;</code>
		''' </summary>
		Public Shared ReadOnly COMPLEX128 As New DataType("COMPLEX128", InnerEnum.COMPLEX128, 15)
		''' <summary>
		''' <pre>
		''' Non-IEEE floating-point format based on IEEE754 single-precision
		''' floating-point number truncated to 16 bits.
		''' This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
		''' </pre>
		''' 
		''' <code>BFLOAT16 = 16;</code>
		''' </summary>
		Public Shared ReadOnly BFLOAT16 As New DataType("BFLOAT16", InnerEnum.BFLOAT16, 16)
		Public Shared ReadOnly UNRECOGNIZED As New DataType("UNRECOGNIZED", InnerEnum.UNRECOGNIZED, -1)

		Private Shared ReadOnly valueList As New List(Of DataType)()

		Shared Sub New()
			valueList.Add(UNDEFINED)
			valueList.Add(FLOAT)
			valueList.Add(UINT8)
			valueList.Add(INT8)
			valueList.Add(UINT16)
			valueList.Add(INT16)
			valueList.Add(INT32)
			valueList.Add(INT64)
			valueList.Add([STRING])
			valueList.Add(BOOL)
			valueList.Add(FLOAT16)
			valueList.Add([DOUBLE])
			valueList.Add(UINT32)
			valueList.Add(UINT64)
			valueList.Add(COMPLEX64)
			valueList.Add(COMPLEX128)
			valueList.Add(BFLOAT16)
			valueList.Add(UNRECOGNIZED)
		End Sub

		Public Enum InnerEnum
			UNDEFINED
			FLOAT
			UINT8
			INT8
			UINT16
			INT16
			INT32
			INT64
			[STRING]
			BOOL
			FLOAT16
			[DOUBLE]
			UINT32
			UINT64
			COMPLEX64
			COMPLEX128
			BFLOAT16
			UNRECOGNIZED
		End Enum

		Public ReadOnly innerEnumValue As InnerEnum
		Private ReadOnly nameValue As String
		Private ReadOnly ordinalValue As Integer
		Private Shared nextOrdinal As Integer = 0

		''' <summary>
		''' <code>UNDEFINED = 0;</code>
		''' </summary>
		Public Const UNDEFINED_VALUE As Integer = 0
		''' <summary>
		''' <pre>
		''' Basic types.
		''' </pre>
		''' 
		''' <code>FLOAT = 1;</code>
		''' </summary>
		Public Const FLOAT_VALUE As Integer = 1
		''' <summary>
		''' <pre>
		''' uint8_t
		''' </pre>
		''' 
		''' <code>UINT8 = 2;</code>
		''' </summary>
		Public Const UINT8_VALUE As Integer = 2
		''' <summary>
		''' <pre>
		''' int8_t
		''' </pre>
		''' 
		''' <code>INT8 = 3;</code>
		''' </summary>
		Public Const INT8_VALUE As Integer = 3
		''' <summary>
		''' <pre>
		''' uint16_t
		''' </pre>
		''' 
		''' <code>UINT16 = 4;</code>
		''' </summary>
		Public Const UINT16_VALUE As Integer = 4
		''' <summary>
		''' <pre>
		''' int16_t
		''' </pre>
		''' 
		''' <code>INT16 = 5;</code>
		''' </summary>
		Public Const INT16_VALUE As Integer = 5
		''' <summary>
		''' <pre>
		''' int32_t
		''' </pre>
		''' 
		''' <code>INT32 = 6;</code>
		''' </summary>
		Public Const INT32_VALUE As Integer = 6
		''' <summary>
		''' <pre>
		''' int64_t
		''' </pre>
		''' 
		''' <code>INT64 = 7;</code>
		''' </summary>
		Public Const INT64_VALUE As Integer = 7
		''' <summary>
		''' <pre>
		''' string
		''' </pre>
		''' 
		''' <code>STRING = 8;</code>
		''' </summary>
		Public Const STRING_VALUE As Integer = 8
		''' <summary>
		''' <pre>
		''' bool
		''' </pre>
		''' 
		''' <code>BOOL = 9;</code>
		''' </summary>
		Public Const BOOL_VALUE As Integer = 9
		''' <summary>
		''' <pre>
		''' IEEE754 half-precision floating-point format (16 bits wide).
		''' This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
		''' </pre>
		''' 
		''' <code>FLOAT16 = 10;</code>
		''' </summary>
		Public Const FLOAT16_VALUE As Integer = 10
		''' <summary>
		''' <code>DOUBLE = 11;</code>
		''' </summary>
		Public Const DOUBLE_VALUE As Integer = 11
		''' <summary>
		''' <code>UINT32 = 12;</code>
		''' </summary>
		Public Const UINT32_VALUE As Integer = 12
		''' <summary>
		''' <code>UINT64 = 13;</code>
		''' </summary>
		Public Const UINT64_VALUE As Integer = 13
		''' <summary>
		''' <pre>
		''' complex with float32 real and imaginary components
		''' </pre>
		''' 
		''' <code>COMPLEX64 = 14;</code>
		''' </summary>
		Public Const COMPLEX64_VALUE As Integer = 14
		''' <summary>
		''' <pre>
		''' complex with float64 real and imaginary components
		''' </pre>
		''' 
		''' <code>COMPLEX128 = 15;</code>
		''' </summary>
		Public Const COMPLEX128_VALUE As Integer = 15
		''' <summary>
		''' <pre>
		''' Non-IEEE floating-point format based on IEEE754 single-precision
		''' floating-point number truncated to 16 bits.
		''' This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
		''' </pre>
		''' 
		''' <code>BFLOAT16 = 16;</code>
		''' </summary>
		Public Const BFLOAT16_VALUE As Integer = 16


		Public ReadOnly Property Number As Integer
			Get
			  If Me = UNRECOGNIZED Then
				Throw New System.ArgumentException("Can't get the number of an unknown enum value.")
			  End If
			  Return outerInstance.value
			End Get
		End Property

		''' @deprecated Use <seealso cref="forNumber(Integer)"/> instead. 
		<Obsolete("Use <seealso cref=""forNumber(Integer)""/> instead.")>
		Public Shared Function valueOf(ByVal value As Integer) As DataType
		  Return forNumber(value)
		End Function

		Public Shared Function forNumber(ByVal value As Integer) As DataType
		  Select Case value
			Case 0
				Return UNDEFINED
			Case 1
				Return FLOAT
			Case 2
				Return UINT8
			Case 3
				Return INT8
			Case 4
				Return UINT16
			Case 5
				Return INT16
			Case 6
				Return INT32
			Case 7
				Return INT64
			Case 8
				Return [STRING]
			Case 9
				Return BOOL
			Case 10
				Return FLOAT16
			Case 11
				Return [DOUBLE]
			Case 12
				Return UINT32
			Case 13
				Return UINT64
			Case 14
				Return COMPLEX64
			Case 15
				Return COMPLEX128
			Case 16
				Return BFLOAT16
			Case Else
				Return Nothing
		  End Select
		End Function

		Public Shared Function internalGetValueMap() As org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataType)
		  Return internalValueMap
		End Function
		Friend Shared ReadOnly internalValueMap As org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataType) = New EnumLiteMapAnonymousInnerClass()

		Public ReadOnly Property ValueDescriptor As org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor
			Get
			  Return Descriptor.getValues().get(ordinal())
			End Get
		End Property

'JAVA TO VB CONVERTER TODO TASK: Java to VB Converter does not convert types within enums:
'		private static class EnumLiteMapAnonymousInnerClass extends org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataType)
	'	{
	'		public DataType findValueByNumber(int number)
	'		{
	'		  Return DataType.forNumber(number);
	'		}
	'	}
		Public ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
			Get
			  Return Descriptor
			End Get
		End Property
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.Descriptor.getEnumTypes().get(0)
			End Get
		End Property

		Friend Shared ReadOnly VALUES() As DataType = values()

		Public Shared Function valueOf(ByVal desc As org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor) As DataType
		  If desc.getType() <> Descriptor Then
			Throw New System.ArgumentException("EnumValueDescriptor is not for this type.")
		  End If
		  If desc.getIndex() = -1 Then
			Return UNRECOGNIZED
		  End If
		  Return VALUES(desc.getIndex())
		End Function

		Friend ReadOnly value As Integer

		Friend Sub New(ByVal name As String, ByVal thisInnerEnumValue As InnerEnum, ByVal outerInstance As TensorNamespace, ByVal value As Integer)
			Me.outerInstance = outerInstance
		  Me.value = value

			nameValue = name
			ordinalValue = nextOrdinal
			nextOrdinal += 1
			innerEnumValue = thisInnerEnumValue
		End Sub

		' @@protoc_insertion_point(enum_scope:org.nd4j.ir.DataType)

		  Public Shared Function values() As DataType()
			  Return valueList.ToArray()
		  End Function

		  Public Function ordinal() As Integer
			  Return ordinalValue
		  End Function

		  Public Overrides Function ToString() As String
			  Return nameValue
		  End Function

		  Public Shared Operator =(ByVal one As DataType, ByVal two As DataType) As Boolean
			  Return one.innerEnumValue = two.innerEnumValue
		  End Operator

		  Public Shared Operator <>(ByVal one As DataType, ByVal two As DataType) As Boolean
			  Return one.innerEnumValue <> two.innerEnumValue
		  End Operator

		  Public Shared Function valueOf(ByVal name As String) As DataType
			  For Each enumInstance As DataType In DataType.valueList
				  If enumInstance.nameValue = name Then
					  Return enumInstance
				  End If
			  Next
			  Throw New System.ArgumentException(name)
		  End Function
	  End Class

	  Public Interface StringStringEntryProtoOrBuilder
		  Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		''' <summary>
		''' <code>string key = 1;</code>
		''' </summary>
		ReadOnly Property Key As String
		''' <summary>
		''' <code>string key = 1;</code>
		''' </summary>
		ReadOnly Property KeyBytes As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <code>string value = 2;</code>
		''' </summary>
		ReadOnly Property Value As String
		''' <summary>
		''' <code>string value = 2;</code>
		''' </summary>
		ReadOnly Property ValueBytes As org.nd4j.shade.protobuf.ByteString
	  End Interface
	  ''' <summary>
	  ''' <pre>
	  ''' StringStringEntryProto follows the pattern for cross-proto-version maps.
	  ''' See https://developers.google.com/protocol-buffers/docs/proto3#maps
	  ''' </pre>
	  ''' 
	  ''' Protobuf type {@code org.nd4j.ir.StringStringEntryProto}
	  ''' </summary>
	  Public NotInheritable Class StringStringEntryProto
		  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
		  Implements StringStringEntryProtoOrBuilder

	  Friend Const serialVersionUID As Long = 0L
		' Use StringStringEntryProto.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private StringStringEntryProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
		  MyBase.New(builder_Conflict)
		End Sub
		Friend Sub New()
		  key_ = ""
		  value_ = ""
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
		  Return New StringStringEntryProto()
		End Function

		Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			Get
			  Return Me.unknownFields
			End Get
		End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private StringStringEntryProto(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
		  Me.New()
		  If extensionRegistry Is Nothing Then
			Throw New System.NullReferenceException()
		  End If
		  Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
		  Try
			Dim done As Boolean = False
			Do While Not done
			  Dim tag As Integer = input.readTag()
			  Select Case tag
				Case 0
				  done = True
				Case 10
				  Dim s As String = input.readStringRequireUtf8()

				  key_ = s
				Case 18
				  Dim s As String = input.readStringRequireUtf8()

				  value_ = s
				Case Else
				  If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					done = True
				  End If
			  End Select
			Loop
		  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Throw e.setUnfinishedMessage(Me)
		  Catch e As java.io.IOException
			Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
		  Finally
			Me.unknownFields = unknownFields.build()
			makeExtensionsImmutable()
		  End Try
		End Sub
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor
			End Get
		End Property

		Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
		  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.StringStringEntryProto), GetType(org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder))
		End Function

		Public Const KEY_FIELD_NUMBER As Integer = 1
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object key_;
		Friend key_ As Object
		''' <summary>
		''' <code>string key = 1;</code>
		''' </summary>
		Public ReadOnly Property Key As String Implements StringStringEntryProtoOrBuilder.getKey
			Get
			  Dim ref As Object = key_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				key_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <code>string key = 1;</code>
		''' </summary>
		Public ReadOnly Property KeyBytes As org.nd4j.shade.protobuf.ByteString Implements StringStringEntryProtoOrBuilder.getKeyBytes
			Get
			  Dim ref As Object = key_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				key_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Public Const VALUE_FIELD_NUMBER As Integer = 2
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object value_;
		Friend value_ As Object
		''' <summary>
		''' <code>string value = 2;</code>
		''' </summary>
		Public ReadOnly Property Value As String Implements StringStringEntryProtoOrBuilder.getValue
			Get
			  Dim ref As Object = value_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				value_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <code>string value = 2;</code>
		''' </summary>
		Public ReadOnly Property ValueBytes As org.nd4j.shade.protobuf.ByteString Implements StringStringEntryProtoOrBuilder.getValueBytes
			Get
			  Dim ref As Object = value_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				value_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Friend memoizedIsInitialized As SByte = -1
		Public Overrides ReadOnly Property Initialized As Boolean
			Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
			  Dim isInitialized_Conflict As SByte = memoizedIsInitialized
			  If isInitialized_Conflict = 1 Then
				  Return True
			  End If
			  If isInitialized_Conflict = 0 Then
				  Return False
			  End If
    
			  memoizedIsInitialized = 1
			  Return True
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
		  If Not KeyBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 1, key_)
		  End If
		  If Not ValueBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 2, value_)
		  End If
		  unknownFields.writeTo(output)
		End Sub

		Public Overrides ReadOnly Property SerializedSize As Integer
			Get
			  Dim size As Integer = memoizedSize
			  If size <> -1 Then
				  Return size
			  End If
    
			  size = 0
			  If Not KeyBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(1, key_)
			  End If
			  If Not ValueBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(2, value_)
			  End If
			  size += unknownFields.getSerializedSize()
			  memoizedSize = size
			  Return size
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		Public Overrides Function Equals(ByVal obj As Object) As Boolean
		  If obj Is Me Then
		   Return True
		  End If
		  If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.StringStringEntryProto) Then
			Return MyBase.Equals(obj)
		  End If
		  Dim other As org.nd4j.ir.TensorNamespace.StringStringEntryProto = DirectCast(obj, org.nd4j.ir.TensorNamespace.StringStringEntryProto)

		  If Not Key.Equals(other.Key) Then
			  Return False
		  End If
		  If Not Value.Equals(other.Value) Then
			  Return False
		  End If
		  If Not unknownFields.Equals(other.unknownFields) Then
			  Return False
		  End If
		  Return True
		End Function

		Public Overrides Function GetHashCode() As Integer
		  If memoizedHashCode <> 0 Then
			Return memoizedHashCode
		  End If
		  Dim hash As Integer = 41
		  hash = (19 * hash) + Descriptor.GetHashCode()
		  hash = (37 * hash) + KEY_FIELD_NUMBER
		  hash = (53 * hash) + Key.GetHashCode()
		  hash = (37 * hash) + VALUE_FIELD_NUMBER
		  hash = (53 * hash) + Value.GetHashCode()
		  hash = (29 * hash) + unknownFields.GetHashCode()
		  memoizedHashCode = hash
		  Return hash
		End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.StringStringEntryProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function

		Public Overrides Function newBuilderForType() As Builder
			Return newBuilder()
		End Function
		Public Shared Function newBuilder() As Builder
		  Return DEFAULT_INSTANCE.toBuilder()
		End Function
		Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.StringStringEntryProto) As Builder
		  Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		End Function
		Public Overrides Function toBuilder() As Builder
		  Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		End Function

		Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Dim builder_Conflict As New Builder(parent)
		  Return builder_Conflict
		End Function
		''' <summary>
		''' <pre>
		''' StringStringEntryProto follows the pattern for cross-proto-version maps.
		''' See https://developers.google.com/protocol-buffers/docs/proto3#maps
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.StringStringEntryProto}
		''' </summary>
		Public NotInheritable Class Builder
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			Implements org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder

		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.StringStringEntryProto), GetType(org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder))
		  End Function

		  ' Construct using org.nd4j.ir.TensorNamespace.StringStringEntryProto.newBuilder()
		  Friend Sub New()
			maybeForceBuilderInitialization()
		  End Sub

		  Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			MyBase.New(parent)
			maybeForceBuilderInitialization()
		  End Sub
		  Friend Sub maybeForceBuilderInitialization()
			If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			End If
		  End Sub
		  Public Overrides Function clear() As Builder
			MyBase.clear()
			key_ = ""

			value_ = ""

			Return Me
		  End Function

		  Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_StringStringEntryProto_descriptor
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.StringStringEntryProto
			  Get
				Return org.nd4j.ir.TensorNamespace.StringStringEntryProto.DefaultInstance
			  End Get
		  End Property

		  Public Overrides Function build() As org.nd4j.ir.TensorNamespace.StringStringEntryProto
			Dim result As org.nd4j.ir.TensorNamespace.StringStringEntryProto = buildPartial()
			If Not result.Initialized Then
			  Throw newUninitializedMessageException(result)
			End If
			Return result
		  End Function

		  Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.StringStringEntryProto
			Dim result As New org.nd4j.ir.TensorNamespace.StringStringEntryProto(Me)
			result.key_ = key_
			result.value_ = value_
			onBuilt()
			Return result
		  End Function

		  Public Overrides Function clone() As Builder
			Return MyBase.clone()
		  End Function
		  Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.setField(field, value)
		  End Function
		  Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			Return MyBase.clearField(field)
		  End Function
		  Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			Return MyBase.clearOneof(oneof)
		  End Function
		  Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			Return MyBase.setRepeatedField(field, index, value)
		  End Function
		  Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.addRepeatedField(field, value)
		  End Function
		  Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			If TypeOf other Is org.nd4j.ir.TensorNamespace.StringStringEntryProto Then
			  Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.StringStringEntryProto))
			Else
			  MyBase.mergeFrom(other)
			  Return Me
			End If
		  End Function

		  Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.StringStringEntryProto) As Builder
			If other Is org.nd4j.ir.TensorNamespace.StringStringEntryProto.DefaultInstance Then
				Return Me
			End If
			If other.Key.Length > 0 Then
			  key_ = other.key_
			  onChanged()
			End If
			If other.Value.Length > 0 Then
			  value_ = other.value_
			  onChanged()
			End If
			Me.mergeUnknownFields(other.unknownFields)
			onChanged()
			Return Me
		  End Function

		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			Dim parsedMessage As org.nd4j.ir.TensorNamespace.StringStringEntryProto = Nothing
			Try
			  parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.StringStringEntryProto)
			  Throw e.unwrapIOException()
			Finally
			  If parsedMessage IsNot Nothing Then
				mergeFrom(parsedMessage)
			  End If
			End Try
			Return Me
		  End Function

		  Friend key_ As Object = ""
		  ''' <summary>
		  ''' <code>string key = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property Key As String Implements org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder.getKey
			  Get
				Dim ref As Object = key_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  key_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>string key = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property KeyBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder.getKeyBytes
			  Get
				Dim ref As Object = key_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  key_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>string key = 1;</code>
		  ''' </summary>
		  Public Function setKey(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			key_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>string key = 1;</code>
		  ''' </summary>
		  Public Function clearKey() As Builder

			key_ = DefaultInstance.Key
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>string key = 1;</code>
		  ''' </summary>
		  Public Function setKeyBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			key_ = value
			onChanged()
			Return Me
		  End Function

		  Friend value_ As Object = ""
		  ''' <summary>
		  ''' <code>string value = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property Value As String Implements org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder.getValue
			  Get
				Dim ref As Object = value_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  value_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>string value = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property ValueBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder.getValueBytes
			  Get
				Dim ref As Object = value_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  value_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>string value = 2;</code>
		  ''' </summary>
		  Public Function setValue(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			value_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>string value = 2;</code>
		  ''' </summary>
		  Public Function clearValue() As Builder

			value_ = DefaultInstance.Value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>string value = 2;</code>
		  ''' </summary>
		  Public Function setValueBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			value_ = value
			onChanged()
			Return Me
		  End Function
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.setUnknownFields(unknownFields)
		  End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.mergeUnknownFields(unknownFields)
		  End Function


		  ' @@protoc_insertion_point(builder_scope:org.nd4j.ir.StringStringEntryProto)
		End Class

		' @@protoc_insertion_point(class_scope:org.nd4j.ir.StringStringEntryProto)
		Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		Shared Sub New()
		  DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.StringStringEntryProto()
		End Sub

		Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.StringStringEntryProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of StringStringEntryProto) = New AbstractParserAnonymousInnerClass()

		Private Class AbstractParserAnonymousInnerClass
			Inherits org.nd4j.shade.protobuf.AbstractParser(Of StringStringEntryProto)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public StringStringEntryProto parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As StringStringEntryProto
			  Return New StringStringEntryProto(input, extensionRegistry)
			End Function
		End Class

		Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of StringStringEntryProto)
		  Return PARSER_Conflict
		End Function

		Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of StringStringEntryProto)
			Get
			  Return PARSER_Conflict
			End Get
		End Property

		Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.StringStringEntryProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

	  End Class

	  Public Interface TypeProtoOrBuilder
		  Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		Function hasTensorType() As Boolean
		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		ReadOnly Property TensorType As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		ReadOnly Property TensorTypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder

		ReadOnly Property ValueCase As org.nd4j.ir.TensorNamespace.TypeProto.ValueCase
	  End Interface
	  ''' <summary>
	  ''' <pre>
	  ''' Define the types.
	  ''' </pre>
	  ''' 
	  ''' Protobuf type {@code org.nd4j.ir.TypeProto}
	  ''' </summary>
	  Public NotInheritable Class TypeProto
		  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
		  Implements TypeProtoOrBuilder

	  Friend Const serialVersionUID As Long = 0L
		' Use TypeProto.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private TypeProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
		  MyBase.New(builder_Conflict)
		End Sub
		Friend Sub New()
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
		  Return New TypeProto()
		End Function

		Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			Get
			  Return Me.unknownFields
			End Get
		End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private TypeProto(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
		  Me.New()
		  If extensionRegistry Is Nothing Then
			Throw New System.NullReferenceException()
		  End If
		  Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
		  Try
			Dim done As Boolean = False
			Do While Not done
			  Dim tag As Integer = input.readTag()
			  Select Case tag
				Case 0
				  done = True
				Case 10
				  Dim subBuilder As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder = Nothing
				  If valueCase_ = 1 Then
					subBuilder = DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor).toBuilder()
				  End If
				  value_ = input.readMessage(org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.parser(), extensionRegistry)
				  If subBuilder IsNot Nothing Then
					subBuilder.mergeFrom(DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor))
					value_ = subBuilder.buildPartial()
				  End If
				  valueCase_ = 1
				Case Else
				  If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					done = True
				  End If
			  End Select
			Loop
		  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Throw e.setUnfinishedMessage(Me)
		  Catch e As java.io.IOException
			Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
		  Finally
			Me.unknownFields = unknownFields.build()
			makeExtensionsImmutable()
		  End Try
		End Sub
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_descriptor
			End Get
		End Property

		Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
		  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TypeProto), GetType(org.nd4j.ir.TensorNamespace.TypeProto.Builder))
		End Function

		Public Interface TensorDescriptorOrBuilder
			Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST NOT have the value of UNDEFINED
		  ''' This field MUST be present for this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
		  ''' </summary>
		  ReadOnly Property ElemTypeValue As Integer
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST NOT have the value of UNDEFINED
		  ''' This field MUST be present for this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
		  ''' </summary>
		  ReadOnly Property ElemType As org.nd4j.ir.TensorNamespace.DataType

		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  Function hasShape() As Boolean
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  ReadOnly Property Shape As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  ReadOnly Property ShapeOrBuilder As org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder
		End Interface
		''' <summary>
		''' Protobuf type {@code org.nd4j.ir.TypeProto.TensorDescriptor}
		''' </summary>
		Public NotInheritable Class TensorDescriptor
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
			Implements TensorDescriptorOrBuilder

		Friend Const serialVersionUID As Long = 0L
		  ' Use TensorDescriptor.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private TensorDescriptor(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
			MyBase.New(builder_Conflict)
		  End Sub
		  Friend Sub New()
			elemType_ = 0
		  End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		  Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
			Return New TensorDescriptor()
		  End Function

		  Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			  Get
				Return Me.unknownFields
			  End Get
		  End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private TensorDescriptor(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
			Me.New()
			If extensionRegistry Is Nothing Then
			  Throw New System.NullReferenceException()
			End If
			Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
			Try
			  Dim done As Boolean = False
			  Do While Not done
				Dim tag As Integer = input.readTag()
				Select Case tag
				  Case 0
					done = True
				  Case 8
					Dim rawValue As Integer = input.readEnum()

					elemType_ = rawValue
				  Case 18
					Dim subBuilder As org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder = Nothing
					If shape_ IsNot Nothing Then
					  subBuilder = shape_.toBuilder()
					End If
					shape_ = input.readMessage(org.nd4j.ir.TensorNamespace.TensorShapeProto.parser(), extensionRegistry)
					If subBuilder IsNot Nothing Then
					  subBuilder.mergeFrom(shape_)
					  shape_ = subBuilder.buildPartial()
					End If

				  Case Else
					If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					  done = True
					End If
				End Select
			  Loop
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Throw e.setUnfinishedMessage(Me)
			Catch e As java.io.IOException
			  Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
			Finally
			  Me.unknownFields = unknownFields.build()
			  makeExtensionsImmutable()
			End Try
		  End Sub
		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor), GetType(org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder))
		  End Function

		  Public Const ELEM_TYPE_FIELD_NUMBER As Integer = 1
		  Friend elemType_ As Integer
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST NOT have the value of UNDEFINED
		  ''' This field MUST be present for this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property ElemTypeValue As Integer Implements TensorDescriptorOrBuilder.getElemTypeValue
			  Get
				Return elemType_
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST NOT have the value of UNDEFINED
		  ''' This field MUST be present for this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property ElemType As org.nd4j.ir.TensorNamespace.DataType Implements TensorDescriptorOrBuilder.getElemType
			  Get
	'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
	'ORIGINAL LINE: @SuppressWarnings("deprecation") org.nd4j.ir.TensorNamespace.DataType result = org.nd4j.ir.TensorNamespace.DataType.valueOf(elemType_);
				Dim result As org.nd4j.ir.TensorNamespace.DataType = org.nd4j.ir.TensorNamespace.DataType.valueOf(elemType_)
				Return If(result = Nothing, org.nd4j.ir.TensorNamespace.DataType.UNRECOGNIZED, result)
			  End Get
		  End Property

		  Public Const SHAPE_FIELD_NUMBER As Integer = 2
		  Friend shape_ As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  Public Function hasShape() As Boolean Implements TensorDescriptorOrBuilder.hasShape
			Return shape_ IsNot Nothing
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property Shape As org.nd4j.ir.TensorNamespace.TensorShapeProto Implements TensorDescriptorOrBuilder.getShape
			  Get
				Return If(shape_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorShapeProto.DefaultInstance, shape_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property ShapeOrBuilder As org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder Implements TensorDescriptorOrBuilder.getShapeOrBuilder
			  Get
				Return Shape
			  End Get
		  End Property

		  Friend memoizedIsInitialized As SByte = -1
		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
				Dim isInitialized_Conflict As SByte = memoizedIsInitialized
				If isInitialized_Conflict = 1 Then
					Return True
				End If
				If isInitialized_Conflict = 0 Then
					Return False
				End If
    
				memoizedIsInitialized = 1
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		  Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
			If elemType_ <> org.nd4j.ir.TensorNamespace.DataType.UNDEFINED.getNumber() Then
			  output.writeEnum(1, elemType_)
			End If
			If shape_ IsNot Nothing Then
			  output.writeMessage(2, Shape)
			End If
			unknownFields.writeTo(output)
		  End Sub

		  Public Overrides ReadOnly Property SerializedSize As Integer
			  Get
				Dim size As Integer = memoizedSize
				If size <> -1 Then
					Return size
				End If
    
				size = 0
				If elemType_ <> org.nd4j.ir.TensorNamespace.DataType.UNDEFINED.getNumber() Then
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeEnumSize(1, elemType_)
				End If
				If shape_ IsNot Nothing Then
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(2, Shape)
				End If
				size += unknownFields.getSerializedSize()
				memoizedSize = size
				Return size
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		  Public Overrides Function Equals(ByVal obj As Object) As Boolean
			If obj Is Me Then
			 Return True
			End If
			If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor) Then
			  Return MyBase.Equals(obj)
			End If
			Dim other As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor = DirectCast(obj, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)

			If elemType_ <> other.elemType_ Then
				Return False
			End If
			If hasShape() <> other.hasShape() Then
				Return False
			End If
			If hasShape() Then
			  If Not Shape.Equals(other.Shape) Then
				  Return False
			  End If
			End If
			If Not unknownFields.Equals(other.unknownFields) Then
				Return False
			End If
			Return True
		  End Function

		  Public Overrides Function GetHashCode() As Integer
			If memoizedHashCode <> 0 Then
			  Return memoizedHashCode
			End If
			Dim hash As Integer = 41
			hash = (19 * hash) + Descriptor.GetHashCode()
			hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER
			hash = (53 * hash) + elemType_
			If hasShape() Then
			  hash = (37 * hash) + SHAPE_FIELD_NUMBER
			  hash = (53 * hash) + Shape.GetHashCode()
			End If
			hash = (29 * hash) + unknownFields.GetHashCode()
			memoizedHashCode = hash
			Return hash
		  End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function

		  Public Overrides Function newBuilderForType() As Builder
			  Return newBuilder()
		  End Function
		  Public Shared Function newBuilder() As Builder
			Return DEFAULT_INSTANCE.toBuilder()
		  End Function
		  Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor) As Builder
			Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		  End Function
		  Public Overrides Function toBuilder() As Builder
			Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		  End Function

		  Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
			Dim builder_Conflict As New Builder(parent)
			Return builder_Conflict
		  End Function
		  ''' <summary>
		  ''' Protobuf type {@code org.nd4j.ir.TypeProto.TensorDescriptor}
		  ''' </summary>
		  Public NotInheritable Class Builder
			  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			  Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder

			Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor
				End Get
			End Property

			Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor), GetType(org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder))
			End Function

			' Construct using org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.newBuilder()
			Friend Sub New()
			  maybeForceBuilderInitialization()
			End Sub

			Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			  MyBase.New(parent)
			  maybeForceBuilderInitialization()
			End Sub
			Friend Sub maybeForceBuilderInitialization()
			  If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			  End If
			End Sub
			Public Overrides Function clear() As Builder
			  MyBase.clear()
			  elemType_ = 0

			  If shapeBuilder_ Is Nothing Then
				shape_ = Nothing
			  Else
				shape_ = Nothing
				shapeBuilder_ = Nothing
			  End If
			  Return Me
			End Function

			Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor
				End Get
			End Property

			Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
				End Get
			End Property

			Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			  Dim result As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor = buildPartial()
			  If Not result.Initialized Then
				Throw newUninitializedMessageException(result)
			  End If
			  Return result
			End Function

			Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			  Dim result As New org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor(Me)
			  result.elemType_ = elemType_
			  If shapeBuilder_ Is Nothing Then
				result.shape_ = shape_
			  Else
				result.shape_ = shapeBuilder_.build()
			  End If
			  onBuilt()
			  Return result
			End Function

			Public Overrides Function clone() As Builder
			  Return MyBase.clone()
			End Function
			Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.setField(field, value)
			End Function
			Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			  Return MyBase.clearField(field)
			End Function
			Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			  Return MyBase.clearOneof(oneof)
			End Function
			Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			  Return MyBase.setRepeatedField(field, index, value)
			End Function
			Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.addRepeatedField(field, value)
			End Function
			Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			  If TypeOf other Is org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor Then
				Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor))
			  Else
				MyBase.mergeFrom(other)
				Return Me
			  End If
			End Function

			Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor) As Builder
			  If other Is org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance Then
				  Return Me
			  End If
			  If other.elemType_ <> 0 Then
				ElemTypeValue = other.ElemTypeValue
			  End If
			  If other.hasShape() Then
				mergeShape(other.Shape)
			  End If
			  Me.mergeUnknownFields(other.unknownFields)
			  onChanged()
			  Return Me
			End Function

			Public Overrides ReadOnly Property Initialized As Boolean
				Get
				  Return True
				End Get
			End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
			Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			  Dim parsedMessage As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor = Nothing
			  Try
				parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
				parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)
				Throw e.unwrapIOException()
			  Finally
				If parsedMessage IsNot Nothing Then
				  mergeFrom(parsedMessage)
				End If
			  End Try
			  Return Me
			End Function

			Friend elemType_ As Integer = 0
			''' <summary>
			''' <pre>
			''' This field MUST NOT have the value of UNDEFINED
			''' This field MUST be present for this version of the IR.
			''' </pre>
			''' 
			''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
			''' </summary>
			Public ReadOnly Property ElemTypeValue As Integer Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder.getElemTypeValue
				Get
				  Return elemType_
				End Get
			End Property
			''' <summary>
			''' <pre>
			''' This field MUST NOT have the value of UNDEFINED
			''' This field MUST be present for this version of the IR.
			''' </pre>
			''' 
			''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
			''' </summary>
			Public Function setElemTypeValue(ByVal value As Integer) As Builder
			  elemType_ = value
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <pre>
			''' This field MUST NOT have the value of UNDEFINED
			''' This field MUST be present for this version of the IR.
			''' </pre>
			''' 
			''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
			''' </summary>
			Public ReadOnly Property ElemType As org.nd4j.ir.TensorNamespace.DataType Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder.getElemType
				Get
	'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
	'ORIGINAL LINE: @SuppressWarnings("deprecation") org.nd4j.ir.TensorNamespace.DataType result = org.nd4j.ir.TensorNamespace.DataType.valueOf(elemType_);
				  Dim result As org.nd4j.ir.TensorNamespace.DataType = org.nd4j.ir.TensorNamespace.DataType.valueOf(elemType_)
				  Return If(result = Nothing, org.nd4j.ir.TensorNamespace.DataType.UNRECOGNIZED, result)
				End Get
			End Property
			''' <summary>
			''' <pre>
			''' This field MUST NOT have the value of UNDEFINED
			''' This field MUST be present for this version of the IR.
			''' </pre>
			''' 
			''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
			''' </summary>
			Public Function setElemType(ByVal value As org.nd4j.ir.TensorNamespace.DataType) As Builder
			  If value = Nothing Then
				Throw New System.NullReferenceException()
			  End If

			  elemType_ = value.getNumber()
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <pre>
			''' This field MUST NOT have the value of UNDEFINED
			''' This field MUST be present for this version of the IR.
			''' </pre>
			''' 
			''' <code>.org.nd4j.ir.DataType elem_type = 1;</code>
			''' </summary>
			Public Function clearElemType() As Builder

			  elemType_ = 0
			  onChanged()
			  Return Me
			End Function

			Friend shape_ As org.nd4j.ir.TensorNamespace.TensorShapeProto
			Friend shapeBuilder_ As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto, org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder)
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public Function hasShape() As Boolean Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder.hasShape
			  Return shapeBuilder_ IsNot Nothing OrElse shape_ IsNot Nothing
			End Function
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public ReadOnly Property Shape As org.nd4j.ir.TensorNamespace.TensorShapeProto Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder.getShape
				Get
				  If shapeBuilder_ Is Nothing Then
					Return If(shape_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorShapeProto.DefaultInstance, shape_)
				  Else
					Return shapeBuilder_.getMessage()
				  End If
				End Get
			End Property
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public Function setShape(ByVal value As org.nd4j.ir.TensorNamespace.TensorShapeProto) As Builder
			  If shapeBuilder_ Is Nothing Then
				If value Is Nothing Then
				  Throw New System.NullReferenceException()
				End If
				shape_ = value
				onChanged()
			  Else
				shapeBuilder_.setMessage(value)
			  End If

			  Return Me
			End Function
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public Function setShape(ByVal builderForValue As org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder) As Builder
			  If shapeBuilder_ Is Nothing Then
				shape_ = builderForValue.build()
				onChanged()
			  Else
				shapeBuilder_.setMessage(builderForValue.build())
			  End If

			  Return Me
			End Function
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public Function mergeShape(ByVal value As org.nd4j.ir.TensorNamespace.TensorShapeProto) As Builder
			  If shapeBuilder_ Is Nothing Then
				If shape_ IsNot Nothing Then
				  shape_ = org.nd4j.ir.TensorNamespace.TensorShapeProto.newBuilder(shape_).mergeFrom(value).buildPartial()
				Else
				  shape_ = value
				End If
				onChanged()
			  Else
				shapeBuilder_.mergeFrom(value)
			  End If

			  Return Me
			End Function
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public Function clearShape() As Builder
			  If shapeBuilder_ Is Nothing Then
				shape_ = Nothing
				onChanged()
			  Else
				shape_ = Nothing
				shapeBuilder_ = Nothing
			  End If

			  Return Me
			End Function
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public ReadOnly Property ShapeBuilder As org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder
				Get
    
				  onChanged()
				  Return getShapeFieldBuilder().getBuilder()
				End Get
			End Property
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Public ReadOnly Property ShapeOrBuilder As org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder Implements org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder.getShapeOrBuilder
				Get
				  If shapeBuilder_ IsNot Nothing Then
					Return shapeBuilder_.getMessageOrBuilder()
				  Else
					Return If(shape_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorShapeProto.DefaultInstance, shape_)
				  End If
				End Get
			End Property
			''' <summary>
			''' <code>.org.nd4j.ir.TensorShapeProto shape = 2;</code>
			''' </summary>
			Friend ReadOnly Property ShapeFieldBuilder As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto, org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder)
				Get
				  If shapeBuilder_ Is Nothing Then
					shapeBuilder_ = New org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto, org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder)(getShape(), getParentForChildren(), isClean())
					shape_ = Nothing
				  End If
				  Return shapeBuilder_
				End Get
			End Property
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.setUnknownFields(unknownFields)
			End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.mergeUnknownFields(unknownFields)
			End Function


			' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TypeProto.TensorDescriptor)
		  End Class

		  ' @@protoc_insertion_point(class_scope:org.nd4j.ir.TypeProto.TensorDescriptor)
		  Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
		  Shared Sub New()
			DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor()
		  End Sub

		  Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		  Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of TensorDescriptor) = New AbstractParserAnonymousInnerClass()

		  Private Class AbstractParserAnonymousInnerClass
			  Inherits org.nd4j.shade.protobuf.AbstractParser(Of TensorDescriptor)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public TensorDescriptor parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As TensorDescriptor
				Return New TensorDescriptor(input, extensionRegistry)
			  End Function
		  End Class

		  Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of TensorDescriptor)
			Return PARSER_Conflict
		  End Function

		  Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of TensorDescriptor)
			  Get
				Return PARSER_Conflict
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

		End Class

		Friend valueCase_ As Integer = 0
		Friend value_ As Object
		Public NotInheritable Class ValueCase Implements org.nd4j.shade.protobuf.Internal.EnumLite
		  Public Shared ReadOnly TENSOR_TYPE As New ValueCase("TENSOR_TYPE", InnerEnum.TENSOR_TYPE, 1)
		  Public Shared ReadOnly VALUE_NOT_SET As New ValueCase("VALUE_NOT_SET", InnerEnum.VALUE_NOT_SET, 0)

		  Private Shared ReadOnly valueList As New List(Of ValueCase)()

		  Shared Sub New()
			  valueList.Add(TENSOR_TYPE)
			  valueList.Add(VALUE_NOT_SET)
		  End Sub

		  Public Enum InnerEnum
			  TENSOR_TYPE
			  VALUE_NOT_SET
		  End Enum

		  Public ReadOnly innerEnumValue As InnerEnum
		  Private ReadOnly nameValue As String
		  Private ReadOnly ordinalValue As Integer
		  Private Shared nextOrdinal As Integer = 0
		  Friend ReadOnly value As Integer
		  Friend Sub New(ByVal name As String, ByVal thisInnerEnumValue As InnerEnum, ByVal outerInstance As TensorNamespace.TypeProto, ByVal value As Integer)
			  Me.outerInstance = outerInstance
			Me.value = value

			  nameValue = name
			  ordinalValue = nextOrdinal
			  nextOrdinal += 1
			  innerEnumValue = thisInnerEnumValue
		  End Sub
		  ''' @deprecated Use <seealso cref="forNumber(Integer)"/> instead. 
		  <Obsolete("Use <seealso cref=""forNumber(Integer)""/> instead.")>
		  Public Shared Function valueOf(ByVal value As Integer) As ValueCase
			Return forNumber(value)
		  End Function

		  Public Shared Function forNumber(ByVal value As Integer) As ValueCase
			Select Case value
			  Case 1
				  Return TENSOR_TYPE
			  Case 0
				  Return VALUE_NOT_SET
			  Case Else
				  Return Nothing
			End Select
		  End Function
		  Public ReadOnly Property Number As Integer
			  Get
				Return Me.value
			  End Get
		  End Property

			Public Shared Function values() As ValueCase()
				Return valueList.ToArray()
			End Function

			Public Function ordinal() As Integer
				Return ordinalValue
			End Function

			Public Overrides Function ToString() As String
				Return nameValue
			End Function

			Public Shared Operator =(ByVal one As ValueCase, ByVal two As ValueCase) As Boolean
				Return one.innerEnumValue = two.innerEnumValue
			End Operator

			Public Shared Operator <>(ByVal one As ValueCase, ByVal two As ValueCase) As Boolean
				Return one.innerEnumValue <> two.innerEnumValue
			End Operator

			Public Shared Function valueOf(ByVal name As String) As ValueCase
				For Each enumInstance As ValueCase In ValueCase.valueList
					If enumInstance.nameValue = name Then
						Return enumInstance
					End If
				Next
				Throw New System.ArgumentException(name)
			End Function
		End Class

		Public ReadOnly Property ValueCase As ValueCase
			Get
			  Return ValueCase.forNumber(valueCase_)
			End Get
		End Property

		Public Const TENSOR_TYPE_FIELD_NUMBER As Integer = 1
		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		Public Function hasTensorType() As Boolean Implements TypeProtoOrBuilder.hasTensorType
		  Return valueCase_ = 1
		End Function
		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		Public ReadOnly Property TensorType As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor Implements TypeProtoOrBuilder.getTensorType
			Get
			  If valueCase_ = 1 Then
				 Return DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)
			  End If
			  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' The type of a tensor.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		''' </summary>
		Public ReadOnly Property TensorTypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder Implements TypeProtoOrBuilder.getTensorTypeOrBuilder
			Get
			  If valueCase_ = 1 Then
				 Return DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)
			  End If
			  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
			End Get
		End Property

		Friend memoizedIsInitialized As SByte = -1
		Public Overrides ReadOnly Property Initialized As Boolean
			Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
			  Dim isInitialized_Conflict As SByte = memoizedIsInitialized
			  If isInitialized_Conflict = 1 Then
				  Return True
			  End If
			  If isInitialized_Conflict = 0 Then
				  Return False
			  End If
    
			  memoizedIsInitialized = 1
			  Return True
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
		  If valueCase_ = 1 Then
			output.writeMessage(1, DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor))
		  End If
		  unknownFields.writeTo(output)
		End Sub

		Public Overrides ReadOnly Property SerializedSize As Integer
			Get
			  Dim size As Integer = memoizedSize
			  If size <> -1 Then
				  Return size
			  End If
    
			  size = 0
			  If valueCase_ = 1 Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(1, DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor))
			  End If
			  size += unknownFields.getSerializedSize()
			  memoizedSize = size
			  Return size
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		Public Overrides Function Equals(ByVal obj As Object) As Boolean
		  If obj Is Me Then
		   Return True
		  End If
		  If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TypeProto) Then
			Return MyBase.Equals(obj)
		  End If
		  Dim other As org.nd4j.ir.TensorNamespace.TypeProto = DirectCast(obj, org.nd4j.ir.TensorNamespace.TypeProto)

		  If Not ValueCase.equals(other.ValueCase) Then
			  Return False
		  End If
		  Select Case valueCase_
			Case 1
			  If Not TensorType.Equals(other.TensorType) Then
				  Return False
			  End If
			Case Else
		  End Select
		  If Not unknownFields.Equals(other.unknownFields) Then
			  Return False
		  End If
		  Return True
		End Function

		Public Overrides Function GetHashCode() As Integer
		  If memoizedHashCode <> 0 Then
			Return memoizedHashCode
		  End If
		  Dim hash As Integer = 41
		  hash = (19 * hash) + Descriptor.GetHashCode()
		  Select Case valueCase_
			Case 1
			  hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER
			  hash = (53 * hash) + TensorType.GetHashCode()
			Case Else
		  End Select
		  hash = (29 * hash) + unknownFields.GetHashCode()
		  memoizedHashCode = hash
		  Return hash
		End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TypeProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TypeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function

		Public Overrides Function newBuilderForType() As Builder
			Return newBuilder()
		End Function
		Public Shared Function newBuilder() As Builder
		  Return DEFAULT_INSTANCE.toBuilder()
		End Function
		Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TypeProto) As Builder
		  Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		End Function
		Public Overrides Function toBuilder() As Builder
		  Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		End Function

		Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Dim builder_Conflict As New Builder(parent)
		  Return builder_Conflict
		End Function
		''' <summary>
		''' <pre>
		''' Define the types.
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.TypeProto}
		''' </summary>
		Public NotInheritable Class Builder
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			Implements org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder

		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TypeProto), GetType(org.nd4j.ir.TensorNamespace.TypeProto.Builder))
		  End Function

		  ' Construct using org.nd4j.ir.TensorNamespace.TypeProto.newBuilder()
		  Friend Sub New()
			maybeForceBuilderInitialization()
		  End Sub

		  Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			MyBase.New(parent)
			maybeForceBuilderInitialization()
		  End Sub
		  Friend Sub maybeForceBuilderInitialization()
			If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			End If
		  End Sub
		  Public Overrides Function clear() As Builder
			MyBase.clear()
			valueCase_ = 0
			value_ = Nothing
			Return Me
		  End Function

		  Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TypeProto_descriptor
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TypeProto
			  Get
				Return org.nd4j.ir.TensorNamespace.TypeProto.DefaultInstance
			  End Get
		  End Property

		  Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TypeProto
			Dim result As org.nd4j.ir.TensorNamespace.TypeProto = buildPartial()
			If Not result.Initialized Then
			  Throw newUninitializedMessageException(result)
			End If
			Return result
		  End Function

		  Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TypeProto
			Dim result As New org.nd4j.ir.TensorNamespace.TypeProto(Me)
			If valueCase_ = 1 Then
			  If tensorTypeBuilder_ Is Nothing Then
				result.value_ = value_
			  Else
				result.value_ = tensorTypeBuilder_.build()
			  End If
			End If
			result.valueCase_ = valueCase_
			onBuilt()
			Return result
		  End Function

		  Public Overrides Function clone() As Builder
			Return MyBase.clone()
		  End Function
		  Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.setField(field, value)
		  End Function
		  Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			Return MyBase.clearField(field)
		  End Function
		  Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			Return MyBase.clearOneof(oneof)
		  End Function
		  Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			Return MyBase.setRepeatedField(field, index, value)
		  End Function
		  Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.addRepeatedField(field, value)
		  End Function
		  Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			If TypeOf other Is org.nd4j.ir.TensorNamespace.TypeProto Then
			  Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TypeProto))
			Else
			  MyBase.mergeFrom(other)
			  Return Me
			End If
		  End Function

		  Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TypeProto) As Builder
			If other Is org.nd4j.ir.TensorNamespace.TypeProto.DefaultInstance Then
				Return Me
			End If
			Select Case other.ValueCase
			  Case TENSOR_TYPE
				mergeTensorType(other.TensorType)
			  Case VALUE_NOT_SET
			End Select
			Me.mergeUnknownFields(other.unknownFields)
			onChanged()
			Return Me
		  End Function

		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			Dim parsedMessage As org.nd4j.ir.TensorNamespace.TypeProto = Nothing
			Try
			  parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TypeProto)
			  Throw e.unwrapIOException()
			Finally
			  If parsedMessage IsNot Nothing Then
				mergeFrom(parsedMessage)
			  End If
			End Try
			Return Me
		  End Function
		  Friend valueCase_ As Integer = 0
		  Friend value_ As Object
		  Public ReadOnly Property ValueCase As ValueCase
			  Get
				Return ValueCase.forNumber(valueCase_)
			  End Get
		  End Property

		  Public Function clearValue() As Builder
			valueCase_ = 0
			value_ = Nothing
			onChanged()
			Return Me
		  End Function


		  Friend tensorTypeBuilder_ As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder)
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public Function hasTensorType() As Boolean Implements org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder.hasTensorType
			Return valueCase_ = 1
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property TensorType As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor Implements org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder.getTensorType
			  Get
				If tensorTypeBuilder_ Is Nothing Then
				  If valueCase_ = 1 Then
					Return DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)
				  End If
				  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
				Else
				  If valueCase_ = 1 Then
					Return tensorTypeBuilder_.getMessage()
				  End If
				  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public Function setTensorType(ByVal value As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor) As Builder
			If tensorTypeBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  value_ = value
			  onChanged()
			Else
			  tensorTypeBuilder_.setMessage(value)
			End If
			valueCase_ = 1
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public Function setTensorType(ByVal builderForValue As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder) As Builder
			If tensorTypeBuilder_ Is Nothing Then
			  value_ = builderForValue.build()
			  onChanged()
			Else
			  tensorTypeBuilder_.setMessage(builderForValue.build())
			End If
			valueCase_ = 1
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public Function mergeTensorType(ByVal value As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor) As Builder
			If tensorTypeBuilder_ Is Nothing Then
			  If valueCase_ = 1 AndAlso value_ IsNot org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance Then
				value_ = org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.newBuilder(DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)).mergeFrom(value).buildPartial()
			  Else
				value_ = value
			  End If
			  onChanged()
			Else
			  If valueCase_ = 1 Then
				tensorTypeBuilder_.mergeFrom(value)
			  End If
			  tensorTypeBuilder_.setMessage(value)
			End If
			valueCase_ = 1
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public Function clearTensorType() As Builder
			If tensorTypeBuilder_ Is Nothing Then
			  If valueCase_ = 1 Then
				valueCase_ = 0
				value_ = Nothing
				onChanged()
			  End If
			Else
			  If valueCase_ = 1 Then
				valueCase_ = 0
				value_ = Nothing
			  End If
			  tensorTypeBuilder_.clear()
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property TensorTypeBuilder As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder
			  Get
				Return getTensorTypeFieldBuilder().getBuilder()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property TensorTypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder Implements org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder.getTensorTypeOrBuilder
			  Get
				If (valueCase_ = 1) AndAlso (tensorTypeBuilder_ IsNot Nothing) Then
				  Return tensorTypeBuilder_.getMessageOrBuilder()
				Else
				  If valueCase_ = 1 Then
					Return DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor)
				  End If
				  Return org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The type of a tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto.TensorDescriptor tensor_type = 1;</code>
		  ''' </summary>
		  Friend ReadOnly Property TensorTypeFieldBuilder As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder)
			  Get
				If tensorTypeBuilder_ Is Nothing Then
				  If Not (valueCase_ = 1) Then
					value_ = org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.DefaultInstance
				  End If
				  tensorTypeBuilder_ = New org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor.Builder, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptorOrBuilder)(DirectCast(value_, org.nd4j.ir.TensorNamespace.TypeProto.TensorDescriptor), getParentForChildren(), isClean())
				  value_ = Nothing
				End If
				valueCase_ = 1
				onChanged()
				Return tensorTypeBuilder_
			  End Get
		  End Property
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.setUnknownFields(unknownFields)
		  End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.mergeUnknownFields(unknownFields)
		  End Function


		  ' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TypeProto)
		End Class

		' @@protoc_insertion_point(class_scope:org.nd4j.ir.TypeProto)
		Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TypeProto
		Shared Sub New()
		  DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TypeProto()
		End Sub

		Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TypeProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of TypeProto) = New AbstractParserAnonymousInnerClass()

		Private Class AbstractParserAnonymousInnerClass
			Inherits org.nd4j.shade.protobuf.AbstractParser(Of TypeProto)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public TypeProto parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As TypeProto
			  Return New TypeProto(input, extensionRegistry)
			End Function
		End Class

		Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of TypeProto)
		  Return PARSER_Conflict
		End Function

		Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of TypeProto)
			Get
			  Return PARSER_Conflict
			End Get
		End Property

		Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TypeProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

	  End Class

	  Public Interface TensorShapeProtoOrBuilder
		  Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		ReadOnly Property DimList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Function getDim(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		ReadOnly Property DimCount As Integer
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: java.util.List<? extends org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder> getDimOrBuilderList();
		ReadOnly Property DimOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder)
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Function getDimOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder
	  End Interface
	  ''' <summary>
	  ''' <pre>
	  ''' Defines a tensor shape. A dimension can be either an integer value
	  ''' or a symbolic variable. A symbolic variable represents an unknown
	  ''' dimension.
	  ''' </pre>
	  ''' 
	  ''' Protobuf type {@code org.nd4j.ir.TensorShapeProto}
	  ''' </summary>
	  Public NotInheritable Class TensorShapeProto
		  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
		  Implements TensorShapeProtoOrBuilder

	  Friend Const serialVersionUID As Long = 0L
		' Use TensorShapeProto.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private TensorShapeProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
		  MyBase.New(builder_Conflict)
		End Sub
		Friend Sub New()
		  dim_ = java.util.Collections.emptyList()
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
		  Return New TensorShapeProto()
		End Function

		Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			Get
			  Return Me.unknownFields
			End Get
		End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private TensorShapeProto(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
		  Me.New()
		  If extensionRegistry Is Nothing Then
			Throw New System.NullReferenceException()
		  End If
		  Dim mutable_bitField0_ As Integer = 0
		  Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
		  Try
			Dim done As Boolean = False
			Do While Not done
			  Dim tag As Integer = input.readTag()
			  Select Case tag
				Case 0
				  done = True
				Case 10
				  If Not ((mutable_bitField0_ And &H1) <> 0) Then
					dim_ = New List(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)()
					mutable_bitField0_ = mutable_bitField0_ Or &H1
				  End If
				  dim_.Add(input.readMessage(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.parser(), extensionRegistry))
				Case Else
				  If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					done = True
				  End If
			  End Select
			Loop
		  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Throw e.setUnfinishedMessage(Me)
		  Catch e As java.io.IOException
			Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
		  Finally
			If ((mutable_bitField0_ And &H1) <> 0) Then
			  dim_ = java.util.Collections.unmodifiableList(dim_)
			End If
			Me.unknownFields = unknownFields.build()
			makeExtensionsImmutable()
		  End Try
		End Sub
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_descriptor
			End Get
		End Property

		Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
		  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto), GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder))
		End Function

		Public Interface DimensionOrBuilder
			Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		  ''' <summary>
		  ''' <code>int64 dim_value = 1;</code>
		  ''' </summary>
		  ReadOnly Property DimValue As Long

		  ''' <summary>
		  ''' <pre>
		  ''' namespace Shape
		  ''' </pre>
		  ''' 
		  ''' <code>string dim_param = 2;</code>
		  ''' </summary>
		  ReadOnly Property DimParam As String
		  ''' <summary>
		  ''' <pre>
		  ''' namespace Shape
		  ''' </pre>
		  ''' 
		  ''' <code>string dim_param = 2;</code>
		  ''' </summary>
		  ReadOnly Property DimParamBytes As org.nd4j.shade.protobuf.ByteString

		  ReadOnly Property ValueCase As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.ValueCase
		End Interface
		''' <summary>
		''' Protobuf type {@code org.nd4j.ir.TensorShapeProto.Dimension}
		''' </summary>
		Public NotInheritable Class Dimension
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
			Implements DimensionOrBuilder

		Friend Const serialVersionUID As Long = 0L
		  ' Use Dimension.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private Dimension(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
			MyBase.New(builder_Conflict)
		  End Sub
		  Friend Sub New()
		  End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		  Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
			Return New Dimension()
		  End Function

		  Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			  Get
				Return Me.unknownFields
			  End Get
		  End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private Dimension(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
			Me.New()
			If extensionRegistry Is Nothing Then
			  Throw New System.NullReferenceException()
			End If
			Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
			Try
			  Dim done As Boolean = False
			  Do While Not done
				Dim tag As Integer = input.readTag()
				Select Case tag
				  Case 0
					done = True
				  Case 8
					valueCase_ = 1
					value_ = input.readInt64()
				  Case 18
					Dim s As String = input.readStringRequireUtf8()
					valueCase_ = 2
					value_ = s
				  Case Else
					If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					  done = True
					End If
				End Select
			  Loop
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Throw e.setUnfinishedMessage(Me)
			Catch e As java.io.IOException
			  Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
			Finally
			  Me.unknownFields = unknownFields.build()
			  makeExtensionsImmutable()
			End Try
		  End Sub
		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension), GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder))
		  End Function

		  Friend valueCase_ As Integer = 0
		  Friend value_ As Object
		  Public NotInheritable Class ValueCase Implements org.nd4j.shade.protobuf.Internal.EnumLite
			Public Shared ReadOnly DIM_VALUE As New ValueCase("DIM_VALUE", InnerEnum.DIM_VALUE, 1)
			Public Shared ReadOnly DIM_PARAM As New ValueCase("DIM_PARAM", InnerEnum.DIM_PARAM, 2)
			Public Shared ReadOnly VALUE_NOT_SET As New ValueCase("VALUE_NOT_SET", InnerEnum.VALUE_NOT_SET, 0)

			Private Shared ReadOnly valueList As New List(Of ValueCase)()

			Shared Sub New()
				valueList.Add(DIM_VALUE)
				valueList.Add(DIM_PARAM)
				valueList.Add(VALUE_NOT_SET)
			End Sub

			Public Enum InnerEnum
				DIM_VALUE
				DIM_PARAM
				VALUE_NOT_SET
			End Enum

			Public ReadOnly innerEnumValue As InnerEnum
			Private ReadOnly nameValue As String
			Private ReadOnly ordinalValue As Integer
			Private Shared nextOrdinal As Integer = 0
			Friend ReadOnly value As Integer
			Friend Sub New(ByVal name As String, ByVal thisInnerEnumValue As InnerEnum, ByVal outerInstance As TensorNamespace.TensorShapeProto.Dimension, ByVal value As Integer)
				Me.outerInstance = outerInstance
			  Me.value = value

				nameValue = name
				ordinalValue = nextOrdinal
				nextOrdinal += 1
				innerEnumValue = thisInnerEnumValue
			End Sub
			''' @deprecated Use <seealso cref="forNumber(Integer)"/> instead. 
			<Obsolete("Use <seealso cref=""forNumber(Integer)""/> instead.")>
			Public Shared Function valueOf(ByVal value As Integer) As ValueCase
			  Return forNumber(value)
			End Function

			Public Shared Function forNumber(ByVal value As Integer) As ValueCase
			  Select Case value
				Case 1
					Return DIM_VALUE
				Case 2
					Return DIM_PARAM
				Case 0
					Return VALUE_NOT_SET
				Case Else
					Return Nothing
			  End Select
			End Function
			Public ReadOnly Property Number As Integer
				Get
				  Return Me.value
				End Get
			End Property

			  Public Shared Function values() As ValueCase()
				  Return valueList.ToArray()
			  End Function

			  Public Function ordinal() As Integer
				  Return ordinalValue
			  End Function

			  Public Overrides Function ToString() As String
				  Return nameValue
			  End Function

			  Public Shared Operator =(ByVal one As ValueCase, ByVal two As ValueCase) As Boolean
				  Return one.innerEnumValue = two.innerEnumValue
			  End Operator

			  Public Shared Operator <>(ByVal one As ValueCase, ByVal two As ValueCase) As Boolean
				  Return one.innerEnumValue <> two.innerEnumValue
			  End Operator

			  Public Shared Function valueOf(ByVal name As String) As ValueCase
				  For Each enumInstance As ValueCase In ValueCase.valueList
					  If enumInstance.nameValue = name Then
						  Return enumInstance
					  End If
				  Next
				  Throw New System.ArgumentException(name)
			  End Function
		  End Class

		  Public ReadOnly Property ValueCase As ValueCase
			  Get
				Return ValueCase.forNumber(valueCase_)
			  End Get
		  End Property

		  Public Const DIM_VALUE_FIELD_NUMBER As Integer = 1
		  ''' <summary>
		  ''' <code>int64 dim_value = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimValue As Long Implements DimensionOrBuilder.getDimValue
			  Get
				If valueCase_ = 1 Then
				  Return DirectCast(value_, Long?)
				End If
				Return 0L
			  End Get
		  End Property

		  Public Const DIM_PARAM_FIELD_NUMBER As Integer = 2
		  ''' <summary>
		  ''' <pre>
		  ''' namespace Shape
		  ''' </pre>
		  ''' 
		  ''' <code>string dim_param = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property DimParam As String Implements DimensionOrBuilder.getDimParam
			  Get
				Dim ref As Object = ""
				If valueCase_ = 2 Then
				  ref = value_
				End If
				If TypeOf ref Is String Then
				  Return DirectCast(ref, String)
				Else
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  If valueCase_ = 2 Then
					value_ = s
				  End If
				  Return s
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' namespace Shape
		  ''' </pre>
		  ''' 
		  ''' <code>string dim_param = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property DimParamBytes As org.nd4j.shade.protobuf.ByteString Implements DimensionOrBuilder.getDimParamBytes
			  Get
				Dim ref As Object = ""
				If valueCase_ = 2 Then
				  ref = value_
				End If
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  If valueCase_ = 2 Then
					value_ = b
				  End If
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property

		  Friend memoizedIsInitialized As SByte = -1
		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
				Dim isInitialized_Conflict As SByte = memoizedIsInitialized
				If isInitialized_Conflict = 1 Then
					Return True
				End If
				If isInitialized_Conflict = 0 Then
					Return False
				End If
    
				memoizedIsInitialized = 1
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		  Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
			If valueCase_ = 1 Then
			  output.writeInt64(1, CLng(Math.Truncate(DirectCast(value_, Long?))))
			End If
			If valueCase_ = 2 Then
			  org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 2, value_)
			End If
			unknownFields.writeTo(output)
		  End Sub

		  Public Overrides ReadOnly Property SerializedSize As Integer
			  Get
				Dim size As Integer = memoizedSize
				If size <> -1 Then
					Return size
				End If
    
				size = 0
				If valueCase_ = 1 Then
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt64Size(1, CLng(Math.Truncate(DirectCast(value_, Long?))))
				End If
				If valueCase_ = 2 Then
				  size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(2, value_)
				End If
				size += unknownFields.getSerializedSize()
				memoizedSize = size
				Return size
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		  Public Overrides Function Equals(ByVal obj As Object) As Boolean
			If obj Is Me Then
			 Return True
			End If
			If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) Then
			  Return MyBase.Equals(obj)
			End If
			Dim other As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension = DirectCast(obj, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)

			If Not ValueCase.equals(other.ValueCase) Then
				Return False
			End If
			Select Case valueCase_
			  Case 1
				If DimValue <> other.DimValue Then
					Return False
				End If
			  Case 2
				If Not DimParam.Equals(other.DimParam) Then
					Return False
				End If
			  Case Else
			End Select
			If Not unknownFields.Equals(other.unknownFields) Then
				Return False
			End If
			Return True
		  End Function

		  Public Overrides Function GetHashCode() As Integer
			If memoizedHashCode <> 0 Then
			  Return memoizedHashCode
			End If
			Dim hash As Integer = 41
			hash = (19 * hash) + Descriptor.GetHashCode()
			Select Case valueCase_
			  Case 1
				hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER
				hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong(DimValue)
			  Case 2
				hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER
				hash = (53 * hash) + DimParam.GetHashCode()
			  Case Else
			End Select
			hash = (29 * hash) + unknownFields.GetHashCode()
			memoizedHashCode = hash
			Return hash
		  End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function

		  Public Overrides Function newBuilderForType() As Builder
			  Return newBuilder()
		  End Function
		  Public Shared Function newBuilder() As Builder
			Return DEFAULT_INSTANCE.toBuilder()
		  End Function
		  Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) As Builder
			Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		  End Function
		  Public Overrides Function toBuilder() As Builder
			Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		  End Function

		  Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
			Dim builder_Conflict As New Builder(parent)
			Return builder_Conflict
		  End Function
		  ''' <summary>
		  ''' Protobuf type {@code org.nd4j.ir.TensorShapeProto.Dimension}
		  ''' </summary>
		  Public NotInheritable Class Builder
			  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			  Implements org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder

			Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor
				End Get
			End Property

			Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension), GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder))
			End Function

			' Construct using org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.newBuilder()
			Friend Sub New()
			  maybeForceBuilderInitialization()
			End Sub

			Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			  MyBase.New(parent)
			  maybeForceBuilderInitialization()
			End Sub
			Friend Sub maybeForceBuilderInitialization()
			  If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			  End If
			End Sub
			Public Overrides Function clear() As Builder
			  MyBase.clear()
			  valueCase_ = 0
			  value_ = Nothing
			  Return Me
			End Function

			Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor
				End Get
			End Property

			Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
				Get
				  Return org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.DefaultInstance
				End Get
			End Property

			Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			  Dim result As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension = buildPartial()
			  If Not result.Initialized Then
				Throw newUninitializedMessageException(result)
			  End If
			  Return result
			End Function

			Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			  Dim result As New org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension(Me)
			  If valueCase_ = 1 Then
				result.value_ = value_
			  End If
			  If valueCase_ = 2 Then
				result.value_ = value_
			  End If
			  result.valueCase_ = valueCase_
			  onBuilt()
			  Return result
			End Function

			Public Overrides Function clone() As Builder
			  Return MyBase.clone()
			End Function
			Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.setField(field, value)
			End Function
			Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			  Return MyBase.clearField(field)
			End Function
			Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			  Return MyBase.clearOneof(oneof)
			End Function
			Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			  Return MyBase.setRepeatedField(field, index, value)
			End Function
			Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.addRepeatedField(field, value)
			End Function
			Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			  If TypeOf other Is org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension Then
				Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension))
			  Else
				MyBase.mergeFrom(other)
				Return Me
			  End If
			End Function

			Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) As Builder
			  If other Is org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.DefaultInstance Then
				  Return Me
			  End If
			  Select Case other.ValueCase
				Case DIM_VALUE
				  DimValue = other.DimValue
				Case DIM_PARAM
				  valueCase_ = 2
				  value_ = other.value_
				  onChanged()
				Case VALUE_NOT_SET
			  End Select
			  Me.mergeUnknownFields(other.unknownFields)
			  onChanged()
			  Return Me
			End Function

			Public Overrides ReadOnly Property Initialized As Boolean
				Get
				  Return True
				End Get
			End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
			Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			  Dim parsedMessage As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension = Nothing
			  Try
				parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
				parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)
				Throw e.unwrapIOException()
			  Finally
				If parsedMessage IsNot Nothing Then
				  mergeFrom(parsedMessage)
				End If
			  End Try
			  Return Me
			End Function
			Friend valueCase_ As Integer = 0
			Friend value_ As Object
			Public ReadOnly Property ValueCase As ValueCase
				Get
				  Return ValueCase.forNumber(valueCase_)
				End Get
			End Property

			Public Function clearValue() As Builder
			  valueCase_ = 0
			  value_ = Nothing
			  onChanged()
			  Return Me
			End Function


			''' <summary>
			''' <code>int64 dim_value = 1;</code>
			''' </summary>
			Public ReadOnly Property DimValue As Long Implements org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder.getDimValue
				Get
				  If valueCase_ = 1 Then
					Return DirectCast(value_, Long?)
				  End If
				  Return 0L
				End Get
			End Property
			''' <summary>
			''' <code>int64 dim_value = 1;</code>
			''' </summary>
			Public Function setDimValue(ByVal value As Long) As Builder
			  valueCase_ = 1
			  value_ = value
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <code>int64 dim_value = 1;</code>
			''' </summary>
			Public Function clearDimValue() As Builder
			  If valueCase_ = 1 Then
				valueCase_ = 0
				value_ = Nothing
				onChanged()
			  End If
			  Return Me
			End Function

			''' <summary>
			''' <pre>
			''' namespace Shape
			''' </pre>
			''' 
			''' <code>string dim_param = 2;</code>
			''' </summary>
			Public ReadOnly Property DimParam As String Implements org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder.getDimParam
				Get
				  Dim ref As Object = ""
				  If valueCase_ = 2 Then
					ref = value_
				  End If
				  If Not (TypeOf ref Is String) Then
					Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
					Dim s As String = bs.toStringUtf8()
					If valueCase_ = 2 Then
					  value_ = s
					End If
					Return s
				  Else
					Return DirectCast(ref, String)
				  End If
				End Get
			End Property
			''' <summary>
			''' <pre>
			''' namespace Shape
			''' </pre>
			''' 
			''' <code>string dim_param = 2;</code>
			''' </summary>
			Public ReadOnly Property DimParamBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder.getDimParamBytes
				Get
				  Dim ref As Object = ""
				  If valueCase_ = 2 Then
					ref = value_
				  End If
				  If TypeOf ref Is String Then
					Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
					If valueCase_ = 2 Then
					  value_ = b
					End If
					Return b
				  Else
					Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  End If
				End Get
			End Property
			''' <summary>
			''' <pre>
			''' namespace Shape
			''' </pre>
			''' 
			''' <code>string dim_param = 2;</code>
			''' </summary>
			Public Function setDimParam(ByVal value As String) As Builder
			  If value Is Nothing Then
		Throw New System.NullReferenceException()
			  End If
	  valueCase_ = 2
			  value_ = value
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <pre>
			''' namespace Shape
			''' </pre>
			''' 
			''' <code>string dim_param = 2;</code>
			''' </summary>
			Public Function clearDimParam() As Builder
			  If valueCase_ = 2 Then
				valueCase_ = 0
				value_ = Nothing
				onChanged()
			  End If
			  Return Me
			End Function
			''' <summary>
			''' <pre>
			''' namespace Shape
			''' </pre>
			''' 
			''' <code>string dim_param = 2;</code>
			''' </summary>
			Public Function setDimParamBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			  If value Is Nothing Then
		Throw New System.NullReferenceException()
			  End If
	  checkByteStringIsUtf8(value)
			  valueCase_ = 2
			  value_ = value
			  onChanged()
			  Return Me
			End Function
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.setUnknownFields(unknownFields)
			End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.mergeUnknownFields(unknownFields)
			End Function


			' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorShapeProto.Dimension)
		  End Class

		  ' @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorShapeProto.Dimension)
		  Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
		  Shared Sub New()
			DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension()
		  End Sub

		  Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		  Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of Dimension) = New AbstractParserAnonymousInnerClass()

		  Private Class AbstractParserAnonymousInnerClass
			  Inherits org.nd4j.shade.protobuf.AbstractParser(Of Dimension)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Dimension parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Dimension
				Return New Dimension(input, extensionRegistry)
			  End Function
		  End Class

		  Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of Dimension)
			Return PARSER_Conflict
		  End Function

		  Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of Dimension)
			  Get
				Return PARSER_Conflict
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

		End Class

		Public Const DIM_FIELD_NUMBER As Integer = 1
		Friend dim_ As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Public ReadOnly Property DimList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) Implements TensorShapeProtoOrBuilder.getDimList
			Get
			  Return dim_
			End Get
		End Property
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: public java.util.List<? extends org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder> getDimOrBuilderList()
		Public ReadOnly Property DimOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder) Implements TensorShapeProtoOrBuilder.getDimOrBuilderList
			Get
			  Return dim_
			End Get
		End Property
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Public ReadOnly Property DimCount As Integer Implements TensorShapeProtoOrBuilder.getDimCount
			Get
			  Return dim_.Count
			End Get
		End Property
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Public Function getDim(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension Implements TensorShapeProtoOrBuilder.getDim
		  Return dim_(index)
		End Function
		''' <summary>
		''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		''' </summary>
		Public Function getDimOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder Implements TensorShapeProtoOrBuilder.getDimOrBuilder
		  Return dim_(index)
		End Function

		Friend memoizedIsInitialized As SByte = -1
		Public Overrides ReadOnly Property Initialized As Boolean
			Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
			  Dim isInitialized_Conflict As SByte = memoizedIsInitialized
			  If isInitialized_Conflict = 1 Then
				  Return True
			  End If
			  If isInitialized_Conflict = 0 Then
				  Return False
			  End If
    
			  memoizedIsInitialized = 1
			  Return True
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
		  For i As Integer = 0 To dim_.Count - 1
			output.writeMessage(1, dim_(i))
		  Next i
		  unknownFields.writeTo(output)
		End Sub

		Public Overrides ReadOnly Property SerializedSize As Integer
			Get
			  Dim size As Integer = memoizedSize
			  If size <> -1 Then
				  Return size
			  End If
    
			  size = 0
			  For i As Integer = 0 To dim_.Count - 1
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(1, dim_(i))
			  Next i
			  size += unknownFields.getSerializedSize()
			  memoizedSize = size
			  Return size
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		Public Overrides Function Equals(ByVal obj As Object) As Boolean
		  If obj Is Me Then
		   Return True
		  End If
		  If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TensorShapeProto) Then
			Return MyBase.Equals(obj)
		  End If
		  Dim other As org.nd4j.ir.TensorNamespace.TensorShapeProto = DirectCast(obj, org.nd4j.ir.TensorNamespace.TensorShapeProto)

'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getDimList().equals(other.getDimList()))
		  If Not getDimList().SequenceEqual(other.getDimList()) Then
			  Return False
		  End If
		  If Not unknownFields.Equals(other.unknownFields) Then
			  Return False
		  End If
		  Return True
		End Function

		Public Overrides Function GetHashCode() As Integer
		  If memoizedHashCode <> 0 Then
			Return memoizedHashCode
		  End If
		  Dim hash As Integer = 41
		  hash = (19 * hash) + Descriptor.GetHashCode()
		  If DimCount > 0 Then
			hash = (37 * hash) + DIM_FIELD_NUMBER
			hash = (53 * hash) + getDimList().GetHashCode()
		  End If
		  hash = (29 * hash) + unknownFields.GetHashCode()
		  memoizedHashCode = hash
		  Return hash
		End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorShapeProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorShapeProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function

		Public Overrides Function newBuilderForType() As Builder
			Return newBuilder()
		End Function
		Public Shared Function newBuilder() As Builder
		  Return DEFAULT_INSTANCE.toBuilder()
		End Function
		Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TensorShapeProto) As Builder
		  Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		End Function
		Public Overrides Function toBuilder() As Builder
		  Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		End Function

		Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Dim builder_Conflict As New Builder(parent)
		  Return builder_Conflict
		End Function
		''' <summary>
		''' <pre>
		''' Defines a tensor shape. A dimension can be either an integer value
		''' or a symbolic variable. A symbolic variable represents an unknown
		''' dimension.
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.TensorShapeProto}
		''' </summary>
		Public NotInheritable Class Builder
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder

		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto), GetType(org.nd4j.ir.TensorNamespace.TensorShapeProto.Builder))
		  End Function

		  ' Construct using org.nd4j.ir.TensorNamespace.TensorShapeProto.newBuilder()
		  Friend Sub New()
			maybeForceBuilderInitialization()
		  End Sub

		  Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			MyBase.New(parent)
			maybeForceBuilderInitialization()
		  End Sub
		  Friend Sub maybeForceBuilderInitialization()
			If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			  getDimFieldBuilder()
			End If
		  End Sub
		  Public Overrides Function clear() As Builder
			MyBase.clear()
			If dimBuilder_ Is Nothing Then
			  dim_ = java.util.Collections.emptyList()
			  bitField0_ = (bitField0_ And Not &H1)
			Else
			  dimBuilder_.clear()
			End If
			Return Me
		  End Function

		  Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorShapeProto_descriptor
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorShapeProto
			  Get
				Return org.nd4j.ir.TensorNamespace.TensorShapeProto.DefaultInstance
			  End Get
		  End Property

		  Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TensorShapeProto
			Dim result As org.nd4j.ir.TensorNamespace.TensorShapeProto = buildPartial()
			If Not result.Initialized Then
			  Throw newUninitializedMessageException(result)
			End If
			Return result
		  End Function

		  Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TensorShapeProto
			Dim result As New org.nd4j.ir.TensorNamespace.TensorShapeProto(Me)
			Dim from_bitField0_ As Integer = bitField0_
			If dimBuilder_ Is Nothing Then
			  If ((bitField0_ And &H1) <> 0) Then
				dim_ = java.util.Collections.unmodifiableList(dim_)
				bitField0_ = (bitField0_ And Not &H1)
			  End If
			  result.dim_ = dim_
			Else
			  result.dim_ = dimBuilder_.build()
			End If
			onBuilt()
			Return result
		  End Function

		  Public Overrides Function clone() As Builder
			Return MyBase.clone()
		  End Function
		  Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.setField(field, value)
		  End Function
		  Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			Return MyBase.clearField(field)
		  End Function
		  Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			Return MyBase.clearOneof(oneof)
		  End Function
		  Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			Return MyBase.setRepeatedField(field, index, value)
		  End Function
		  Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.addRepeatedField(field, value)
		  End Function
		  Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			If TypeOf other Is org.nd4j.ir.TensorNamespace.TensorShapeProto Then
			  Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TensorShapeProto))
			Else
			  MyBase.mergeFrom(other)
			  Return Me
			End If
		  End Function

		  Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TensorShapeProto) As Builder
			If other Is org.nd4j.ir.TensorNamespace.TensorShapeProto.DefaultInstance Then
				Return Me
			End If
			If dimBuilder_ Is Nothing Then
			  If other.dim_.Count > 0 Then
				If dim_.Count = 0 Then
				  dim_ = other.dim_
				  bitField0_ = (bitField0_ And Not &H1)
				Else
				  ensureDimIsMutable()
				  CType(dim_, List(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)).AddRange(other.dim_)
				End If
				onChanged()
			  End If
			Else
			  If other.dim_.Count > 0 Then
				If dimBuilder_.isEmpty() Then
				  dimBuilder_.dispose()
				  dimBuilder_ = Nothing
				  dim_ = other.dim_
				  bitField0_ = (bitField0_ And Not &H1)
				  dimBuilder_ = If(org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders, getDimFieldBuilder(), Nothing)
				Else
				  dimBuilder_.addAllMessages(other.dim_)
				End If
			  End If
			End If
			Me.mergeUnknownFields(other.unknownFields)
			onChanged()
			Return Me
		  End Function

		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			Dim parsedMessage As org.nd4j.ir.TensorNamespace.TensorShapeProto = Nothing
			Try
			  parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TensorShapeProto)
			  Throw e.unwrapIOException()
			Finally
			  If parsedMessage IsNot Nothing Then
				mergeFrom(parsedMessage)
			  End If
			End Try
			Return Me
		  End Function
		  Friend bitField0_ As Integer

		  Friend dim_ As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) = java.util.Collections.emptyList()
		  Friend Sub ensureDimIsMutable()
			If Not ((bitField0_ And &H1) <> 0) Then
			  dim_ = New List(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)(dim_)
			  bitField0_ = bitField0_ Or &H1
			End If
		  End Sub

		  Friend dimBuilder_ As org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder)

		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder.getDimList
			  Get
				If dimBuilder_ Is Nothing Then
				  Return java.util.Collections.unmodifiableList(dim_)
				Else
				  Return dimBuilder_.getMessageList()
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder.getDimCount
			  Get
				If dimBuilder_ Is Nothing Then
				  Return dim_.Count
				Else
				  Return dimBuilder_.getCount()
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function getDim(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder.getDim
			If dimBuilder_ Is Nothing Then
			  Return dim_(index)
			Else
			  Return dimBuilder_.getMessage(index)
			End If
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function setDim(ByVal index As Integer, ByVal value As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) As Builder
			If dimBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureDimIsMutable()
			  dim_(index) = value
			  onChanged()
			Else
			  dimBuilder_.setMessage(index, value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function setDim(ByVal index As Integer, ByVal builderForValue As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder) As Builder
			If dimBuilder_ Is Nothing Then
			  ensureDimIsMutable()
			  dim_(index) = builderForValue.build()
			  onChanged()
			Else
			  dimBuilder_.setMessage(index, builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDim(ByVal value As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) As Builder
			If dimBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureDimIsMutable()
			  dim_.Add(value)
			  onChanged()
			Else
			  dimBuilder_.addMessage(value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDim(ByVal index As Integer, ByVal value As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension) As Builder
			If dimBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureDimIsMutable()
			  dim_.Insert(index, value)
			  onChanged()
			Else
			  dimBuilder_.addMessage(index, value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDim(ByVal builderForValue As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder) As Builder
			If dimBuilder_ Is Nothing Then
			  ensureDimIsMutable()
			  dim_.Add(builderForValue.build())
			  onChanged()
			Else
			  dimBuilder_.addMessage(builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDim(ByVal index As Integer, ByVal builderForValue As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder) As Builder
			If dimBuilder_ Is Nothing Then
			  ensureDimIsMutable()
			  dim_.Insert(index, builderForValue.build())
			  onChanged()
			Else
			  dimBuilder_.addMessage(index, builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addAllDim(Of T1 As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension)(ByVal values As IEnumerable(Of T1)) As Builder
			If dimBuilder_ Is Nothing Then
			  ensureDimIsMutable()
			  org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, dim_)
			  onChanged()
			Else
			  dimBuilder_.addAllMessages(values)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function clearDim() As Builder
			If dimBuilder_ Is Nothing Then
			  dim_ = java.util.Collections.emptyList()
			  bitField0_ = (bitField0_ And Not &H1)
			  onChanged()
			Else
			  dimBuilder_.clear()
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function removeDim(ByVal index As Integer) As Builder
			If dimBuilder_ Is Nothing Then
			  ensureDimIsMutable()
			  dim_.RemoveAt(index)
			  onChanged()
			Else
			  dimBuilder_.remove(index)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function getDimBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder
			Return getDimFieldBuilder().getBuilder(index)
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function getDimOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder.getDimOrBuilder
			If dimBuilder_ Is Nothing Then
			  Return dim_(index)
			Else
			  Return dimBuilder_.getMessageOrBuilder(index)
			End If
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: public java.util.List<? extends org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder> getDimOrBuilderList()
		  Public ReadOnly Property DimOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder) Implements org.nd4j.ir.TensorNamespace.TensorShapeProtoOrBuilder.getDimOrBuilderList
			  Get
				If dimBuilder_ IsNot Nothing Then
				  Return dimBuilder_.getMessageOrBuilderList()
				Else
				  Return java.util.Collections.unmodifiableList(dim_)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDimBuilder() As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder
			Return getDimFieldBuilder().addBuilder(org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.DefaultInstance)
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public Function addDimBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder
			Return getDimFieldBuilder().addBuilder(index, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.DefaultInstance)
		  End Function
		  ''' <summary>
		  ''' <code>repeated .org.nd4j.ir.TensorShapeProto.Dimension dim = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimBuilderList As IList(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder)
			  Get
				Return getDimFieldBuilder().getBuilderList()
			  End Get
		  End Property
		  Friend ReadOnly Property DimFieldBuilder As org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder)
			  Get
				If dimBuilder_ Is Nothing Then
				  dimBuilder_ = New org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension, org.nd4j.ir.TensorNamespace.TensorShapeProto.Dimension.Builder, org.nd4j.ir.TensorNamespace.TensorShapeProto.DimensionOrBuilder)(dim_, ((bitField0_ And &H1) <> 0), getParentForChildren(), isClean())
				  dim_ = Nothing
				End If
				Return dimBuilder_
			  End Get
		  End Property
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.setUnknownFields(unknownFields)
		  End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.mergeUnknownFields(unknownFields)
		  End Function


		  ' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorShapeProto)
		End Class

		' @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorShapeProto)
		Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TensorShapeProto
		Shared Sub New()
		  DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TensorShapeProto()
		End Sub

		Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TensorShapeProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of TensorShapeProto) = New AbstractParserAnonymousInnerClass()

		Private Class AbstractParserAnonymousInnerClass
			Inherits org.nd4j.shade.protobuf.AbstractParser(Of TensorShapeProto)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public TensorShapeProto parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As TensorShapeProto
			  Return New TensorShapeProto(input, extensionRegistry)
			End Function
		End Class

		Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of TensorShapeProto)
		  Return PARSER_Conflict
		End Function

		Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of TensorShapeProto)
			Get
			  Return PARSER_Conflict
			End Get
		End Property

		Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorShapeProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

	  End Class

	  Public Interface ValueInfoProtoOrBuilder
		  Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>string name = 1;</code>
		''' </summary>
		ReadOnly Property Name As String
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>string name = 1;</code>
		''' </summary>
		ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		Function hasType() As Boolean
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		Function [getType]() As org.nd4j.ir.TensorNamespace.TypeProto
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		ReadOnly Property TypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder

		''' <summary>
		''' <pre>
		''' A human-readable documentation for this value. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 3;</code>
		''' </summary>
		ReadOnly Property DocString As String
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this value. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 3;</code>
		''' </summary>
		ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString
	  End Interface
	  ''' <summary>
	  ''' <pre>
	  ''' Defines information on value, including the name, the type, and
	  ''' the shape of the value.
	  ''' </pre>
	  ''' 
	  ''' Protobuf type {@code org.nd4j.ir.ValueInfoProto}
	  ''' </summary>
	  Public NotInheritable Class ValueInfoProto
		  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
		  Implements ValueInfoProtoOrBuilder

	  Friend Const serialVersionUID As Long = 0L
		' Use ValueInfoProto.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private ValueInfoProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
		  MyBase.New(builder_Conflict)
		End Sub
		Friend Sub New()
		  name_ = ""
		  docString_ = ""
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
		  Return New ValueInfoProto()
		End Function

		Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			Get
			  Return Me.unknownFields
			End Get
		End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private ValueInfoProto(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
		  Me.New()
		  If extensionRegistry Is Nothing Then
			Throw New System.NullReferenceException()
		  End If
		  Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
		  Try
			Dim done As Boolean = False
			Do While Not done
			  Dim tag As Integer = input.readTag()
			  Select Case tag
				Case 0
				  done = True
				Case 10
				  Dim s As String = input.readStringRequireUtf8()

				  name_ = s
				Case 18
				  Dim subBuilder As org.nd4j.ir.TensorNamespace.TypeProto.Builder = Nothing
				  If type_ IsNot Nothing Then
					subBuilder = type_.toBuilder()
				  End If
				  type_ = input.readMessage(org.nd4j.ir.TensorNamespace.TypeProto.parser(), extensionRegistry)
				  If subBuilder IsNot Nothing Then
					subBuilder.mergeFrom(type_)
					type_ = subBuilder.buildPartial()
				  End If

				Case 26
				  Dim s As String = input.readStringRequireUtf8()

				  docString_ = s
				Case Else
				  If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					done = True
				  End If
			  End Select
			Loop
		  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Throw e.setUnfinishedMessage(Me)
		  Catch e As java.io.IOException
			Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
		  Finally
			Me.unknownFields = unknownFields.build()
			makeExtensionsImmutable()
		  End Try
		End Sub
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_ValueInfoProto_descriptor
			End Get
		End Property

		Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
		  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.ValueInfoProto), GetType(org.nd4j.ir.TensorNamespace.ValueInfoProto.Builder))
		End Function

		Public Const NAME_FIELD_NUMBER As Integer = 1
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object name_;
		Friend name_ As Object
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>string name = 1;</code>
		''' </summary>
		Public ReadOnly Property Name As String Implements ValueInfoProtoOrBuilder.getName
			Get
			  Dim ref As Object = name_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				name_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>string name = 1;</code>
		''' </summary>
		Public ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString Implements ValueInfoProtoOrBuilder.getNameBytes
			Get
			  Dim ref As Object = name_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				name_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Public Const TYPE_FIELD_NUMBER As Integer = 2
		Friend type_ As org.nd4j.ir.TensorNamespace.TypeProto
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		Public Function hasType() As Boolean Implements ValueInfoProtoOrBuilder.hasType
		  Return type_ IsNot Nothing
		End Function
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		Public Function [getType]() As org.nd4j.ir.TensorNamespace.TypeProto Implements ValueInfoProtoOrBuilder.getType
		  Return If(type_ Is Nothing, org.nd4j.ir.TensorNamespace.TypeProto.DefaultInstance, type_)
		End Function
		''' <summary>
		''' <pre>
		''' This field MUST be present in this version of the IR.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		''' </summary>
		Public ReadOnly Property TypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder Implements ValueInfoProtoOrBuilder.getTypeOrBuilder
			Get
			  Return [getType]()
			End Get
		End Property

		Public Const DOC_STRING_FIELD_NUMBER As Integer = 3
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object docString_;
		Friend docString_ As Object
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this value. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 3;</code>
		''' </summary>
		Public ReadOnly Property DocString As String Implements ValueInfoProtoOrBuilder.getDocString
			Get
			  Dim ref As Object = docString_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				docString_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this value. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 3;</code>
		''' </summary>
		Public ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString Implements ValueInfoProtoOrBuilder.getDocStringBytes
			Get
			  Dim ref As Object = docString_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				docString_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Friend memoizedIsInitialized As SByte = -1
		Public Overrides ReadOnly Property Initialized As Boolean
			Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
			  Dim isInitialized_Conflict As SByte = memoizedIsInitialized
			  If isInitialized_Conflict = 1 Then
				  Return True
			  End If
			  If isInitialized_Conflict = 0 Then
				  Return False
			  End If
    
			  memoizedIsInitialized = 1
			  Return True
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
		  If Not NameBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 1, name_)
		  End If
		  If type_ IsNot Nothing Then
			output.writeMessage(2, [getType]())
		  End If
		  If Not DocStringBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 3, docString_)
		  End If
		  unknownFields.writeTo(output)
		End Sub

		Public Overrides ReadOnly Property SerializedSize As Integer
			Get
			  Dim size As Integer = memoizedSize
			  If size <> -1 Then
				  Return size
			  End If
    
			  size = 0
			  If Not NameBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(1, name_)
			  End If
			  If type_ IsNot Nothing Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(2, [getType]())
			  End If
			  If Not DocStringBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(3, docString_)
			  End If
			  size += unknownFields.getSerializedSize()
			  memoizedSize = size
			  Return size
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		Public Overrides Function Equals(ByVal obj As Object) As Boolean
		  If obj Is Me Then
		   Return True
		  End If
		  If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.ValueInfoProto) Then
			Return MyBase.Equals(obj)
		  End If
		  Dim other As org.nd4j.ir.TensorNamespace.ValueInfoProto = DirectCast(obj, org.nd4j.ir.TensorNamespace.ValueInfoProto)

		  If Not Name.Equals(other.Name) Then
			  Return False
		  End If
		  If hasType() <> other.hasType() Then
			  Return False
		  End If
		  If hasType() Then
			If Not [getType]().Equals(other.getType()) Then
				Return False
			End If
		  End If
		  If Not DocString.Equals(other.DocString) Then
			  Return False
		  End If
		  If Not unknownFields.Equals(other.unknownFields) Then
			  Return False
		  End If
		  Return True
		End Function

		Public Overrides Function GetHashCode() As Integer
		  If memoizedHashCode <> 0 Then
			Return memoizedHashCode
		  End If
		  Dim hash As Integer = 41
		  hash = (19 * hash) + Descriptor.GetHashCode()
		  hash = (37 * hash) + NAME_FIELD_NUMBER
		  hash = (53 * hash) + Name.GetHashCode()
		  If hasType() Then
			hash = (37 * hash) + TYPE_FIELD_NUMBER
			hash = (53 * hash) + [getType]().GetHashCode()
		  End If
		  hash = (37 * hash) + DOC_STRING_FIELD_NUMBER
		  hash = (53 * hash) + DocString.GetHashCode()
		  hash = (29 * hash) + unknownFields.GetHashCode()
		  memoizedHashCode = hash
		  Return hash
		End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.ValueInfoProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.ValueInfoProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function

		Public Overrides Function newBuilderForType() As Builder
			Return newBuilder()
		End Function
		Public Shared Function newBuilder() As Builder
		  Return DEFAULT_INSTANCE.toBuilder()
		End Function
		Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.ValueInfoProto) As Builder
		  Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		End Function
		Public Overrides Function toBuilder() As Builder
		  Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		End Function

		Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Dim builder_Conflict As New Builder(parent)
		  Return builder_Conflict
		End Function
		''' <summary>
		''' <pre>
		''' Defines information on value, including the name, the type, and
		''' the shape of the value.
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.ValueInfoProto}
		''' </summary>
		Public NotInheritable Class Builder
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder

		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_ValueInfoProto_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.ValueInfoProto), GetType(org.nd4j.ir.TensorNamespace.ValueInfoProto.Builder))
		  End Function

		  ' Construct using org.nd4j.ir.TensorNamespace.ValueInfoProto.newBuilder()
		  Friend Sub New()
			maybeForceBuilderInitialization()
		  End Sub

		  Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			MyBase.New(parent)
			maybeForceBuilderInitialization()
		  End Sub
		  Friend Sub maybeForceBuilderInitialization()
			If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			End If
		  End Sub
		  Public Overrides Function clear() As Builder
			MyBase.clear()
			name_ = ""

			If typeBuilder_ Is Nothing Then
			  type_ = Nothing
			Else
			  type_ = Nothing
			  typeBuilder_ = Nothing
			End If
			docString_ = ""

			Return Me
		  End Function

		  Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_ValueInfoProto_descriptor
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.ValueInfoProto
			  Get
				Return org.nd4j.ir.TensorNamespace.ValueInfoProto.DefaultInstance
			  End Get
		  End Property

		  Public Overrides Function build() As org.nd4j.ir.TensorNamespace.ValueInfoProto
			Dim result As org.nd4j.ir.TensorNamespace.ValueInfoProto = buildPartial()
			If Not result.Initialized Then
			  Throw newUninitializedMessageException(result)
			End If
			Return result
		  End Function

		  Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.ValueInfoProto
			Dim result As New org.nd4j.ir.TensorNamespace.ValueInfoProto(Me)
			result.name_ = name_
			If typeBuilder_ Is Nothing Then
			  result.type_ = type_
			Else
			  result.type_ = typeBuilder_.build()
			End If
			result.docString_ = docString_
			onBuilt()
			Return result
		  End Function

		  Public Overrides Function clone() As Builder
			Return MyBase.clone()
		  End Function
		  Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.setField(field, value)
		  End Function
		  Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			Return MyBase.clearField(field)
		  End Function
		  Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			Return MyBase.clearOneof(oneof)
		  End Function
		  Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			Return MyBase.setRepeatedField(field, index, value)
		  End Function
		  Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.addRepeatedField(field, value)
		  End Function
		  Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			If TypeOf other Is org.nd4j.ir.TensorNamespace.ValueInfoProto Then
			  Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.ValueInfoProto))
			Else
			  MyBase.mergeFrom(other)
			  Return Me
			End If
		  End Function

		  Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.ValueInfoProto) As Builder
			If other Is org.nd4j.ir.TensorNamespace.ValueInfoProto.DefaultInstance Then
				Return Me
			End If
			If other.Name.Length > 0 Then
			  name_ = other.name_
			  onChanged()
			End If
			If other.hasType() Then
			  mergeType(other.getType())
			End If
			If other.DocString.Length > 0 Then
			  docString_ = other.docString_
			  onChanged()
			End If
			Me.mergeUnknownFields(other.unknownFields)
			onChanged()
			Return Me
		  End Function

		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			Dim parsedMessage As org.nd4j.ir.TensorNamespace.ValueInfoProto = Nothing
			Try
			  parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.ValueInfoProto)
			  Throw e.unwrapIOException()
			Finally
			  If parsedMessage IsNot Nothing Then
				mergeFrom(parsedMessage)
			  End If
			End Try
			Return Me
		  End Function

		  Friend name_ As Object = ""
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property Name As String Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getName
			  Get
				Dim ref As Object = name_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  name_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getNameBytes
			  Get
				Dim ref As Object = name_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  name_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 1;</code>
		  ''' </summary>
		  Public Function setName(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			name_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 1;</code>
		  ''' </summary>
		  Public Function clearName() As Builder

			name_ = DefaultInstance.Name
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 1;</code>
		  ''' </summary>
		  Public Function setNameBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			name_ = value
			onChanged()
			Return Me
		  End Function

		  Friend type_ As org.nd4j.ir.TensorNamespace.TypeProto
		  Friend typeBuilder_ As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto, org.nd4j.ir.TensorNamespace.TypeProto.Builder, org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder)
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function hasType() As Boolean Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.hasType
			Return typeBuilder_ IsNot Nothing OrElse type_ IsNot Nothing
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function [getType]() As org.nd4j.ir.TensorNamespace.TypeProto Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getType
			If typeBuilder_ Is Nothing Then
			  Return If(type_ Is Nothing, org.nd4j.ir.TensorNamespace.TypeProto.DefaultInstance, type_)
			Else
			  Return typeBuilder_.getMessage()
			End If
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function setType(ByVal value As org.nd4j.ir.TensorNamespace.TypeProto) As Builder
			If typeBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  type_ = value
			  onChanged()
			Else
			  typeBuilder_.setMessage(value)
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function setType(ByVal builderForValue As org.nd4j.ir.TensorNamespace.TypeProto.Builder) As Builder
			If typeBuilder_ Is Nothing Then
			  type_ = builderForValue.build()
			  onChanged()
			Else
			  typeBuilder_.setMessage(builderForValue.build())
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function mergeType(ByVal value As org.nd4j.ir.TensorNamespace.TypeProto) As Builder
			If typeBuilder_ Is Nothing Then
			  If type_ IsNot Nothing Then
				type_ = org.nd4j.ir.TensorNamespace.TypeProto.newBuilder(type_).mergeFrom(value).buildPartial()
			  Else
				type_ = value
			  End If
			  onChanged()
			Else
			  typeBuilder_.mergeFrom(value)
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public Function clearType() As Builder
			If typeBuilder_ Is Nothing Then
			  type_ = Nothing
			  onChanged()
			Else
			  type_ = Nothing
			  typeBuilder_ = Nothing
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property TypeBuilder As org.nd4j.ir.TensorNamespace.TypeProto.Builder
			  Get
    
				onChanged()
				Return getTypeFieldBuilder().getBuilder()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property TypeOrBuilder As org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getTypeOrBuilder
			  Get
				If typeBuilder_ IsNot Nothing Then
				  Return typeBuilder_.getMessageOrBuilder()
				Else
				  Return If(type_ Is Nothing, org.nd4j.ir.TensorNamespace.TypeProto.DefaultInstance, type_)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' This field MUST be present in this version of the IR.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TypeProto type = 2;</code>
		  ''' </summary>
		  Friend ReadOnly Property TypeFieldBuilder As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto, org.nd4j.ir.TensorNamespace.TypeProto.Builder, org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder)
			  Get
				If typeBuilder_ Is Nothing Then
				  typeBuilder_ = New org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TypeProto, org.nd4j.ir.TensorNamespace.TypeProto.Builder, org.nd4j.ir.TensorNamespace.TypeProtoOrBuilder)([getType](), getParentForChildren(), isClean())
				  type_ = Nothing
				End If
				Return typeBuilder_
			  End Get
		  End Property

		  Friend docString_ As Object = ""
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this value. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 3;</code>
		  ''' </summary>
		  Public ReadOnly Property DocString As String Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getDocString
			  Get
				Dim ref As Object = docString_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  docString_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this value. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 3;</code>
		  ''' </summary>
		  Public ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.ValueInfoProtoOrBuilder.getDocStringBytes
			  Get
				Dim ref As Object = docString_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  docString_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this value. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 3;</code>
		  ''' </summary>
		  Public Function setDocString(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			docString_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this value. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 3;</code>
		  ''' </summary>
		  Public Function clearDocString() As Builder

			docString_ = DefaultInstance.DocString
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this value. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 3;</code>
		  ''' </summary>
		  Public Function setDocStringBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			docString_ = value
			onChanged()
			Return Me
		  End Function
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.setUnknownFields(unknownFields)
		  End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.mergeUnknownFields(unknownFields)
		  End Function


		  ' @@protoc_insertion_point(builder_scope:org.nd4j.ir.ValueInfoProto)
		End Class

		' @@protoc_insertion_point(class_scope:org.nd4j.ir.ValueInfoProto)
		Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.ValueInfoProto
		Shared Sub New()
		  DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.ValueInfoProto()
		End Sub

		Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.ValueInfoProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of ValueInfoProto) = New AbstractParserAnonymousInnerClass()

		Private Class AbstractParserAnonymousInnerClass
			Inherits org.nd4j.shade.protobuf.AbstractParser(Of ValueInfoProto)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public ValueInfoProto parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As ValueInfoProto
			  Return New ValueInfoProto(input, extensionRegistry)
			End Function
		End Class

		Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of ValueInfoProto)
		  Return PARSER_Conflict
		End Function

		Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of ValueInfoProto)
			Get
			  Return PARSER_Conflict
			End Get
		End Property

		Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.ValueInfoProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

	  End Class

	  Public Interface TensorProtoOrBuilder
		  Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		ReadOnly Property DimsList As IList(Of Long)
		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		ReadOnly Property DimsCount As Integer
		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		Function getDims(ByVal index As Integer) As Long

		''' <summary>
		''' <pre>
		''' The data type of the tensor.
		''' This field MUST have a valid TensorProto.DataType value
		''' </pre>
		''' 
		''' <code>int32 data_type = 2;</code>
		''' </summary>
		ReadOnly Property DataType As Integer

		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		Function hasSegment() As Boolean
		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		ReadOnly Property Segment As org.nd4j.ir.TensorNamespace.TensorProto.Segment
		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		ReadOnly Property SegmentOrBuilder As org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder

		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		ReadOnly Property FloatDataList As IList(Of Single)
		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		ReadOnly Property FloatDataCount As Integer
		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		Function getFloatData(ByVal index As Integer) As Single

		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		ReadOnly Property Int32DataList As IList(Of Integer)
		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		ReadOnly Property Int32DataCount As Integer
		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		Function getInt32Data(ByVal index As Integer) As Integer

		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		ReadOnly Property StringDataList As IList(Of org.nd4j.shade.protobuf.ByteString)
		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		ReadOnly Property StringDataCount As Integer
		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		Function getStringData(ByVal index As Integer) As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		ReadOnly Property Int64DataList As IList(Of Long)
		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		ReadOnly Property Int64DataCount As Integer
		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		Function getInt64Data(ByVal index As Integer) As Long

		''' <summary>
		''' <pre>
		''' Optionally, a name for the tensor.
		''' </pre>
		''' 
		''' <code>string name = 8;</code>
		''' </summary>
		ReadOnly Property Name As String
		''' <summary>
		''' <pre>
		''' Optionally, a name for the tensor.
		''' </pre>
		''' 
		''' <code>string name = 8;</code>
		''' </summary>
		ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <pre>
		''' A human-readable documentation for this tensor. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 12;</code>
		''' </summary>
		ReadOnly Property DocString As String
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this tensor. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 12;</code>
		''' </summary>
		ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <pre>
		''' Serializations can either use one of the fields above, or use this
		''' raw bytes field. The only exception is the string case, where one is
		''' required to store the content in the repeated bytes string_data field.
		''' When this raw_data field is used to store tensor value, elements MUST
		''' be stored in as fixed-width, little-endian order.
		''' Floating-point data types MUST be stored in IEEE 754 format.
		''' Complex64 elements must be written as two consecutive FLOAT values, real component first.
		''' Complex128 elements must be written as two consecutive DOUBLE values, real component first.
		''' Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
		''' Note: the advantage of specific field rather than the raw_data field is
		''' that in some cases (e.g. int data), protobuf does a better packing via
		''' variable length storage, and may lead to smaller binary footprint.
		''' When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
		''' </pre>
		''' 
		''' <code>bytes raw_data = 9;</code>
		''' </summary>
		ReadOnly Property RawData As org.nd4j.shade.protobuf.ByteString

		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		ReadOnly Property ExternalDataList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto)
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Function getExternalData(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		ReadOnly Property ExternalDataCount As Integer
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: java.util.List<? extends org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder> getExternalDataOrBuilderList();
		ReadOnly Property ExternalDataOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder)
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Function getExternalDataOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder

		''' <summary>
		''' <pre>
		''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		''' </summary>
		ReadOnly Property DataLocationValue As Integer
		''' <summary>
		''' <pre>
		''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		''' </summary>
		ReadOnly Property DataLocation As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation

		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		ReadOnly Property DoubleDataList As IList(Of Double)
		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		ReadOnly Property DoubleDataCount As Integer
		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		Function getDoubleData(ByVal index As Integer) As Double

		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		ReadOnly Property Uint64DataList As IList(Of Long)
		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		ReadOnly Property Uint64DataCount As Integer
		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		Function getUint64Data(ByVal index As Integer) As Long

		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		ReadOnly Property HalfValList As IList(Of Integer)
		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		ReadOnly Property HalfValCount As Integer
		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		Function getHalfVal(ByVal index As Integer) As Integer

		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		ReadOnly Property BoolValList As IList(Of Boolean)
		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		ReadOnly Property BoolValCount As Integer
		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		Function getBoolVal(ByVal index As Integer) As Boolean
	  End Interface
	  ''' <summary>
	  ''' <pre>
	  ''' Tensors
	  ''' A serialized tensor value.
	  ''' </pre>
	  ''' 
	  ''' Protobuf type {@code org.nd4j.ir.TensorProto}
	  ''' </summary>
	  Public NotInheritable Class TensorProto
		  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
		  Implements TensorProtoOrBuilder

	  Friend Const serialVersionUID As Long = 0L
		' Use TensorProto.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private TensorProto(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
		  MyBase.New(builder_Conflict)
		End Sub
		Friend Sub New()
		  dims_ = emptyLongList()
		  floatData_ = emptyFloatList()
		  int32Data_ = emptyIntList()
		  stringData_ = java.util.Collections.emptyList()
		  int64Data_ = emptyLongList()
		  name_ = ""
		  docString_ = ""
		  rawData_ = org.nd4j.shade.protobuf.ByteString.EMPTY
		  externalData_ = java.util.Collections.emptyList()
		  dataLocation_ = 0
		  doubleData_ = emptyDoubleList()
		  uint64Data_ = emptyLongList()
		  halfVal_ = emptyIntList()
		  boolVal_ = emptyBooleanList()
		End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
		  Return New TensorProto()
		End Function

		Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			Get
			  Return Me.unknownFields
			End Get
		End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private TensorProto(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
		  Me.New()
		  If extensionRegistry Is Nothing Then
			Throw New System.NullReferenceException()
		  End If
		  Dim mutable_bitField0_ As Integer = 0
		  Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
		  Try
			Dim done As Boolean = False
			Do While Not done
			  Dim tag As Integer = input.readTag()
			  Select Case tag
				Case 0
				  done = True
				Case 8
				  If Not ((mutable_bitField0_ And &H1) <> 0) Then
					dims_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H1
				  End If
				  dims_.addLong(input.readInt64())
				Case 10
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H1) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					dims_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H1
				  End If
				  Do While input.getBytesUntilLimit() > 0
					dims_.addLong(input.readInt64())
				  Loop
				  input.popLimit(limit)
				Case 16

				  dataType_ = input.readInt32()
				Case 26
				  Dim subBuilder As org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder = Nothing
				  If segment_ IsNot Nothing Then
					subBuilder = segment_.toBuilder()
				  End If
				  segment_ = input.readMessage(org.nd4j.ir.TensorNamespace.TensorProto.Segment.parser(), extensionRegistry)
				  If subBuilder IsNot Nothing Then
					subBuilder.mergeFrom(segment_)
					segment_ = subBuilder.buildPartial()
				  End If

				Case 37
				  If Not ((mutable_bitField0_ And &H2) <> 0) Then
					floatData_ = newFloatList()
					mutable_bitField0_ = mutable_bitField0_ Or &H2
				  End If
				  floatData_.addFloat(input.readFloat())
				Case 34
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H2) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					floatData_ = newFloatList()
					mutable_bitField0_ = mutable_bitField0_ Or &H2
				  End If
				  Do While input.getBytesUntilLimit() > 0
					floatData_.addFloat(input.readFloat())
				  Loop
				  input.popLimit(limit)
				Case 40
				  If Not ((mutable_bitField0_ And &H4) <> 0) Then
					int32Data_ = newIntList()
					mutable_bitField0_ = mutable_bitField0_ Or &H4
				  End If
				  int32Data_.addInt(input.readInt32())
				Case 42
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H4) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					int32Data_ = newIntList()
					mutable_bitField0_ = mutable_bitField0_ Or &H4
				  End If
				  Do While input.getBytesUntilLimit() > 0
					int32Data_.addInt(input.readInt32())
				  Loop
				  input.popLimit(limit)
				Case 50
				  If Not ((mutable_bitField0_ And &H8) <> 0) Then
					stringData_ = New List(Of org.nd4j.shade.protobuf.ByteString)()
					mutable_bitField0_ = mutable_bitField0_ Or &H8
				  End If
				  stringData_.Add(input.readBytes())
				Case 56
				  If Not ((mutable_bitField0_ And &H10) <> 0) Then
					int64Data_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H10
				  End If
				  int64Data_.addLong(input.readInt64())
				Case 58
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H10) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					int64Data_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H10
				  End If
				  Do While input.getBytesUntilLimit() > 0
					int64Data_.addLong(input.readInt64())
				  Loop
				  input.popLimit(limit)
				Case 66
				  Dim s As String = input.readStringRequireUtf8()

				  name_ = s
				Case 74

				  rawData_ = input.readBytes()
				Case 81
				  If Not ((mutable_bitField0_ And &H40) <> 0) Then
					doubleData_ = newDoubleList()
					mutable_bitField0_ = mutable_bitField0_ Or &H40
				  End If
				  doubleData_.addDouble(input.readDouble())
				Case 82
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H40) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					doubleData_ = newDoubleList()
					mutable_bitField0_ = mutable_bitField0_ Or &H40
				  End If
				  Do While input.getBytesUntilLimit() > 0
					doubleData_.addDouble(input.readDouble())
				  Loop
				  input.popLimit(limit)
				Case 88
				  If Not ((mutable_bitField0_ And &H80) <> 0) Then
					uint64Data_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H80
				  End If
				  uint64Data_.addLong(input.readUInt64())
				Case 90
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H80) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					uint64Data_ = newLongList()
					mutable_bitField0_ = mutable_bitField0_ Or &H80
				  End If
				  Do While input.getBytesUntilLimit() > 0
					uint64Data_.addLong(input.readUInt64())
				  Loop
				  input.popLimit(limit)
				Case 98
				  Dim s As String = input.readStringRequireUtf8()

				  docString_ = s
				Case 106
				  If Not ((mutable_bitField0_ And &H20) <> 0) Then
					externalData_ = New List(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto)()
					mutable_bitField0_ = mutable_bitField0_ Or &H20
				  End If
				  externalData_.Add(input.readMessage(org.nd4j.ir.TensorNamespace.StringStringEntryProto.parser(), extensionRegistry))
				Case 112
				  Dim rawValue As Integer = input.readEnum()

				  dataLocation_ = rawValue
				Case 120
				  If Not ((mutable_bitField0_ And &H100) <> 0) Then
					halfVal_ = newIntList()
					mutable_bitField0_ = mutable_bitField0_ Or &H100
				  End If
				  halfVal_.addInt(input.readInt32())
				Case 122
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H100) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					halfVal_ = newIntList()
					mutable_bitField0_ = mutable_bitField0_ Or &H100
				  End If
				  Do While input.getBytesUntilLimit() > 0
					halfVal_.addInt(input.readInt32())
				  Loop
				  input.popLimit(limit)
				Case 128
				  If Not ((mutable_bitField0_ And &H200) <> 0) Then
					boolVal_ = newBooleanList()
					mutable_bitField0_ = mutable_bitField0_ Or &H200
				  End If
				  boolVal_.addBoolean(input.readBool())
				Case 130
				  Dim length As Integer = input.readRawVarint32()
				  Dim limit As Integer = input.pushLimit(length)
				  If Not ((mutable_bitField0_ And &H200) <> 0) AndAlso input.getBytesUntilLimit() > 0 Then
					boolVal_ = newBooleanList()
					mutable_bitField0_ = mutable_bitField0_ Or &H200
				  End If
				  Do While input.getBytesUntilLimit() > 0
					boolVal_.addBoolean(input.readBool())
				  Loop
				  input.popLimit(limit)
				Case Else
				  If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					done = True
				  End If
			  End Select
			Loop
		  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Throw e.setUnfinishedMessage(Me)
		  Catch e As java.io.IOException
			Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
		  Finally
			If ((mutable_bitField0_ And &H1) <> 0) Then
			  dims_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H2) <> 0) Then
			  floatData_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H4) <> 0) Then
			  int32Data_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H8) <> 0) Then
			  stringData_ = java.util.Collections.unmodifiableList(stringData_) ' C
			End If
			If ((mutable_bitField0_ And &H10) <> 0) Then
			  int64Data_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H40) <> 0) Then
			  doubleData_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H80) <> 0) Then
			  uint64Data_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H20) <> 0) Then
			  externalData_ = java.util.Collections.unmodifiableList(externalData_)
			End If
			If ((mutable_bitField0_ And &H100) <> 0) Then
			  halfVal_.makeImmutable() ' C
			End If
			If ((mutable_bitField0_ And &H200) <> 0) Then
			  boolVal_.makeImmutable() ' C
			End If
			Me.unknownFields = unknownFields.build()
			makeExtensionsImmutable()
		  End Try
		End Sub
		Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			Get
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_descriptor
			End Get
		End Property

		Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
		  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorProto), GetType(org.nd4j.ir.TensorNamespace.TensorProto.Builder))
		End Function

		''' <summary>
		''' <pre>
		''' Location of the data for this tensor. MUST be one of:
		''' - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
		''' - EXTERNAL - data stored in an external location as described by external_data field.
		''' </pre>
		''' 
		''' Protobuf enum {@code org.nd4j.ir.TensorProto.DataLocation}
		''' </summary>
		Public NotInheritable Class DataLocation Implements org.nd4j.shade.protobuf.ProtocolMessageEnum
		  ''' <summary>
		  ''' <code>DEFAULT = 0;</code>
		  ''' </summary>
		  Public Shared ReadOnly [DEFAULT] As New DataLocation("@DEFAULT", InnerEnum.DEFAULT, 0)
		  ''' <summary>
		  ''' <code>EXTERNAL = 1;</code>
		  ''' </summary>
		  Public Shared ReadOnly EXTERNAL As New DataLocation("EXTERNAL", InnerEnum.EXTERNAL, 1)
		  Public Shared ReadOnly UNRECOGNIZED As New DataLocation("UNRECOGNIZED", InnerEnum.UNRECOGNIZED, -1)

		  Private Shared ReadOnly valueList As New List(Of DataLocation)()

		  Shared Sub New()
			  valueList.Add([DEFAULT])
			  valueList.Add(EXTERNAL)
			  valueList.Add(UNRECOGNIZED)
		  End Sub

		  Public Enum InnerEnum
			  [DEFAULT]
			  EXTERNAL
			  UNRECOGNIZED
		  End Enum

		  Public ReadOnly innerEnumValue As InnerEnum
		  Private ReadOnly nameValue As String
		  Private ReadOnly ordinalValue As Integer
		  Private Shared nextOrdinal As Integer = 0

		  ''' <summary>
		  ''' <code>DEFAULT = 0;</code>
		  ''' </summary>
		  Public Const DEFAULT_VALUE As Integer = 0
		  ''' <summary>
		  ''' <code>EXTERNAL = 1;</code>
		  ''' </summary>
		  Public Const EXTERNAL_VALUE As Integer = 1


		  Public ReadOnly Property Number As Integer
			  Get
				If Me = UNRECOGNIZED Then
				  Throw New System.ArgumentException("Can't get the number of an unknown enum value.")
				End If
				Return value
			  End Get
		  End Property

		  ''' @deprecated Use <seealso cref="forNumber(Integer)"/> instead. 
		  <Obsolete("Use <seealso cref=""forNumber(Integer)""/> instead.")>
		  Public Shared Function valueOf(ByVal value As Integer) As DataLocation
			Return forNumber(value)
		  End Function

		  Public Shared Function forNumber(ByVal value As Integer) As DataLocation
			Select Case value
			  Case 0
				  Return [DEFAULT]
			  Case 1
				  Return EXTERNAL
			  Case Else
				  Return Nothing
			End Select
		  End Function

		  Public Shared Function internalGetValueMap() As org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataLocation)
			Return internalValueMap
		  End Function
		  Friend Shared ReadOnly internalValueMap As org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataLocation) = New EnumLiteMapAnonymousInnerClass()

		  Public ReadOnly Property ValueDescriptor As org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor
			  Get
				Return getDescriptor().getValues().get(ordinal())
			  End Get
		  End Property

'JAVA TO VB CONVERTER TODO TASK: Java to VB Converter does not convert types within enums:
'		  private static class EnumLiteMapAnonymousInnerClass extends org.nd4j.shade.protobuf.Internal.EnumLiteMap(Of DataLocation)
	'	  {
	'		  public DataLocation findValueByNumber(int number)
	'		  {
	'			Return DataLocation.forNumber(number);
	'		  }
	'	  }
		  Public ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
			  Get
				Return getDescriptor()
			  End Get
		  End Property
		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.EnumDescriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.TensorProto.Descriptor.getEnumTypes().get(0)
			  End Get
		  End Property

		  Friend Shared ReadOnly VALUES() As DataLocation = values()

		  Public Shared Function valueOf(ByVal desc As org.nd4j.shade.protobuf.Descriptors.EnumValueDescriptor) As DataLocation
			If desc.getType() <> getDescriptor() Then
			  Throw New System.ArgumentException("EnumValueDescriptor is not for this type.")
			End If
			If desc.getIndex() = -1 Then
			  Return UNRECOGNIZED
			End If
			Return VALUES(desc.getIndex())
		  End Function

		  Friend ReadOnly value As Integer

		  Friend Sub New(ByVal name As String, ByVal thisInnerEnumValue As InnerEnum, ByVal outerInstance As TensorNamespace.TensorProto, ByVal value As Integer)
			  Me.outerInstance = outerInstance
			Me.value = value

			  nameValue = name
			  ordinalValue = nextOrdinal
			  nextOrdinal += 1
			  innerEnumValue = thisInnerEnumValue
		  End Sub

		  ' @@protoc_insertion_point(enum_scope:org.nd4j.ir.TensorProto.DataLocation)

			Public Shared Function values() As DataLocation()
				Return valueList.ToArray()
			End Function

			Public Function ordinal() As Integer
				Return ordinalValue
			End Function

			Public Overrides Function ToString() As String
				Return nameValue
			End Function

			Public Shared Operator =(ByVal one As DataLocation, ByVal two As DataLocation) As Boolean
				Return one.innerEnumValue = two.innerEnumValue
			End Operator

			Public Shared Operator <>(ByVal one As DataLocation, ByVal two As DataLocation) As Boolean
				Return one.innerEnumValue <> two.innerEnumValue
			End Operator

			Public Shared Function valueOf(ByVal name As String) As DataLocation
				For Each enumInstance As DataLocation In DataLocation.valueList
					If enumInstance.nameValue = name Then
						Return enumInstance
					End If
				Next
				Throw New System.ArgumentException(name)
			End Function
		End Class

		Public Interface SegmentOrBuilder
			Inherits org.nd4j.shade.protobuf.MessageOrBuilder

		  ''' <summary>
		  ''' <code>int64 begin = 1;</code>
		  ''' </summary>
		  ReadOnly Property Begin As Long

		  ''' <summary>
		  ''' <code>int64 end = 2;</code>
		  ''' </summary>
		  ReadOnly Property End As Long
		End Interface
		''' <summary>
		''' <pre>
		''' For very large tensors, we may want to store them in chunks, in which
		''' case the following fields will specify the segment that is stored in
		''' the current TensorProto.
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.TensorProto.Segment}
		''' </summary>
		Public NotInheritable Class Segment
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3
			Implements SegmentOrBuilder

		Friend Const serialVersionUID As Long = 0L
		  ' Use Segment.newBuilder() to construct.
'JAVA TO VB CONVERTER TODO TASK: Wildcard generics in constructor parameters are not converted. Move the generic type parameter and constraint to the class header:
'ORIGINAL LINE: private Segment(org.nd4j.shade.protobuf.GeneratedMessageV3.Builder<?> builder)
'JAVA TO VB CONVERTER NOTE: The parameter builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Friend Sub New(ByVal builder_Conflict As org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of T1))
			MyBase.New(builder_Conflict)
		  End Sub
		  Friend Sub New()
		  End Sub

'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
'ORIGINAL LINE: @java.lang.Override @SuppressWarnings({"unused"}) protected java.lang.Object newInstance(UnusedPrivateParameter unused)
		  Protected Friend Overrides Function newInstance(ByVal unused As UnusedPrivateParameter) As Object
			Return New Segment()
		  End Function

		  Public Overrides ReadOnly Property UnknownFields As org.nd4j.shade.protobuf.UnknownFieldSet
			  Get
				Return Me.unknownFields
			  End Get
		  End Property
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: private Segment(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Friend Sub New(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite)
			Me.New()
			If extensionRegistry Is Nothing Then
			  Throw New System.NullReferenceException()
			End If
			Dim unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet.Builder = org.nd4j.shade.protobuf.UnknownFieldSet.newBuilder()
			Try
			  Dim done As Boolean = False
			  Do While Not done
				Dim tag As Integer = input.readTag()
				Select Case tag
				  Case 0
					done = True
				  Case 8

					begin_ = input.readInt64()
				  Case 16

					end_ = input.readInt64()
				  Case Else
					If Not parseUnknownField(input, unknownFields, extensionRegistry, tag) Then
					  done = True
					End If
				End Select
			  Loop
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Throw e.setUnfinishedMessage(Me)
			Catch e As java.io.IOException
			  Throw (New org.nd4j.shade.protobuf.InvalidProtocolBufferException(e)).setUnfinishedMessage(Me)
			Finally
			  Me.unknownFields = unknownFields.build()
			  makeExtensionsImmutable()
			End Try
		  End Sub
		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorProto.Segment), GetType(org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder))
		  End Function

		  Public Const BEGIN_FIELD_NUMBER As Integer = 1
		  Friend begin_ As Long
		  ''' <summary>
		  ''' <code>int64 begin = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property Begin As Long Implements SegmentOrBuilder.getBegin
			  Get
				Return begin_
			  End Get
		  End Property

		  Public Const END_FIELD_NUMBER As Integer = 2
		  Friend end_ As Long
		  ''' <summary>
		  ''' <code>int64 end = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property End As Long Implements SegmentOrBuilder.getEnd
			  Get
				Return end_
			  End Get
		  End Property

		  Friend memoizedIsInitialized As SByte = -1
		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
				Dim isInitialized_Conflict As SByte = memoizedIsInitialized
				If isInitialized_Conflict = 1 Then
					Return True
				End If
				If isInitialized_Conflict = 0 Then
					Return False
				End If
    
				memoizedIsInitialized = 1
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		  Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
			If begin_ <> 0L Then
			  output.writeInt64(1, begin_)
			End If
			If end_ <> 0L Then
			  output.writeInt64(2, end_)
			End If
			unknownFields.writeTo(output)
		  End Sub

		  Public Overrides ReadOnly Property SerializedSize As Integer
			  Get
				Dim size As Integer = memoizedSize
				If size <> -1 Then
					Return size
				End If
    
				size = 0
				If begin_ <> 0L Then
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt64Size(1, begin_)
				End If
				If end_ <> 0L Then
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt64Size(2, end_)
				End If
				size += unknownFields.getSerializedSize()
				memoizedSize = size
				Return size
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		  Public Overrides Function Equals(ByVal obj As Object) As Boolean
			If obj Is Me Then
			 Return True
			End If
			If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TensorProto.Segment) Then
			  Return MyBase.Equals(obj)
			End If
			Dim other As org.nd4j.ir.TensorNamespace.TensorProto.Segment = DirectCast(obj, org.nd4j.ir.TensorNamespace.TensorProto.Segment)

			If Begin <> other.Begin Then
				Return False
			End If
			If [End] <> other.End Then
				Return False
			End If
			If Not unknownFields.Equals(other.unknownFields) Then
				Return False
			End If
			Return True
		  End Function

		  Public Overrides Function GetHashCode() As Integer
			If memoizedHashCode <> 0 Then
			  Return memoizedHashCode
			End If
			Dim hash As Integer = 41
			hash = (19 * hash) + Descriptor.GetHashCode()
			hash = (37 * hash) + BEGIN_FIELD_NUMBER
			hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong(Begin)
			hash = (37 * hash) + END_FIELD_NUMBER
			hash = (53 * hash) + org.nd4j.shade.protobuf.Internal.hashLong([End])
			hash = (29 * hash) + unknownFields.GetHashCode()
			memoizedHashCode = hash
			Return hash
		  End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		  Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		  End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto.Segment parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		  End Function

		  Public Overrides Function newBuilderForType() As Builder
			  Return newBuilder()
		  End Function
		  Public Shared Function newBuilder() As Builder
			Return DEFAULT_INSTANCE.toBuilder()
		  End Function
		  Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TensorProto.Segment) As Builder
			Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		  End Function
		  Public Overrides Function toBuilder() As Builder
			Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		  End Function

		  Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
			Dim builder_Conflict As New Builder(parent)
			Return builder_Conflict
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For very large tensors, we may want to store them in chunks, in which
		  ''' case the following fields will specify the segment that is stored in
		  ''' the current TensorProto.
		  ''' </pre>
		  ''' 
		  ''' Protobuf type {@code org.nd4j.ir.TensorProto.Segment}
		  ''' </summary>
		  Public NotInheritable Class Builder
			  Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			  Implements org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder

			Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor
				End Get
			End Property

			Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorProto.Segment), GetType(org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder))
			End Function

			' Construct using org.nd4j.ir.TensorNamespace.TensorProto.Segment.newBuilder()
			Friend Sub New()
			  maybeForceBuilderInitialization()
			End Sub

			Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			  MyBase.New(parent)
			  maybeForceBuilderInitialization()
			End Sub
			Friend Sub maybeForceBuilderInitialization()
			  If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			  End If
			End Sub
			Public Overrides Function clear() As Builder
			  MyBase.clear()
			  begin_ = 0L

			  end_ = 0L

			  Return Me
			End Function

			Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
				Get
				  Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_Segment_descriptor
				End Get
			End Property

			Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorProto.Segment
				Get
				  Return org.nd4j.ir.TensorNamespace.TensorProto.Segment.DefaultInstance
				End Get
			End Property

			Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			  Dim result As org.nd4j.ir.TensorNamespace.TensorProto.Segment = buildPartial()
			  If Not result.Initialized Then
				Throw newUninitializedMessageException(result)
			  End If
			  Return result
			End Function

			Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			  Dim result As New org.nd4j.ir.TensorNamespace.TensorProto.Segment(Me)
			  result.begin_ = begin_
			  result.end_ = end_
			  onBuilt()
			  Return result
			End Function

			Public Overrides Function clone() As Builder
			  Return MyBase.clone()
			End Function
			Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.setField(field, value)
			End Function
			Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			  Return MyBase.clearField(field)
			End Function
			Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			  Return MyBase.clearOneof(oneof)
			End Function
			Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			  Return MyBase.setRepeatedField(field, index, value)
			End Function
			Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			  Return MyBase.addRepeatedField(field, value)
			End Function
			Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			  If TypeOf other Is org.nd4j.ir.TensorNamespace.TensorProto.Segment Then
				Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TensorProto.Segment))
			  Else
				MyBase.mergeFrom(other)
				Return Me
			  End If
			End Function

			Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TensorProto.Segment) As Builder
			  If other Is org.nd4j.ir.TensorNamespace.TensorProto.Segment.DefaultInstance Then
				  Return Me
			  End If
			  If other.Begin <> 0L Then
				Begin = other.Begin
			  End If
			  If other.End <> 0L Then
				[End] = other.End
			  End If
			  Me.mergeUnknownFields(other.unknownFields)
			  onChanged()
			  Return Me
			End Function

			Public Overrides ReadOnly Property Initialized As Boolean
				Get
				  Return True
				End Get
			End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
			Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			  Dim parsedMessage As org.nd4j.ir.TensorNamespace.TensorProto.Segment = Nothing
			  Try
				parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			  Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
				parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TensorProto.Segment)
				Throw e.unwrapIOException()
			  Finally
				If parsedMessage IsNot Nothing Then
				  mergeFrom(parsedMessage)
				End If
			  End Try
			  Return Me
			End Function

			Friend begin_ As Long
			''' <summary>
			''' <code>int64 begin = 1;</code>
			''' </summary>
			Public ReadOnly Property Begin As Long Implements org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder.getBegin
				Get
				  Return begin_
				End Get
			End Property
			''' <summary>
			''' <code>int64 begin = 1;</code>
			''' </summary>
			Public Function setBegin(ByVal value As Long) As Builder

			  begin_ = value
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <code>int64 begin = 1;</code>
			''' </summary>
			Public Function clearBegin() As Builder

			  begin_ = 0L
			  onChanged()
			  Return Me
			End Function

			Friend end_ As Long
			''' <summary>
			''' <code>int64 end = 2;</code>
			''' </summary>
			Public ReadOnly Property End As Long Implements org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder.getEnd
				Get
				  Return end_
				End Get
			End Property
			''' <summary>
			''' <code>int64 end = 2;</code>
			''' </summary>
			Public Function setEnd(ByVal value As Long) As Builder

			  end_ = value
			  onChanged()
			  Return Me
			End Function
			''' <summary>
			''' <code>int64 end = 2;</code>
			''' </summary>
			Public Function clearEnd() As Builder

			  end_ = 0L
			  onChanged()
			  Return Me
			End Function
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.setUnknownFields(unknownFields)
			End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
			Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			  Return MyBase.mergeUnknownFields(unknownFields)
			End Function


			' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorProto.Segment)
		  End Class

		  ' @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorProto.Segment)
		  Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TensorProto.Segment
		  Shared Sub New()
			DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TensorProto.Segment()
		  End Sub

		  Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		  Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of Segment) = New AbstractParserAnonymousInnerClass()

		  Private Class AbstractParserAnonymousInnerClass
			  Inherits org.nd4j.shade.protobuf.AbstractParser(Of Segment)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Segment parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Segment
				Return New Segment(input, extensionRegistry)
			  End Function
		  End Class

		  Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of Segment)
			Return PARSER_Conflict
		  End Function

		  Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of Segment)
			  Get
				Return PARSER_Conflict
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorProto.Segment
			  Get
				Return DEFAULT_INSTANCE
			  End Get
		  End Property

		End Class

		Public Const DIMS_FIELD_NUMBER As Integer = 1
		Friend dims_ As org.nd4j.shade.protobuf.Internal.LongList
		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		Public ReadOnly Property DimsList As IList(Of Long) Implements TensorProtoOrBuilder.getDimsList
			Get
			  Return dims_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		Public ReadOnly Property DimsCount As Integer Implements TensorProtoOrBuilder.getDimsCount
			Get
			  Return dims_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' The shape of the tensor.
		''' </pre>
		''' 
		''' <code>repeated int64 dims = 1;</code>
		''' </summary>
		Public Function getDims(ByVal index As Integer) As Long Implements TensorProtoOrBuilder.getDims
		  Return dims_.getLong(index)
		End Function
		Friend dimsMemoizedSerializedSize As Integer = -1

		Public Const DATA_TYPE_FIELD_NUMBER As Integer = 2
		Friend dataType_ As Integer
		''' <summary>
		''' <pre>
		''' The data type of the tensor.
		''' This field MUST have a valid TensorProto.DataType value
		''' </pre>
		''' 
		''' <code>int32 data_type = 2;</code>
		''' </summary>
		Public ReadOnly Property DataType As Integer Implements TensorProtoOrBuilder.getDataType
			Get
			  Return dataType_
			End Get
		End Property

		Public Const SEGMENT_FIELD_NUMBER As Integer = 3
		Friend segment_ As org.nd4j.ir.TensorNamespace.TensorProto.Segment
		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		Public Function hasSegment() As Boolean Implements TensorProtoOrBuilder.hasSegment
		  Return segment_ IsNot Nothing
		End Function
		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		Public ReadOnly Property Segment As org.nd4j.ir.TensorNamespace.TensorProto.Segment Implements TensorProtoOrBuilder.getSegment
			Get
			  Return If(segment_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorProto.Segment.DefaultInstance, segment_)
			End Get
		End Property
		''' <summary>
		''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		''' </summary>
		Public ReadOnly Property SegmentOrBuilder As org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder Implements TensorProtoOrBuilder.getSegmentOrBuilder
			Get
			  Return Segment
			End Get
		End Property

		Public Const FLOAT_DATA_FIELD_NUMBER As Integer = 4
		Friend floatData_ As org.nd4j.shade.protobuf.Internal.FloatList
		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property FloatDataList As IList(Of Single) Implements TensorProtoOrBuilder.getFloatDataList
			Get
			  Return floatData_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property FloatDataCount As Integer Implements TensorProtoOrBuilder.getFloatDataCount
			Get
			  Return floatData_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For float and complex64 values
		''' Complex64 tensors are encoded as a single array of floats,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		''' </pre>
		''' 
		''' <code>repeated float float_data = 4 [packed = true];</code>
		''' </summary>
		Public Function getFloatData(ByVal index As Integer) As Single Implements TensorProtoOrBuilder.getFloatData
		  Return floatData_.getFloat(index)
		End Function
		Friend floatDataMemoizedSerializedSize As Integer = -1

		Public Const INT32_DATA_FIELD_NUMBER As Integer = 5
		Friend int32Data_ As org.nd4j.shade.protobuf.Internal.IntList
		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Int32DataList As IList(Of Integer) Implements TensorProtoOrBuilder.getInt32DataList
			Get
			  Return int32Data_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Int32DataCount As Integer Implements TensorProtoOrBuilder.getInt32DataCount
			Get
			  Return int32Data_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		''' float16 values must be bit-wise converted to an uint16_t prior
		''' to writing to the buffer.
		''' When this field is present, the data_type field MUST be
		''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		''' </pre>
		''' 
		''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		''' </summary>
		Public Function getInt32Data(ByVal index As Integer) As Integer Implements TensorProtoOrBuilder.getInt32Data
		  Return int32Data_.getInt(index)
		End Function
		Friend int32DataMemoizedSerializedSize As Integer = -1

		Public Const STRING_DATA_FIELD_NUMBER As Integer = 6
		Friend stringData_ As IList(Of org.nd4j.shade.protobuf.ByteString)
		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		Public ReadOnly Property StringDataList As IList(Of org.nd4j.shade.protobuf.ByteString) Implements TensorProtoOrBuilder.getStringDataList
			Get
			  Return stringData_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		Public ReadOnly Property StringDataCount As Integer Implements TensorProtoOrBuilder.getStringDataCount
			Get
			  Return stringData_.Count
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For strings.
		''' Each element of string_data is a UTF-8 encoded Unicode
		''' string. No trailing null, no leading BOM. The protobuf "string"
		''' scalar type is not used to match ML community conventions.
		''' When this field is present, the data_type field MUST be STRING
		''' </pre>
		''' 
		''' <code>repeated bytes string_data = 6;</code>
		''' </summary>
		Public Function getStringData(ByVal index As Integer) As org.nd4j.shade.protobuf.ByteString Implements TensorProtoOrBuilder.getStringData
		  Return stringData_(index)
		End Function

		Public Const INT64_DATA_FIELD_NUMBER As Integer = 7
		Friend int64Data_ As org.nd4j.shade.protobuf.Internal.LongList
		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Int64DataList As IList(Of Long) Implements TensorProtoOrBuilder.getInt64DataList
			Get
			  Return int64Data_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Int64DataCount As Integer Implements TensorProtoOrBuilder.getInt64DataCount
			Get
			  Return int64Data_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For int64.
		''' When this field is present, the data_type field MUST be INT64
		''' </pre>
		''' 
		''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		''' </summary>
		Public Function getInt64Data(ByVal index As Integer) As Long Implements TensorProtoOrBuilder.getInt64Data
		  Return int64Data_.getLong(index)
		End Function
		Friend int64DataMemoizedSerializedSize As Integer = -1

		Public Const NAME_FIELD_NUMBER As Integer = 8
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object name_;
		Friend name_ As Object
		''' <summary>
		''' <pre>
		''' Optionally, a name for the tensor.
		''' </pre>
		''' 
		''' <code>string name = 8;</code>
		''' </summary>
		Public ReadOnly Property Name As String Implements TensorProtoOrBuilder.getName
			Get
			  Dim ref As Object = name_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				name_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' Optionally, a name for the tensor.
		''' </pre>
		''' 
		''' <code>string name = 8;</code>
		''' </summary>
		Public ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString Implements TensorProtoOrBuilder.getNameBytes
			Get
			  Dim ref As Object = name_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				name_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Public Const DOC_STRING_FIELD_NUMBER As Integer = 12
'JAVA TO VB CONVERTER TODO TASK: There is no VB equivalent to 'volatile':
'ORIGINAL LINE: private volatile java.lang.Object docString_;
		Friend docString_ As Object
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this tensor. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 12;</code>
		''' </summary>
		Public ReadOnly Property DocString As String Implements TensorProtoOrBuilder.getDocString
			Get
			  Dim ref As Object = docString_
			  If TypeOf ref Is String Then
				Return DirectCast(ref, String)
			  Else
				Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				Dim s As String = bs.toStringUtf8()
				docString_ = s
				Return s
			  End If
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' A human-readable documentation for this tensor. Markdown is allowed.
		''' </pre>
		''' 
		''' <code>string doc_string = 12;</code>
		''' </summary>
		Public ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString Implements TensorProtoOrBuilder.getDocStringBytes
			Get
			  Dim ref As Object = docString_
			  If TypeOf ref Is String Then
				Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				docString_ = b
				Return b
			  Else
				Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
			  End If
			End Get
		End Property

		Public Const RAW_DATA_FIELD_NUMBER As Integer = 9
		Friend rawData_ As org.nd4j.shade.protobuf.ByteString
		''' <summary>
		''' <pre>
		''' Serializations can either use one of the fields above, or use this
		''' raw bytes field. The only exception is the string case, where one is
		''' required to store the content in the repeated bytes string_data field.
		''' When this raw_data field is used to store tensor value, elements MUST
		''' be stored in as fixed-width, little-endian order.
		''' Floating-point data types MUST be stored in IEEE 754 format.
		''' Complex64 elements must be written as two consecutive FLOAT values, real component first.
		''' Complex128 elements must be written as two consecutive DOUBLE values, real component first.
		''' Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
		''' Note: the advantage of specific field rather than the raw_data field is
		''' that in some cases (e.g. int data), protobuf does a better packing via
		''' variable length storage, and may lead to smaller binary footprint.
		''' When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
		''' </pre>
		''' 
		''' <code>bytes raw_data = 9;</code>
		''' </summary>
		Public ReadOnly Property RawData As org.nd4j.shade.protobuf.ByteString Implements TensorProtoOrBuilder.getRawData
			Get
			  Return rawData_
			End Get
		End Property

		Public Const EXTERNAL_DATA_FIELD_NUMBER As Integer = 13
		Friend externalData_ As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto)
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Public ReadOnly Property ExternalDataList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto) Implements TensorProtoOrBuilder.getExternalDataList
			Get
			  Return externalData_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: public java.util.List<? extends org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder> getExternalDataOrBuilderList()
		Public ReadOnly Property ExternalDataOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder) Implements TensorProtoOrBuilder.getExternalDataOrBuilderList
			Get
			  Return externalData_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Public ReadOnly Property ExternalDataCount As Integer Implements TensorProtoOrBuilder.getExternalDataCount
			Get
			  Return externalData_.Count
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Public Function getExternalData(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto Implements TensorProtoOrBuilder.getExternalData
		  Return externalData_(index)
		End Function
		''' <summary>
		''' <pre>
		''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		''' external_data stores key-value pairs describing data location. Recognized keys are:
		''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		'''                           protobuf model was stored
		''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		'''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		''' </pre>
		''' 
		''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		''' </summary>
		Public Function getExternalDataOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder Implements TensorProtoOrBuilder.getExternalDataOrBuilder
		  Return externalData_(index)
		End Function

		Public Const DATA_LOCATION_FIELD_NUMBER As Integer = 14
		Friend dataLocation_ As Integer
		''' <summary>
		''' <pre>
		''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		''' </summary>
		Public ReadOnly Property DataLocationValue As Integer Implements TensorProtoOrBuilder.getDataLocationValue
			Get
			  Return dataLocation_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		''' </pre>
		''' 
		''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		''' </summary>
		Public ReadOnly Property DataLocation As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation Implements TensorProtoOrBuilder.getDataLocation
			Get
	'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
	'ORIGINAL LINE: @SuppressWarnings("deprecation") org.nd4j.ir.TensorNamespace.TensorProto.DataLocation result = org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.valueOf(dataLocation_);
			  Dim result As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation = org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.valueOf(dataLocation_)
			  Return If(result = Nothing, org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.UNRECOGNIZED, result)
			End Get
		End Property

		Public Const DOUBLE_DATA_FIELD_NUMBER As Integer = 10
		Friend doubleData_ As org.nd4j.shade.protobuf.Internal.DoubleList
		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property DoubleDataList As IList(Of Double) Implements TensorProtoOrBuilder.getDoubleDataList
			Get
			  Return doubleData_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property DoubleDataCount As Integer Implements TensorProtoOrBuilder.getDoubleDataCount
			Get
			  Return doubleData_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For double
		''' Complex128 tensors are encoded as a single array of doubles,
		''' with the real components appearing in odd numbered positions,
		''' and the corresponding imaginary component appearing in the
		''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		''' </pre>
		''' 
		''' <code>repeated double double_data = 10 [packed = true];</code>
		''' </summary>
		Public Function getDoubleData(ByVal index As Integer) As Double Implements TensorProtoOrBuilder.getDoubleData
		  Return doubleData_.getDouble(index)
		End Function
		Friend doubleDataMemoizedSerializedSize As Integer = -1

		Public Const UINT64_DATA_FIELD_NUMBER As Integer = 11
		Friend uint64Data_ As org.nd4j.shade.protobuf.Internal.LongList
		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Uint64DataList As IList(Of Long) Implements TensorProtoOrBuilder.getUint64DataList
			Get
			  Return uint64Data_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property Uint64DataCount As Integer Implements TensorProtoOrBuilder.getUint64DataCount
			Get
			  Return uint64Data_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For uint64 and uint32 values
		''' When this field is present, the data_type field MUST be
		''' UINT32 or UINT64
		''' </pre>
		''' 
		''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		''' </summary>
		Public Function getUint64Data(ByVal index As Integer) As Long Implements TensorProtoOrBuilder.getUint64Data
		  Return uint64Data_.getLong(index)
		End Function
		Friend uint64DataMemoizedSerializedSize As Integer = -1

		Public Const HALF_VAL_FIELD_NUMBER As Integer = 15
		Friend halfVal_ As org.nd4j.shade.protobuf.Internal.IntList
		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property HalfValList As IList(Of Integer) Implements TensorProtoOrBuilder.getHalfValList
			Get
			  Return halfVal_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property HalfValCount As Integer Implements TensorProtoOrBuilder.getHalfValCount
			Get
			  Return halfVal_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' For half values (tensorflow compatibility)
		''' </pre>
		''' 
		''' <code>repeated int32 half_val = 15 [packed = true];</code>
		''' </summary>
		Public Function getHalfVal(ByVal index As Integer) As Integer Implements TensorProtoOrBuilder.getHalfVal
		  Return halfVal_.getInt(index)
		End Function
		Friend halfValMemoizedSerializedSize As Integer = -1

		Public Const BOOL_VAL_FIELD_NUMBER As Integer = 16
		Friend boolVal_ As org.nd4j.shade.protobuf.Internal.BooleanList
		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property BoolValList As IList(Of Boolean) Implements TensorProtoOrBuilder.getBoolValList
			Get
			  Return boolVal_
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		Public ReadOnly Property BoolValCount As Integer Implements TensorProtoOrBuilder.getBoolValCount
			Get
			  Return boolVal_.size()
			End Get
		End Property
		''' <summary>
		''' <pre>
		''' boolean values
		''' </pre>
		''' 
		''' <code>repeated bool bool_val = 16 [packed = true];</code>
		''' </summary>
		Public Function getBoolVal(ByVal index As Integer) As Boolean Implements TensorProtoOrBuilder.getBoolVal
		  Return boolVal_.getBoolean(index)
		End Function
		Friend boolValMemoizedSerializedSize As Integer = -1

		Friend memoizedIsInitialized As SByte = -1
		Public Overrides ReadOnly Property Initialized As Boolean
			Get
	'JAVA TO VB CONVERTER NOTE: The local variable isInitialized was renamed since Visual Basic will not allow local variables with the same name as their enclosing function or property:
			  Dim isInitialized_Conflict As SByte = memoizedIsInitialized
			  If isInitialized_Conflict = 1 Then
				  Return True
			  End If
			  If isInitialized_Conflict = 0 Then
				  Return False
			  End If
    
			  memoizedIsInitialized = 1
			  Return True
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public void writeTo(org.nd4j.shade.protobuf.CodedOutputStream output) throws java.io.IOException
		Public Overrides Sub writeTo(ByVal output As org.nd4j.shade.protobuf.CodedOutputStream)
		  SerializedSize
		  If getDimsList().Count > 0 Then
			output.writeUInt32NoTag(10)
			output.writeUInt32NoTag(dimsMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To dims_.size() - 1
			output.writeInt64NoTag(dims_.getLong(i))
		  Next i
		  If dataType_ <> 0 Then
			output.writeInt32(2, dataType_)
		  End If
		  If segment_ IsNot Nothing Then
			output.writeMessage(3, Segment)
		  End If
		  If getFloatDataList().Count > 0 Then
			output.writeUInt32NoTag(34)
			output.writeUInt32NoTag(floatDataMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To floatData_.size() - 1
			output.writeFloatNoTag(floatData_.getFloat(i))
		  Next i
		  If getInt32DataList().Count > 0 Then
			output.writeUInt32NoTag(42)
			output.writeUInt32NoTag(int32DataMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To int32Data_.size() - 1
			output.writeInt32NoTag(int32Data_.getInt(i))
		  Next i
		  For i As Integer = 0 To stringData_.Count - 1
			output.writeBytes(6, stringData_(i))
		  Next i
		  If getInt64DataList().Count > 0 Then
			output.writeUInt32NoTag(58)
			output.writeUInt32NoTag(int64DataMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To int64Data_.size() - 1
			output.writeInt64NoTag(int64Data_.getLong(i))
		  Next i
		  If Not NameBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 8, name_)
		  End If
		  If Not rawData_.isEmpty() Then
			output.writeBytes(9, rawData_)
		  End If
		  If getDoubleDataList().Count > 0 Then
			output.writeUInt32NoTag(82)
			output.writeUInt32NoTag(doubleDataMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To doubleData_.size() - 1
			output.writeDoubleNoTag(doubleData_.getDouble(i))
		  Next i
		  If getUint64DataList().Count > 0 Then
			output.writeUInt32NoTag(90)
			output.writeUInt32NoTag(uint64DataMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To uint64Data_.size() - 1
			output.writeUInt64NoTag(uint64Data_.getLong(i))
		  Next i
		  If Not DocStringBytes.isEmpty() Then
			org.nd4j.shade.protobuf.GeneratedMessageV3.writeString(output, 12, docString_)
		  End If
		  For i As Integer = 0 To externalData_.Count - 1
			output.writeMessage(13, externalData_(i))
		  Next i
		  If dataLocation_ <> org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.DEFAULT.getNumber() Then
			output.writeEnum(14, dataLocation_)
		  End If
		  If getHalfValList().Count > 0 Then
			output.writeUInt32NoTag(122)
			output.writeUInt32NoTag(halfValMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To halfVal_.size() - 1
			output.writeInt32NoTag(halfVal_.getInt(i))
		  Next i
		  If getBoolValList().Count > 0 Then
			output.writeUInt32NoTag(130)
			output.writeUInt32NoTag(boolValMemoizedSerializedSize)
		  End If
		  For i As Integer = 0 To boolVal_.size() - 1
			output.writeBoolNoTag(boolVal_.getBoolean(i))
		  Next i
		  unknownFields.writeTo(output)
		End Sub

		Public Overrides ReadOnly Property SerializedSize As Integer
			Get
			  Dim size As Integer = memoizedSize
			  If size <> -1 Then
				  Return size
			  End If
    
			  size = 0
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To dims_.size() - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeInt64SizeNoTag(dims_.getLong(i))
				Next i
				size += dataSize
				If getDimsList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				dimsMemoizedSerializedSize = dataSize
			  End If
			  If dataType_ <> 0 Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32Size(2, dataType_)
			  End If
			  If segment_ IsNot Nothing Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(3, Segment)
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				dataSize = 4 * getFloatDataList().Count
				size += dataSize
				If getFloatDataList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				floatDataMemoizedSerializedSize = dataSize
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To int32Data_.size() - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(int32Data_.getInt(i))
				Next i
				size += dataSize
				If getInt32DataList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				int32DataMemoizedSerializedSize = dataSize
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To stringData_.Count - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeBytesSizeNoTag(stringData_(i))
				Next i
				size += dataSize
				size += 1 * getStringDataList().Count
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To int64Data_.size() - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeInt64SizeNoTag(int64Data_.getLong(i))
				Next i
				size += dataSize
				If getInt64DataList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				int64DataMemoizedSerializedSize = dataSize
			  End If
			  If Not NameBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(8, name_)
			  End If
			  If Not rawData_.isEmpty() Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeBytesSize(9, rawData_)
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				dataSize = 8 * getDoubleDataList().Count
				size += dataSize
				If getDoubleDataList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				doubleDataMemoizedSerializedSize = dataSize
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To uint64Data_.size() - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeUInt64SizeNoTag(uint64Data_.getLong(i))
				Next i
				size += dataSize
				If getUint64DataList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				uint64DataMemoizedSerializedSize = dataSize
			  End If
			  If Not DocStringBytes.isEmpty() Then
				size += org.nd4j.shade.protobuf.GeneratedMessageV3.computeStringSize(12, docString_)
			  End If
			  For i As Integer = 0 To externalData_.Count - 1
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeMessageSize(13, externalData_(i))
			  Next i
			  If dataLocation_ <> org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.DEFAULT.getNumber() Then
				size += org.nd4j.shade.protobuf.CodedOutputStream.computeEnumSize(14, dataLocation_)
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				For i As Integer = 0 To halfVal_.size() - 1
				  dataSize += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(halfVal_.getInt(i))
				Next i
				size += dataSize
				If getHalfValList().Count > 0 Then
				  size += 1
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				halfValMemoizedSerializedSize = dataSize
			  End If
			  If True Then
				Dim dataSize As Integer = 0
				dataSize = 1 * getBoolValList().Count
				size += dataSize
				If getBoolValList().Count > 0 Then
				  size += 2
				  size += org.nd4j.shade.protobuf.CodedOutputStream.computeInt32SizeNoTag(dataSize)
				End If
				boolValMemoizedSerializedSize = dataSize
			  End If
			  size += unknownFields.getSerializedSize()
			  memoizedSize = size
			  Return size
			End Get
		End Property

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public boolean equals(final java.lang.Object obj)
		Public Overrides Function Equals(ByVal obj As Object) As Boolean
		  If obj Is Me Then
		   Return True
		  End If
		  If Not (TypeOf obj Is org.nd4j.ir.TensorNamespace.TensorProto) Then
			Return MyBase.Equals(obj)
		  End If
		  Dim other As org.nd4j.ir.TensorNamespace.TensorProto = DirectCast(obj, org.nd4j.ir.TensorNamespace.TensorProto)

'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getDimsList().equals(other.getDimsList()))
		  If Not getDimsList().SequenceEqual(other.getDimsList()) Then
			  Return False
		  End If
		  If DataType <> other.DataType Then
			  Return False
		  End If
		  If hasSegment() <> other.hasSegment() Then
			  Return False
		  End If
		  If hasSegment() Then
			If Not Segment.equals(other.Segment) Then
				Return False
			End If
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getFloatDataList().equals(other.getFloatDataList()))
		  If Not getFloatDataList().SequenceEqual(other.getFloatDataList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getInt32DataList().equals(other.getInt32DataList()))
		  If Not getInt32DataList().SequenceEqual(other.getInt32DataList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getStringDataList().equals(other.getStringDataList()))
		  If Not getStringDataList().SequenceEqual(other.getStringDataList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getInt64DataList().equals(other.getInt64DataList()))
		  If Not getInt64DataList().SequenceEqual(other.getInt64DataList()) Then
			  Return False
		  End If
		  If Not Name.Equals(other.Name) Then
			  Return False
		  End If
		  If Not DocString.Equals(other.DocString) Then
			  Return False
		  End If
		  If Not RawData.Equals(other.RawData) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getExternalDataList().equals(other.getExternalDataList()))
		  If Not getExternalDataList().SequenceEqual(other.getExternalDataList()) Then
			  Return False
		  End If
		  If dataLocation_ <> other.dataLocation_ Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getDoubleDataList().equals(other.getDoubleDataList()))
		  If Not getDoubleDataList().SequenceEqual(other.getDoubleDataList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getUint64DataList().equals(other.getUint64DataList()))
		  If Not getUint64DataList().SequenceEqual(other.getUint64DataList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getHalfValList().equals(other.getHalfValList()))
		  If Not getHalfValList().SequenceEqual(other.getHalfValList()) Then
			  Return False
		  End If
'JAVA TO VB CONVERTER WARNING: LINQ 'SequenceEqual' is not always identical to Java AbstractList 'equals':
'ORIGINAL LINE: if (!getBoolValList().equals(other.getBoolValList()))
		  If Not getBoolValList().SequenceEqual(other.getBoolValList()) Then
			  Return False
		  End If
		  If Not unknownFields.Equals(other.unknownFields) Then
			  Return False
		  End If
		  Return True
		End Function

		Public Overrides Function GetHashCode() As Integer
		  If memoizedHashCode <> 0 Then
			Return memoizedHashCode
		  End If
		  Dim hash As Integer = 41
		  hash = (19 * hash) + Descriptor.GetHashCode()
		  If DimsCount > 0 Then
			hash = (37 * hash) + DIMS_FIELD_NUMBER
			hash = (53 * hash) + getDimsList().GetHashCode()
		  End If
		  hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER
		  hash = (53 * hash) + DataType
		  If hasSegment() Then
			hash = (37 * hash) + SEGMENT_FIELD_NUMBER
			hash = (53 * hash) + Segment.hashCode()
		  End If
		  If FloatDataCount > 0 Then
			hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER
			hash = (53 * hash) + getFloatDataList().GetHashCode()
		  End If
		  If Int32DataCount > 0 Then
			hash = (37 * hash) + INT32_DATA_FIELD_NUMBER
			hash = (53 * hash) + getInt32DataList().GetHashCode()
		  End If
		  If StringDataCount > 0 Then
			hash = (37 * hash) + STRING_DATA_FIELD_NUMBER
			hash = (53 * hash) + getStringDataList().GetHashCode()
		  End If
		  If Int64DataCount > 0 Then
			hash = (37 * hash) + INT64_DATA_FIELD_NUMBER
			hash = (53 * hash) + getInt64DataList().GetHashCode()
		  End If
		  hash = (37 * hash) + NAME_FIELD_NUMBER
		  hash = (53 * hash) + Name.GetHashCode()
		  hash = (37 * hash) + DOC_STRING_FIELD_NUMBER
		  hash = (53 * hash) + DocString.GetHashCode()
		  hash = (37 * hash) + RAW_DATA_FIELD_NUMBER
		  hash = (53 * hash) + RawData.GetHashCode()
		  If ExternalDataCount > 0 Then
			hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER
			hash = (53 * hash) + getExternalDataList().GetHashCode()
		  End If
		  hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER
		  hash = (53 * hash) + dataLocation_
		  If DoubleDataCount > 0 Then
			hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER
			hash = (53 * hash) + getDoubleDataList().GetHashCode()
		  End If
		  If Uint64DataCount > 0 Then
			hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER
			hash = (53 * hash) + getUint64DataList().GetHashCode()
		  End If
		  If HalfValCount > 0 Then
			hash = (37 * hash) + HALF_VAL_FIELD_NUMBER
			hash = (53 * hash) + getHalfValList().GetHashCode()
		  End If
		  If BoolValCount > 0 Then
			hash = (37 * hash) + BOOL_VAL_FIELD_NUMBER
			hash = (53 * hash) + getBoolValList().GetHashCode()
		  End If
		  hash = (29 * hash) + unknownFields.GetHashCode()
		  memoizedHashCode = hash
		  Return hash
		End Function

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(java.nio.ByteBuffer data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(java.nio.ByteBuffer data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As java.nio.ByteBuffer, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(org.nd4j.shade.protobuf.ByteString data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(org.nd4j.shade.protobuf.ByteString data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data As org.nd4j.shade.protobuf.ByteString, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(byte[] data) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(byte[] data, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
		Public Shared Function parseFrom(ByVal data() As SByte, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return PARSER_Conflict.parseFrom(data, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseDelimitedFrom(java.io.InputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseDelimitedFrom(ByVal input As Stream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input)
		End Function
'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: public static org.nd4j.ir.TensorNamespace.TensorProto parseFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		Public Shared Function parseFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As org.nd4j.ir.TensorNamespace.TensorProto
		  Return org.nd4j.shade.protobuf.GeneratedMessageV3.parseWithIOException(PARSER_Conflict, input, extensionRegistry)
		End Function

		Public Overrides Function newBuilderForType() As Builder
			Return newBuilder()
		End Function
		Public Shared Function newBuilder() As Builder
		  Return DEFAULT_INSTANCE.toBuilder()
		End Function
		Public Shared Function newBuilder(ByVal prototype As org.nd4j.ir.TensorNamespace.TensorProto) As Builder
		  Return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype)
		End Function
		Public Overrides Function toBuilder() As Builder
		  Return If(Me Is DEFAULT_INSTANCE, New Builder(), (New Builder()).mergeFrom(Me))
		End Function

		Protected Friend Overrides Function newBuilderForType(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent) As Builder
'JAVA TO VB CONVERTER NOTE: The variable builder was renamed since it may cause conflicts with calls to static members of the user-defined type with this name:
		  Dim builder_Conflict As New Builder(parent)
		  Return builder_Conflict
		End Function
		''' <summary>
		''' <pre>
		''' Tensors
		''' A serialized tensor value.
		''' </pre>
		''' 
		''' Protobuf type {@code org.nd4j.ir.TensorProto}
		''' </summary>
		Public NotInheritable Class Builder
			Inherits org.nd4j.shade.protobuf.GeneratedMessageV3.Builder(Of Builder)
			Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder

		  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_descriptor
			  End Get
		  End Property

		  Protected Friend Overrides Function internalGetFieldAccessorTable() As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
			Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable.ensureFieldAccessorsInitialized(GetType(org.nd4j.ir.TensorNamespace.TensorProto), GetType(org.nd4j.ir.TensorNamespace.TensorProto.Builder))
		  End Function

		  ' Construct using org.nd4j.ir.TensorNamespace.TensorProto.newBuilder()
		  Friend Sub New()
			maybeForceBuilderInitialization()
		  End Sub

		  Friend Sub New(ByVal parent As org.nd4j.shade.protobuf.GeneratedMessageV3.BuilderParent)
			MyBase.New(parent)
			maybeForceBuilderInitialization()
		  End Sub
		  Friend Sub maybeForceBuilderInitialization()
			If org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders Then
			  getExternalDataFieldBuilder()
			End If
		  End Sub
		  Public Overrides Function clear() As Builder
			MyBase.clear()
			dims_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H1)
			dataType_ = 0

			If segmentBuilder_ Is Nothing Then
			  segment_ = Nothing
			Else
			  segment_ = Nothing
			  segmentBuilder_ = Nothing
			End If
			floatData_ = emptyFloatList()
			bitField0_ = (bitField0_ And Not &H2)
			int32Data_ = emptyIntList()
			bitField0_ = (bitField0_ And Not &H4)
			stringData_ = java.util.Collections.emptyList()
			bitField0_ = (bitField0_ And Not &H8)
			int64Data_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H10)
			name_ = ""

			docString_ = ""

			rawData_ = org.nd4j.shade.protobuf.ByteString.EMPTY

			If externalDataBuilder_ Is Nothing Then
			  externalData_ = java.util.Collections.emptyList()
			  bitField0_ = (bitField0_ And Not &H20)
			Else
			  externalDataBuilder_.clear()
			End If
			dataLocation_ = 0

			doubleData_ = emptyDoubleList()
			bitField0_ = (bitField0_ And Not &H40)
			uint64Data_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H80)
			halfVal_ = emptyIntList()
			bitField0_ = (bitField0_ And Not &H100)
			boolVal_ = emptyBooleanList()
			bitField0_ = (bitField0_ And Not &H200)
			Return Me
		  End Function

		  Public Overrides ReadOnly Property DescriptorForType As org.nd4j.shade.protobuf.Descriptors.Descriptor
			  Get
				Return org.nd4j.ir.TensorNamespace.internal_static_org_nd4j_ir_TensorProto_descriptor
			  End Get
		  End Property

		  Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorProto
			  Get
				Return org.nd4j.ir.TensorNamespace.TensorProto.DefaultInstance
			  End Get
		  End Property

		  Public Overrides Function build() As org.nd4j.ir.TensorNamespace.TensorProto
			Dim result As org.nd4j.ir.TensorNamespace.TensorProto = buildPartial()
			If Not result.Initialized Then
			  Throw newUninitializedMessageException(result)
			End If
			Return result
		  End Function

		  Public Overrides Function buildPartial() As org.nd4j.ir.TensorNamespace.TensorProto
			Dim result As New org.nd4j.ir.TensorNamespace.TensorProto(Me)
			Dim from_bitField0_ As Integer = bitField0_
			If ((bitField0_ And &H1) <> 0) Then
			  dims_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H1)
			End If
			result.dims_ = dims_
			result.dataType_ = dataType_
			If segmentBuilder_ Is Nothing Then
			  result.segment_ = segment_
			Else
			  result.segment_ = segmentBuilder_.build()
			End If
			If ((bitField0_ And &H2) <> 0) Then
			  floatData_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H2)
			End If
			result.floatData_ = floatData_
			If ((bitField0_ And &H4) <> 0) Then
			  int32Data_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H4)
			End If
			result.int32Data_ = int32Data_
			If ((bitField0_ And &H8) <> 0) Then
			  stringData_ = java.util.Collections.unmodifiableList(stringData_)
			  bitField0_ = (bitField0_ And Not &H8)
			End If
			result.stringData_ = stringData_
			If ((bitField0_ And &H10) <> 0) Then
			  int64Data_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H10)
			End If
			result.int64Data_ = int64Data_
			result.name_ = name_
			result.docString_ = docString_
			result.rawData_ = rawData_
			If externalDataBuilder_ Is Nothing Then
			  If ((bitField0_ And &H20) <> 0) Then
				externalData_ = java.util.Collections.unmodifiableList(externalData_)
				bitField0_ = (bitField0_ And Not &H20)
			  End If
			  result.externalData_ = externalData_
			Else
			  result.externalData_ = externalDataBuilder_.build()
			End If
			result.dataLocation_ = dataLocation_
			If ((bitField0_ And &H40) <> 0) Then
			  doubleData_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H40)
			End If
			result.doubleData_ = doubleData_
			If ((bitField0_ And &H80) <> 0) Then
			  uint64Data_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H80)
			End If
			result.uint64Data_ = uint64Data_
			If ((bitField0_ And &H100) <> 0) Then
			  halfVal_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H100)
			End If
			result.halfVal_ = halfVal_
			If ((bitField0_ And &H200) <> 0) Then
			  boolVal_.makeImmutable()
			  bitField0_ = (bitField0_ And Not &H200)
			End If
			result.boolVal_ = boolVal_
			onBuilt()
			Return result
		  End Function

		  Public Overrides Function clone() As Builder
			Return MyBase.clone()
		  End Function
		  Public Overrides Function setField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.setField(field, value)
		  End Function
		  Public Overrides Function clearField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor) As Builder
			Return MyBase.clearField(field)
		  End Function
		  Public Overrides Function clearOneof(ByVal oneof As org.nd4j.shade.protobuf.Descriptors.OneofDescriptor) As Builder
			Return MyBase.clearOneof(oneof)
		  End Function
		  Public Overrides Function setRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal index As Integer, ByVal value As Object) As Builder
			Return MyBase.setRepeatedField(field, index, value)
		  End Function
		  Public Overrides Function addRepeatedField(ByVal field As org.nd4j.shade.protobuf.Descriptors.FieldDescriptor, ByVal value As Object) As Builder
			Return MyBase.addRepeatedField(field, value)
		  End Function
		  Public Overrides Function mergeFrom(ByVal other As org.nd4j.shade.protobuf.Message) As Builder
			If TypeOf other Is org.nd4j.ir.TensorNamespace.TensorProto Then
			  Return mergeFrom(CType(other, org.nd4j.ir.TensorNamespace.TensorProto))
			Else
			  MyBase.mergeFrom(other)
			  Return Me
			End If
		  End Function

		  Public Function mergeFrom(ByVal other As org.nd4j.ir.TensorNamespace.TensorProto) As Builder
			If other Is org.nd4j.ir.TensorNamespace.TensorProto.DefaultInstance Then
				Return Me
			End If
			If Not other.dims_.isEmpty() Then
			  If dims_.isEmpty() Then
				dims_ = other.dims_
				bitField0_ = (bitField0_ And Not &H1)
			  Else
				ensureDimsIsMutable()
				dims_.addAll(other.dims_)
			  End If
			  onChanged()
			End If
			If other.DataType <> 0 Then
			  DataType = other.DataType
			End If
			If other.hasSegment() Then
			  mergeSegment(other.Segment)
			End If
			If Not other.floatData_.isEmpty() Then
			  If floatData_.isEmpty() Then
				floatData_ = other.floatData_
				bitField0_ = (bitField0_ And Not &H2)
			  Else
				ensureFloatDataIsMutable()
				floatData_.addAll(other.floatData_)
			  End If
			  onChanged()
			End If
			If Not other.int32Data_.isEmpty() Then
			  If int32Data_.isEmpty() Then
				int32Data_ = other.int32Data_
				bitField0_ = (bitField0_ And Not &H4)
			  Else
				ensureInt32DataIsMutable()
				int32Data_.addAll(other.int32Data_)
			  End If
			  onChanged()
			End If
			If other.stringData_.Count > 0 Then
			  If stringData_.Count = 0 Then
				stringData_ = other.stringData_
				bitField0_ = (bitField0_ And Not &H8)
			  Else
				ensureStringDataIsMutable()
				CType(stringData_, List(Of org.nd4j.shade.protobuf.ByteString)).AddRange(other.stringData_)
			  End If
			  onChanged()
			End If
			If Not other.int64Data_.isEmpty() Then
			  If int64Data_.isEmpty() Then
				int64Data_ = other.int64Data_
				bitField0_ = (bitField0_ And Not &H10)
			  Else
				ensureInt64DataIsMutable()
				int64Data_.addAll(other.int64Data_)
			  End If
			  onChanged()
			End If
			If other.Name.Length > 0 Then
			  name_ = other.name_
			  onChanged()
			End If
			If other.DocString.Length > 0 Then
			  docString_ = other.docString_
			  onChanged()
			End If
			If other.RawData <> org.nd4j.shade.protobuf.ByteString.EMPTY Then
			  RawData = other.RawData
			End If
			If externalDataBuilder_ Is Nothing Then
			  If other.externalData_.Count > 0 Then
				If externalData_.Count = 0 Then
				  externalData_ = other.externalData_
				  bitField0_ = (bitField0_ And Not &H20)
				Else
				  ensureExternalDataIsMutable()
				  CType(externalData_, List(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto)).AddRange(other.externalData_)
				End If
				onChanged()
			  End If
			Else
			  If other.externalData_.Count > 0 Then
				If externalDataBuilder_.isEmpty() Then
				  externalDataBuilder_.dispose()
				  externalDataBuilder_ = Nothing
				  externalData_ = other.externalData_
				  bitField0_ = (bitField0_ And Not &H20)
				  externalDataBuilder_ = If(org.nd4j.shade.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders, getExternalDataFieldBuilder(), Nothing)
				Else
				  externalDataBuilder_.addAllMessages(other.externalData_)
				End If
			  End If
			End If
			If other.dataLocation_ <> 0 Then
			  DataLocationValue = other.DataLocationValue
			End If
			If Not other.doubleData_.isEmpty() Then
			  If doubleData_.isEmpty() Then
				doubleData_ = other.doubleData_
				bitField0_ = (bitField0_ And Not &H40)
			  Else
				ensureDoubleDataIsMutable()
				doubleData_.addAll(other.doubleData_)
			  End If
			  onChanged()
			End If
			If Not other.uint64Data_.isEmpty() Then
			  If uint64Data_.isEmpty() Then
				uint64Data_ = other.uint64Data_
				bitField0_ = (bitField0_ And Not &H80)
			  Else
				ensureUint64DataIsMutable()
				uint64Data_.addAll(other.uint64Data_)
			  End If
			  onChanged()
			End If
			If Not other.halfVal_.isEmpty() Then
			  If halfVal_.isEmpty() Then
				halfVal_ = other.halfVal_
				bitField0_ = (bitField0_ And Not &H100)
			  Else
				ensureHalfValIsMutable()
				halfVal_.addAll(other.halfVal_)
			  End If
			  onChanged()
			End If
			If Not other.boolVal_.isEmpty() Then
			  If boolVal_.isEmpty() Then
				boolVal_ = other.boolVal_
				bitField0_ = (bitField0_ And Not &H200)
			  Else
				ensureBoolValIsMutable()
				boolVal_.addAll(other.boolVal_)
			  End If
			  onChanged()
			End If
			Me.mergeUnknownFields(other.unknownFields)
			onChanged()
			Return Me
		  End Function

		  Public Overrides ReadOnly Property Initialized As Boolean
			  Get
				Return True
			  End Get
		  End Property

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public Builder mergeFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
		  Public Overrides Function mergeFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As Builder
			Dim parsedMessage As org.nd4j.ir.TensorNamespace.TensorProto = Nothing
			Try
			  parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry)
			Catch e As org.nd4j.shade.protobuf.InvalidProtocolBufferException
			  parsedMessage = CType(e.getUnfinishedMessage(), org.nd4j.ir.TensorNamespace.TensorProto)
			  Throw e.unwrapIOException()
			Finally
			  If parsedMessage IsNot Nothing Then
				mergeFrom(parsedMessage)
			  End If
			End Try
			Return Me
		  End Function
		  Friend bitField0_ As Integer

		  Friend dims_ As org.nd4j.shade.protobuf.Internal.LongList = emptyLongList()
		  Friend Sub ensureDimsIsMutable()
			If Not ((bitField0_ And &H1) <> 0) Then
			  dims_ = mutableCopy(dims_)
			  bitField0_ = bitField0_ Or &H1
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimsList As IList(Of Long) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDimsList
			  Get
				Return If((bitField0_ And &H1) <> 0, java.util.Collections.unmodifiableList(dims_), dims_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public ReadOnly Property DimsCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDimsCount
			  Get
				Return dims_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public Function getDims(ByVal index As Integer) As Long Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDims
			Return dims_.getLong(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public Function setDims(ByVal index As Integer, ByVal value As Long) As Builder
			ensureDimsIsMutable()
			dims_.setLong(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public Function addDims(ByVal value As Long) As Builder
			ensureDimsIsMutable()
			dims_.addLong(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public Function addAllDims(Of T1 As Long)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureDimsIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, dims_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The shape of the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 dims = 1;</code>
		  ''' </summary>
		  Public Function clearDims() As Builder
			dims_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H1)
			onChanged()
			Return Me
		  End Function

		  Friend dataType_ As Integer
		  ''' <summary>
		  ''' <pre>
		  ''' The data type of the tensor.
		  ''' This field MUST have a valid TensorProto.DataType value
		  ''' </pre>
		  ''' 
		  ''' <code>int32 data_type = 2;</code>
		  ''' </summary>
		  Public ReadOnly Property DataType As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDataType
			  Get
				Return dataType_
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' The data type of the tensor.
		  ''' This field MUST have a valid TensorProto.DataType value
		  ''' </pre>
		  ''' 
		  ''' <code>int32 data_type = 2;</code>
		  ''' </summary>
		  Public Function setDataType(ByVal value As Integer) As Builder

			dataType_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' The data type of the tensor.
		  ''' This field MUST have a valid TensorProto.DataType value
		  ''' </pre>
		  ''' 
		  ''' <code>int32 data_type = 2;</code>
		  ''' </summary>
		  Public Function clearDataType() As Builder

			dataType_ = 0
			onChanged()
			Return Me
		  End Function

		  Friend segment_ As org.nd4j.ir.TensorNamespace.TensorProto.Segment
		  Friend segmentBuilder_ As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorProto.Segment, org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder, org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder)
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public Function hasSegment() As Boolean Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.hasSegment
			Return segmentBuilder_ IsNot Nothing OrElse segment_ IsNot Nothing
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public ReadOnly Property Segment As org.nd4j.ir.TensorNamespace.TensorProto.Segment Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getSegment
			  Get
				If segmentBuilder_ Is Nothing Then
				  Return If(segment_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorProto.Segment.DefaultInstance, segment_)
				Else
				  Return segmentBuilder_.getMessage()
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public Function setSegment(ByVal value As org.nd4j.ir.TensorNamespace.TensorProto.Segment) As Builder
			If segmentBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  segment_ = value
			  onChanged()
			Else
			  segmentBuilder_.setMessage(value)
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public Function setSegment(ByVal builderForValue As org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder) As Builder
			If segmentBuilder_ Is Nothing Then
			  segment_ = builderForValue.build()
			  onChanged()
			Else
			  segmentBuilder_.setMessage(builderForValue.build())
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public Function mergeSegment(ByVal value As org.nd4j.ir.TensorNamespace.TensorProto.Segment) As Builder
			If segmentBuilder_ Is Nothing Then
			  If segment_ IsNot Nothing Then
				segment_ = org.nd4j.ir.TensorNamespace.TensorProto.Segment.newBuilder(segment_).mergeFrom(value).buildPartial()
			  Else
				segment_ = value
			  End If
			  onChanged()
			Else
			  segmentBuilder_.mergeFrom(value)
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public Function clearSegment() As Builder
			If segmentBuilder_ Is Nothing Then
			  segment_ = Nothing
			  onChanged()
			Else
			  segment_ = Nothing
			  segmentBuilder_ = Nothing
			End If

			Return Me
		  End Function
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public ReadOnly Property SegmentBuilder As org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder
			  Get
    
				onChanged()
				Return getSegmentFieldBuilder().getBuilder()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Public ReadOnly Property SegmentOrBuilder As org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getSegmentOrBuilder
			  Get
				If segmentBuilder_ IsNot Nothing Then
				  Return segmentBuilder_.getMessageOrBuilder()
				Else
				  Return If(segment_ Is Nothing, org.nd4j.ir.TensorNamespace.TensorProto.Segment.DefaultInstance, segment_)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <code>.org.nd4j.ir.TensorProto.Segment segment = 3;</code>
		  ''' </summary>
		  Friend ReadOnly Property SegmentFieldBuilder As org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorProto.Segment, org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder, org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder)
			  Get
				If segmentBuilder_ Is Nothing Then
				  segmentBuilder_ = New org.nd4j.shade.protobuf.SingleFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.TensorProto.Segment, org.nd4j.ir.TensorNamespace.TensorProto.Segment.Builder, org.nd4j.ir.TensorNamespace.TensorProto.SegmentOrBuilder)(getSegment(), getParentForChildren(), isClean())
				  segment_ = Nothing
				End If
				Return segmentBuilder_
			  End Get
		  End Property

		  Friend floatData_ As org.nd4j.shade.protobuf.Internal.FloatList = emptyFloatList()
		  Friend Sub ensureFloatDataIsMutable()
			If Not ((bitField0_ And &H2) <> 0) Then
			  floatData_ = mutableCopy(floatData_)
			  bitField0_ = bitField0_ Or &H2
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property FloatDataList As IList(Of Single) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getFloatDataList
			  Get
				Return If((bitField0_ And &H2) <> 0, java.util.Collections.unmodifiableList(floatData_), floatData_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property FloatDataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getFloatDataCount
			  Get
				Return floatData_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public Function getFloatData(ByVal index As Integer) As Single Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getFloatData
			Return floatData_.getFloat(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public Function setFloatData(ByVal index As Integer, ByVal value As Single) As Builder
			ensureFloatDataIsMutable()
			floatData_.setFloat(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public Function addFloatData(ByVal value As Single) As Builder
			ensureFloatDataIsMutable()
			floatData_.addFloat(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllFloatData(Of T1 As Single)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureFloatDataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, floatData_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For float and complex64 values
		  ''' Complex64 tensors are encoded as a single array of floats,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated float float_data = 4 [packed = true];</code>
		  ''' </summary>
		  Public Function clearFloatData() As Builder
			floatData_ = emptyFloatList()
			bitField0_ = (bitField0_ And Not &H2)
			onChanged()
			Return Me
		  End Function

		  Friend int32Data_ As org.nd4j.shade.protobuf.Internal.IntList = emptyIntList()
		  Friend Sub ensureInt32DataIsMutable()
			If Not ((bitField0_ And &H4) <> 0) Then
			  int32Data_ = mutableCopy(int32Data_)
			  bitField0_ = bitField0_ Or &H4
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Int32DataList As IList(Of Integer) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt32DataList
			  Get
				Return If((bitField0_ And &H4) <> 0, java.util.Collections.unmodifiableList(int32Data_), int32Data_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Int32DataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt32DataCount
			  Get
				Return int32Data_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public Function getInt32Data(ByVal index As Integer) As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt32Data
			Return int32Data_.getInt(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public Function setInt32Data(ByVal index As Integer, ByVal value As Integer) As Builder
			ensureInt32DataIsMutable()
			int32Data_.setInt(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public Function addInt32Data(ByVal value As Integer) As Builder
			ensureInt32DataIsMutable()
			int32Data_.addInt(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllInt32Data(Of T1 As Integer)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureInt32DataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, int32Data_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int32, uint8, int8, uint16, int16, bool, and float16 values
		  ''' float16 values must be bit-wise converted to an uint16_t prior
		  ''' to writing to the buffer.
		  ''' When this field is present, the data_type field MUST be
		  ''' INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 int32_data = 5 [packed = true];</code>
		  ''' </summary>
		  Public Function clearInt32Data() As Builder
			int32Data_ = emptyIntList()
			bitField0_ = (bitField0_ And Not &H4)
			onChanged()
			Return Me
		  End Function

		  Friend stringData_ As IList(Of org.nd4j.shade.protobuf.ByteString) = java.util.Collections.emptyList()
		  Friend Sub ensureStringDataIsMutable()
			If Not ((bitField0_ And &H8) <> 0) Then
			  stringData_ = New List(Of org.nd4j.shade.protobuf.ByteString)(stringData_)
			  bitField0_ = bitField0_ Or &H8
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public ReadOnly Property StringDataList As IList(Of org.nd4j.shade.protobuf.ByteString) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getStringDataList
			  Get
				Return If((bitField0_ And &H8) <> 0, java.util.Collections.unmodifiableList(stringData_), stringData_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public ReadOnly Property StringDataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getStringDataCount
			  Get
				Return stringData_.Count
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public Function getStringData(ByVal index As Integer) As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getStringData
			Return stringData_(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public Function setStringData(ByVal index As Integer, ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  ensureStringDataIsMutable()
			stringData_(index) = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public Function addStringData(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  ensureStringDataIsMutable()
			stringData_.Add(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public Function addAllStringData(Of T1 As org.nd4j.shade.protobuf.ByteString)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureStringDataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, stringData_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For strings.
		  ''' Each element of string_data is a UTF-8 encoded Unicode
		  ''' string. No trailing null, no leading BOM. The protobuf "string"
		  ''' scalar type is not used to match ML community conventions.
		  ''' When this field is present, the data_type field MUST be STRING
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bytes string_data = 6;</code>
		  ''' </summary>
		  Public Function clearStringData() As Builder
			stringData_ = java.util.Collections.emptyList()
			bitField0_ = (bitField0_ And Not &H8)
			onChanged()
			Return Me
		  End Function

		  Friend int64Data_ As org.nd4j.shade.protobuf.Internal.LongList = emptyLongList()
		  Friend Sub ensureInt64DataIsMutable()
			If Not ((bitField0_ And &H10) <> 0) Then
			  int64Data_ = mutableCopy(int64Data_)
			  bitField0_ = bitField0_ Or &H10
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Int64DataList As IList(Of Long) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt64DataList
			  Get
				Return If((bitField0_ And &H10) <> 0, java.util.Collections.unmodifiableList(int64Data_), int64Data_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Int64DataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt64DataCount
			  Get
				Return int64Data_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public Function getInt64Data(ByVal index As Integer) As Long Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getInt64Data
			Return int64Data_.getLong(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public Function setInt64Data(ByVal index As Integer, ByVal value As Long) As Builder
			ensureInt64DataIsMutable()
			int64Data_.setLong(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public Function addInt64Data(ByVal value As Long) As Builder
			ensureInt64DataIsMutable()
			int64Data_.addLong(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllInt64Data(Of T1 As Long)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureInt64DataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, int64Data_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For int64.
		  ''' When this field is present, the data_type field MUST be INT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int64 int64_data = 7 [packed = true];</code>
		  ''' </summary>
		  Public Function clearInt64Data() As Builder
			int64Data_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H10)
			onChanged()
			Return Me
		  End Function

		  Friend name_ As Object = ""
		  ''' <summary>
		  ''' <pre>
		  ''' Optionally, a name for the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 8;</code>
		  ''' </summary>
		  Public ReadOnly Property Name As String Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getName
			  Get
				Dim ref As Object = name_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  name_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Optionally, a name for the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 8;</code>
		  ''' </summary>
		  Public ReadOnly Property NameBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getNameBytes
			  Get
				Dim ref As Object = name_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  name_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Optionally, a name for the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 8;</code>
		  ''' </summary>
		  Public Function setName(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			name_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Optionally, a name for the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 8;</code>
		  ''' </summary>
		  Public Function clearName() As Builder

			name_ = DefaultInstance.Name
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Optionally, a name for the tensor.
		  ''' </pre>
		  ''' 
		  ''' <code>string name = 8;</code>
		  ''' </summary>
		  Public Function setNameBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			name_ = value
			onChanged()
			Return Me
		  End Function

		  Friend docString_ As Object = ""
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this tensor. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 12;</code>
		  ''' </summary>
		  Public ReadOnly Property DocString As String Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDocString
			  Get
				Dim ref As Object = docString_
				If Not (TypeOf ref Is String) Then
				  Dim bs As org.nd4j.shade.protobuf.ByteString = DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				  Dim s As String = bs.toStringUtf8()
				  docString_ = s
				  Return s
				Else
				  Return DirectCast(ref, String)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this tensor. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 12;</code>
		  ''' </summary>
		  Public ReadOnly Property DocStringBytes As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDocStringBytes
			  Get
				Dim ref As Object = docString_
				If TypeOf ref Is String Then
				  Dim b As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.copyFromUtf8(DirectCast(ref, String))
				  docString_ = b
				  Return b
				Else
				  Return DirectCast(ref, org.nd4j.shade.protobuf.ByteString)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this tensor. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 12;</code>
		  ''' </summary>
		  Public Function setDocString(ByVal value As String) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			docString_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this tensor. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 12;</code>
		  ''' </summary>
		  Public Function clearDocString() As Builder

			docString_ = DefaultInstance.DocString
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' A human-readable documentation for this tensor. Markdown is allowed.
		  ''' </pre>
		  ''' 
		  ''' <code>string doc_string = 12;</code>
		  ''' </summary>
		  Public Function setDocStringBytes(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If
	  checkByteStringIsUtf8(value)

			docString_ = value
			onChanged()
			Return Me
		  End Function

		  Friend rawData_ As org.nd4j.shade.protobuf.ByteString = org.nd4j.shade.protobuf.ByteString.EMPTY
		  ''' <summary>
		  ''' <pre>
		  ''' Serializations can either use one of the fields above, or use this
		  ''' raw bytes field. The only exception is the string case, where one is
		  ''' required to store the content in the repeated bytes string_data field.
		  ''' When this raw_data field is used to store tensor value, elements MUST
		  ''' be stored in as fixed-width, little-endian order.
		  ''' Floating-point data types MUST be stored in IEEE 754 format.
		  ''' Complex64 elements must be written as two consecutive FLOAT values, real component first.
		  ''' Complex128 elements must be written as two consecutive DOUBLE values, real component first.
		  ''' Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
		  ''' Note: the advantage of specific field rather than the raw_data field is
		  ''' that in some cases (e.g. int data), protobuf does a better packing via
		  ''' variable length storage, and may lead to smaller binary footprint.
		  ''' When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
		  ''' </pre>
		  ''' 
		  ''' <code>bytes raw_data = 9;</code>
		  ''' </summary>
		  Public ReadOnly Property RawData As org.nd4j.shade.protobuf.ByteString Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getRawData
			  Get
				Return rawData_
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Serializations can either use one of the fields above, or use this
		  ''' raw bytes field. The only exception is the string case, where one is
		  ''' required to store the content in the repeated bytes string_data field.
		  ''' When this raw_data field is used to store tensor value, elements MUST
		  ''' be stored in as fixed-width, little-endian order.
		  ''' Floating-point data types MUST be stored in IEEE 754 format.
		  ''' Complex64 elements must be written as two consecutive FLOAT values, real component first.
		  ''' Complex128 elements must be written as two consecutive DOUBLE values, real component first.
		  ''' Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
		  ''' Note: the advantage of specific field rather than the raw_data field is
		  ''' that in some cases (e.g. int data), protobuf does a better packing via
		  ''' variable length storage, and may lead to smaller binary footprint.
		  ''' When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
		  ''' </pre>
		  ''' 
		  ''' <code>bytes raw_data = 9;</code>
		  ''' </summary>
		  Public Function setRawData(ByVal value As org.nd4j.shade.protobuf.ByteString) As Builder
			If value Is Nothing Then
		Throw New System.NullReferenceException()
			End If

			rawData_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Serializations can either use one of the fields above, or use this
		  ''' raw bytes field. The only exception is the string case, where one is
		  ''' required to store the content in the repeated bytes string_data field.
		  ''' When this raw_data field is used to store tensor value, elements MUST
		  ''' be stored in as fixed-width, little-endian order.
		  ''' Floating-point data types MUST be stored in IEEE 754 format.
		  ''' Complex64 elements must be written as two consecutive FLOAT values, real component first.
		  ''' Complex128 elements must be written as two consecutive DOUBLE values, real component first.
		  ''' Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
		  ''' Note: the advantage of specific field rather than the raw_data field is
		  ''' that in some cases (e.g. int data), protobuf does a better packing via
		  ''' variable length storage, and may lead to smaller binary footprint.
		  ''' When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
		  ''' </pre>
		  ''' 
		  ''' <code>bytes raw_data = 9;</code>
		  ''' </summary>
		  Public Function clearRawData() As Builder

			rawData_ = DefaultInstance.RawData
			onChanged()
			Return Me
		  End Function

		  Friend externalData_ As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto) = java.util.Collections.emptyList()
		  Friend Sub ensureExternalDataIsMutable()
			If Not ((bitField0_ And &H20) <> 0) Then
			  externalData_ = New List(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto)(externalData_)
			  bitField0_ = bitField0_ Or &H20
			End If
		  End Sub

		  Friend externalDataBuilder_ As org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto, org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder, org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder)

		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public ReadOnly Property ExternalDataList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getExternalDataList
			  Get
				If externalDataBuilder_ Is Nothing Then
				  Return java.util.Collections.unmodifiableList(externalData_)
				Else
				  Return externalDataBuilder_.getMessageList()
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public ReadOnly Property ExternalDataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getExternalDataCount
			  Get
				If externalDataBuilder_ Is Nothing Then
				  Return externalData_.Count
				Else
				  Return externalDataBuilder_.getCount()
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function getExternalData(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getExternalData
			If externalDataBuilder_ Is Nothing Then
			  Return externalData_(index)
			Else
			  Return externalDataBuilder_.getMessage(index)
			End If
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function setExternalData(ByVal index As Integer, ByVal value As org.nd4j.ir.TensorNamespace.StringStringEntryProto) As Builder
			If externalDataBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureExternalDataIsMutable()
			  externalData_(index) = value
			  onChanged()
			Else
			  externalDataBuilder_.setMessage(index, value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function setExternalData(ByVal index As Integer, ByVal builderForValue As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder) As Builder
			If externalDataBuilder_ Is Nothing Then
			  ensureExternalDataIsMutable()
			  externalData_(index) = builderForValue.build()
			  onChanged()
			Else
			  externalDataBuilder_.setMessage(index, builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalData(ByVal value As org.nd4j.ir.TensorNamespace.StringStringEntryProto) As Builder
			If externalDataBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureExternalDataIsMutable()
			  externalData_.Add(value)
			  onChanged()
			Else
			  externalDataBuilder_.addMessage(value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalData(ByVal index As Integer, ByVal value As org.nd4j.ir.TensorNamespace.StringStringEntryProto) As Builder
			If externalDataBuilder_ Is Nothing Then
			  If value Is Nothing Then
				Throw New System.NullReferenceException()
			  End If
			  ensureExternalDataIsMutable()
			  externalData_.Insert(index, value)
			  onChanged()
			Else
			  externalDataBuilder_.addMessage(index, value)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalData(ByVal builderForValue As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder) As Builder
			If externalDataBuilder_ Is Nothing Then
			  ensureExternalDataIsMutable()
			  externalData_.Add(builderForValue.build())
			  onChanged()
			Else
			  externalDataBuilder_.addMessage(builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalData(ByVal index As Integer, ByVal builderForValue As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder) As Builder
			If externalDataBuilder_ Is Nothing Then
			  ensureExternalDataIsMutable()
			  externalData_.Insert(index, builderForValue.build())
			  onChanged()
			Else
			  externalDataBuilder_.addMessage(index, builderForValue.build())
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addAllExternalData(Of T1 As org.nd4j.ir.TensorNamespace.StringStringEntryProto)(ByVal values As IEnumerable(Of T1)) As Builder
			If externalDataBuilder_ Is Nothing Then
			  ensureExternalDataIsMutable()
			  org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, externalData_)
			  onChanged()
			Else
			  externalDataBuilder_.addAllMessages(values)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function clearExternalData() As Builder
			If externalDataBuilder_ Is Nothing Then
			  externalData_ = java.util.Collections.emptyList()
			  bitField0_ = (bitField0_ And Not &H20)
			  onChanged()
			Else
			  externalDataBuilder_.clear()
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function removeExternalData(ByVal index As Integer) As Builder
			If externalDataBuilder_ Is Nothing Then
			  ensureExternalDataIsMutable()
			  externalData_.RemoveAt(index)
			  onChanged()
			Else
			  externalDataBuilder_.remove(index)
			End If
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function getExternalDataBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder
			Return getExternalDataFieldBuilder().getBuilder(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function getExternalDataOrBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getExternalDataOrBuilder
			If externalDataBuilder_ Is Nothing Then
			  Return externalData_(index)
			Else
			  Return externalDataBuilder_.getMessageOrBuilder(index)
			End If
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
'JAVA TO VB CONVERTER WARNING: Java wildcard generics have no direct equivalent in VB:
'ORIGINAL LINE: public java.util.List<? extends org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder> getExternalDataOrBuilderList()
		  Public ReadOnly Property ExternalDataOrBuilderList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getExternalDataOrBuilderList
			  Get
				If externalDataBuilder_ IsNot Nothing Then
				  Return externalDataBuilder_.getMessageOrBuilderList()
				Else
				  Return java.util.Collections.unmodifiableList(externalData_)
				End If
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalDataBuilder() As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder
			Return getExternalDataFieldBuilder().addBuilder(org.nd4j.ir.TensorNamespace.StringStringEntryProto.DefaultInstance)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public Function addExternalDataBuilder(ByVal index As Integer) As org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder
			Return getExternalDataFieldBuilder().addBuilder(index, org.nd4j.ir.TensorNamespace.StringStringEntryProto.DefaultInstance)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' Data can be stored inside the protobuf file using type-specific fields or raw_data.
		  ''' Alternatively, raw bytes data can be stored in an external file, using the external_data field.
		  ''' external_data stores key-value pairs describing data location. Recognized keys are:
		  ''' - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
		  '''                           protobuf model was stored
		  ''' - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
		  '''                         Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
		  ''' - "length" (optional) - number of bytes containing data. Integer stored as string.
		  ''' - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
		  ''' </pre>
		  ''' 
		  ''' <code>repeated .org.nd4j.ir.StringStringEntryProto external_data = 13;</code>
		  ''' </summary>
		  Public ReadOnly Property ExternalDataBuilderList As IList(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder)
			  Get
				Return getExternalDataFieldBuilder().getBuilderList()
			  End Get
		  End Property
		  Friend ReadOnly Property ExternalDataFieldBuilder As org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto, org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder, org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder)
			  Get
				If externalDataBuilder_ Is Nothing Then
				  externalDataBuilder_ = New org.nd4j.shade.protobuf.RepeatedFieldBuilderV3(Of org.nd4j.ir.TensorNamespace.StringStringEntryProto, org.nd4j.ir.TensorNamespace.StringStringEntryProto.Builder, org.nd4j.ir.TensorNamespace.StringStringEntryProtoOrBuilder)(externalData_, ((bitField0_ And &H20) <> 0), getParentForChildren(), isClean())
				  externalData_ = Nothing
				End If
				Return externalDataBuilder_
			  End Get
		  End Property

		  Friend dataLocation_ As Integer = 0
		  ''' <summary>
		  ''' <pre>
		  ''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		  ''' </summary>
		  Public ReadOnly Property DataLocationValue As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDataLocationValue
			  Get
				Return dataLocation_
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		  ''' </summary>
		  Public Function setDataLocationValue(ByVal value As Integer) As Builder
			dataLocation_ = value
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		  ''' </summary>
		  Public ReadOnly Property DataLocation As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDataLocation
			  Get
	'JAVA TO VB CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
	'ORIGINAL LINE: @SuppressWarnings("deprecation") org.nd4j.ir.TensorNamespace.TensorProto.DataLocation result = org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.valueOf(dataLocation_);
				Dim result As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation = org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.valueOf(dataLocation_)
				Return If(result = Nothing, org.nd4j.ir.TensorNamespace.TensorProto.DataLocation.UNRECOGNIZED, result)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		  ''' </summary>
		  Public Function setDataLocation(ByVal value As org.nd4j.ir.TensorNamespace.TensorProto.DataLocation) As Builder
			If value = Nothing Then
			  Throw New System.NullReferenceException()
			End If

			dataLocation_ = value.getNumber()
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
		  ''' </pre>
		  ''' 
		  ''' <code>.org.nd4j.ir.TensorProto.DataLocation data_location = 14;</code>
		  ''' </summary>
		  Public Function clearDataLocation() As Builder

			dataLocation_ = 0
			onChanged()
			Return Me
		  End Function

		  Friend doubleData_ As org.nd4j.shade.protobuf.Internal.DoubleList = emptyDoubleList()
		  Friend Sub ensureDoubleDataIsMutable()
			If Not ((bitField0_ And &H40) <> 0) Then
			  doubleData_ = mutableCopy(doubleData_)
			  bitField0_ = bitField0_ Or &H40
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property DoubleDataList As IList(Of Double) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDoubleDataList
			  Get
				Return If((bitField0_ And &H40) <> 0, java.util.Collections.unmodifiableList(doubleData_), doubleData_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property DoubleDataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDoubleDataCount
			  Get
				Return doubleData_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public Function getDoubleData(ByVal index As Integer) As Double Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getDoubleData
			Return doubleData_.getDouble(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public Function setDoubleData(ByVal index As Integer, ByVal value As Double) As Builder
			ensureDoubleDataIsMutable()
			doubleData_.setDouble(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public Function addDoubleData(ByVal value As Double) As Builder
			ensureDoubleDataIsMutable()
			doubleData_.addDouble(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllDoubleData(Of T1 As Double)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureDoubleDataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, doubleData_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For double
		  ''' Complex128 tensors are encoded as a single array of doubles,
		  ''' with the real components appearing in odd numbered positions,
		  ''' and the corresponding imaginary component appearing in the
		  ''' subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
		  ''' is encoded as [1.0, 2.0 ,3.0 ,4.0]
		  ''' When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
		  ''' </pre>
		  ''' 
		  ''' <code>repeated double double_data = 10 [packed = true];</code>
		  ''' </summary>
		  Public Function clearDoubleData() As Builder
			doubleData_ = emptyDoubleList()
			bitField0_ = (bitField0_ And Not &H40)
			onChanged()
			Return Me
		  End Function

		  Friend uint64Data_ As org.nd4j.shade.protobuf.Internal.LongList = emptyLongList()
		  Friend Sub ensureUint64DataIsMutable()
			If Not ((bitField0_ And &H80) <> 0) Then
			  uint64Data_ = mutableCopy(uint64Data_)
			  bitField0_ = bitField0_ Or &H80
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Uint64DataList As IList(Of Long) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getUint64DataList
			  Get
				Return If((bitField0_ And &H80) <> 0, java.util.Collections.unmodifiableList(uint64Data_), uint64Data_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property Uint64DataCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getUint64DataCount
			  Get
				Return uint64Data_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public Function getUint64Data(ByVal index As Integer) As Long Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getUint64Data
			Return uint64Data_.getLong(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public Function setUint64Data(ByVal index As Integer, ByVal value As Long) As Builder
			ensureUint64DataIsMutable()
			uint64Data_.setLong(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public Function addUint64Data(ByVal value As Long) As Builder
			ensureUint64DataIsMutable()
			uint64Data_.addLong(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllUint64Data(Of T1 As Long)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureUint64DataIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, uint64Data_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For uint64 and uint32 values
		  ''' When this field is present, the data_type field MUST be
		  ''' UINT32 or UINT64
		  ''' </pre>
		  ''' 
		  ''' <code>repeated uint64 uint64_data = 11 [packed = true];</code>
		  ''' </summary>
		  Public Function clearUint64Data() As Builder
			uint64Data_ = emptyLongList()
			bitField0_ = (bitField0_ And Not &H80)
			onChanged()
			Return Me
		  End Function

		  Friend halfVal_ As org.nd4j.shade.protobuf.Internal.IntList = emptyIntList()
		  Friend Sub ensureHalfValIsMutable()
			If Not ((bitField0_ And &H100) <> 0) Then
			  halfVal_ = mutableCopy(halfVal_)
			  bitField0_ = bitField0_ Or &H100
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property HalfValList As IList(Of Integer) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getHalfValList
			  Get
				Return If((bitField0_ And &H100) <> 0, java.util.Collections.unmodifiableList(halfVal_), halfVal_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property HalfValCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getHalfValCount
			  Get
				Return halfVal_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public Function getHalfVal(ByVal index As Integer) As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getHalfVal
			Return halfVal_.getInt(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public Function setHalfVal(ByVal index As Integer, ByVal value As Integer) As Builder
			ensureHalfValIsMutable()
			halfVal_.setInt(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public Function addHalfVal(ByVal value As Integer) As Builder
			ensureHalfValIsMutable()
			halfVal_.addInt(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllHalfVal(Of T1 As Integer)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureHalfValIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, halfVal_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' For half values (tensorflow compatibility)
		  ''' </pre>
		  ''' 
		  ''' <code>repeated int32 half_val = 15 [packed = true];</code>
		  ''' </summary>
		  Public Function clearHalfVal() As Builder
			halfVal_ = emptyIntList()
			bitField0_ = (bitField0_ And Not &H100)
			onChanged()
			Return Me
		  End Function

		  Friend boolVal_ As org.nd4j.shade.protobuf.Internal.BooleanList = emptyBooleanList()
		  Friend Sub ensureBoolValIsMutable()
			If Not ((bitField0_ And &H200) <> 0) Then
			  boolVal_ = mutableCopy(boolVal_)
			  bitField0_ = bitField0_ Or &H200
			End If
		  End Sub
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property BoolValList As IList(Of Boolean) Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getBoolValList
			  Get
				Return If((bitField0_ And &H200) <> 0, java.util.Collections.unmodifiableList(boolVal_), boolVal_)
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public ReadOnly Property BoolValCount As Integer Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getBoolValCount
			  Get
				Return boolVal_.size()
			  End Get
		  End Property
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public Function getBoolVal(ByVal index As Integer) As Boolean Implements org.nd4j.ir.TensorNamespace.TensorProtoOrBuilder.getBoolVal
			Return boolVal_.getBoolean(index)
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public Function setBoolVal(ByVal index As Integer, ByVal value As Boolean) As Builder
			ensureBoolValIsMutable()
			boolVal_.setBoolean(index, value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public Function addBoolVal(ByVal value As Boolean) As Builder
			ensureBoolValIsMutable()
			boolVal_.addBoolean(value)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public Function addAllBoolVal(Of T1 As Boolean)(ByVal values As IEnumerable(Of T1)) As Builder
			ensureBoolValIsMutable()
			org.nd4j.shade.protobuf.AbstractMessageLite.Builder.addAll(values, boolVal_)
			onChanged()
			Return Me
		  End Function
		  ''' <summary>
		  ''' <pre>
		  ''' boolean values
		  ''' </pre>
		  ''' 
		  ''' <code>repeated bool bool_val = 16 [packed = true];</code>
		  ''' </summary>
		  Public Function clearBoolVal() As Builder
			boolVal_ = emptyBooleanList()
			bitField0_ = (bitField0_ And Not &H200)
			onChanged()
			Return Me
		  End Function
'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder setUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function setUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.setUnknownFields(unknownFields)
		  End Function

'JAVA TO VB CONVERTER WARNING: 'final' parameters are not available in VB:
'ORIGINAL LINE: @java.lang.Override public final Builder mergeUnknownFields(final org.nd4j.shade.protobuf.UnknownFieldSet unknownFields)
		  Public Overrides Function mergeUnknownFields(ByVal unknownFields As org.nd4j.shade.protobuf.UnknownFieldSet) As Builder
			Return MyBase.mergeUnknownFields(unknownFields)
		  End Function


		  ' @@protoc_insertion_point(builder_scope:org.nd4j.ir.TensorProto)
		End Class

		' @@protoc_insertion_point(class_scope:org.nd4j.ir.TensorProto)
		Friend Shared ReadOnly DEFAULT_INSTANCE As org.nd4j.ir.TensorNamespace.TensorProto
		Shared Sub New()
		  DEFAULT_INSTANCE = New org.nd4j.ir.TensorNamespace.TensorProto()
		End Sub

		Public Shared ReadOnly Property DefaultInstance As org.nd4j.ir.TensorNamespace.TensorProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

'JAVA TO VB CONVERTER NOTE: The field PARSER was renamed since Visual Basic does not allow fields to have the same name as other class members:
		Friend Shared ReadOnly PARSER_Conflict As org.nd4j.shade.protobuf.Parser(Of TensorProto) = New AbstractParserAnonymousInnerClass()

		Private Class AbstractParserAnonymousInnerClass
			Inherits org.nd4j.shade.protobuf.AbstractParser(Of TensorProto)

'JAVA TO VB CONVERTER WARNING: Method 'throws' clauses are not available in VB:
'ORIGINAL LINE: @java.lang.Override public TensorProto parsePartialFrom(org.nd4j.shade.protobuf.CodedInputStream input, org.nd4j.shade.protobuf.ExtensionRegistryLite extensionRegistry) throws org.nd4j.shade.protobuf.InvalidProtocolBufferException
			Public Overrides Function parsePartialFrom(ByVal input As org.nd4j.shade.protobuf.CodedInputStream, ByVal extensionRegistry As org.nd4j.shade.protobuf.ExtensionRegistryLite) As TensorProto
			  Return New TensorProto(input, extensionRegistry)
			End Function
		End Class

		Public Shared Function parser() As org.nd4j.shade.protobuf.Parser(Of TensorProto)
		  Return PARSER_Conflict
		End Function

		Public Overrides ReadOnly Property ParserForType As org.nd4j.shade.protobuf.Parser(Of TensorProto)
			Get
			  Return PARSER_Conflict
			End Get
		End Property

		Public Overrides ReadOnly Property DefaultInstanceForType As org.nd4j.ir.TensorNamespace.TensorProto
			Get
			  Return DEFAULT_INSTANCE
			End Get
		End Property

	  End Class

	  Private Shared ReadOnly internal_static_org_nd4j_ir_StringStringEntryProto_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TypeProto_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorShapeProto_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_ValueInfoProto_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorProto_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorProto_Segment_descriptor As org.nd4j.shade.protobuf.Descriptors.Descriptor
	  Private Shared ReadOnly internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable As org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable

	  Public Shared ReadOnly Property Descriptor As org.nd4j.shade.protobuf.Descriptors.FileDescriptor
		  Get
			Return descriptor
		  End Get
	  End Property
	  Private Shared descriptor As org.nd4j.shade.protobuf.Descriptors.FileDescriptor
	  Shared Sub New()
		Dim descriptorData() As String = { vbLf & ChrW(&O014).ToString() & "tensor.proto" & ChrW(&O022).ToString() & ChrW(&O013).ToString() & "org.nd4j.ir""4" & vbLf & ChrW(&O026).ToString() & "StringStr" & "ingEntryProto" & ChrW(&O022).ToString() & ChrW(&O013).ToString() & vbLf & ChrW(&O003).ToString() & "key" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & ChrW(&O022).ToString() & vbCrLf & ChrW(&O005).ToString() & "value" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & """" & ChrW(&O300).ToString() & ChrW(&O001).ToString() & vbLf & vbTab & "TypeProto" & ChrW(&O022).ToString() & ">" & vbLf & ChrW(&O013).ToString() & "tensor_type" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O013).ToString() & "2'.o" & "rg.nd4j.ir.TypeProto.TensorDescriptorH" & ChrW(&O000).ToString() & ChrW(&O032).ToString() & "j" & vbLf & ChrW(&O020).ToString() & "TensorDescriptor" & ChrW(&O022).ToString() & "(" & vbLf & vbTab & "elem_type" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O016).ToString() & "2" & ChrW(&O025).ToString() & ".org.nd4j.ir.DataType" & ChrW(&O022).ToString() & "," & vbLf & ChrW(&O005).ToString() & "shape" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O013).ToString() & "2" & ChrW(&O035).ToString() & ".o" & "rg.nd4j.ir.TensorShapeProtoB" & ChrW(&O007).ToString() & vbLf & ChrW(&O005).ToString() & "value""" & ChrW(&O210).ToString() & ChrW(&O001).ToString() & vbLf & ChrW(&O020).ToString() & "TensorShapeProto" & ChrW(&O022).ToString() & "4" & vbLf & ChrW(&O003).ToString() & "dim" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O013).ToString() & "2'.org.nd4" & "j.ir.TensorShapeProto.Dimension" & ChrW(&O032).ToString() & ">" & vbLf & vbTab & "Dimen" & "sion" & ChrW(&O022).ToString() & ChrW(&O023).ToString() & vbLf & vbTab & "dim_value" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O003).ToString() & "H" & ChrW(&O000).ToString() & ChrW(&O022).ToString() & ChrW(&O023).ToString() & vbLf & vbTab & "dim_param" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & "H" & ChrW(&O000).ToString() & "B" & ChrW(&O007).ToString() & vbLf & ChrW(&O005).ToString() & "value""X" & vbLf & ChrW(&O016).ToString() & "ValueInfoProto" & ChrW(&O022).ToString() & ChrW(&O014).ToString() & vbLf & ChrW(&O004).ToString() & "nam" & "e" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & ChrW(&O022).ToString() & "$" & vbLf & ChrW(&O004).ToString() & "type" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O013).ToString() & "2" & ChrW(&O026).ToString() & ".org.nd4j.ir.Type" & "Proto" & ChrW(&O022).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & "doc_string" & ChrW(&O030).ToString() & ChrW(&O003).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & """" & ChrW(&O234).ToString() & ChrW(&O004).ToString() & vbLf & ChrW(&O013).ToString() & "TensorProt" & "o" & ChrW(&O022).ToString() & ChrW(&O014).ToString() & vbLf & ChrW(&O004).ToString() & "dims" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O003).ToString() & ChrW(&O022).ToString() & ChrW(&O021).ToString() & vbLf & vbTab & "data_type" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O005).ToString() & ChrW(&O022).ToString() & "1" & vbLf & ChrW(&O007).ToString() & "se" & "gment" & ChrW(&O030).ToString() & ChrW(&O003).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O013).ToString() & "2 .org.nd4j.ir.TensorProto.Se" & "gment" & ChrW(&O022).ToString() & ChrW(&O026).ToString() & vbLf & vbLf & "float_data" & ChrW(&O030).ToString() & ChrW(&O004).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O002).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O026).ToString() & vbLf & vbLf & "int32_d" & "ata" & ChrW(&O030).ToString() & ChrW(&O005).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O005).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O023).ToString() & vbLf & ChrW(&O013).ToString() & "string_data" & ChrW(&O030).ToString() & ChrW(&O006).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O014).ToString() & ChrW(&O022).ToString() & ChrW(&O026).ToString() & vbLf & vbLf & "in" & "t64_data" & ChrW(&O030).ToString() & ChrW(&O007).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O003).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O014).ToString() & vbLf & ChrW(&O004).ToString() & "name" & ChrW(&O030).ToString() & ChrW(&O010).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & ChrW(&O022).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & "doc_" & "string" & ChrW(&O030).ToString() & ChrW(&O014).ToString() & " " & ChrW(&O001).ToString() & "(" & vbTab & ChrW(&O022).ToString() & ChrW(&O020).ToString() & vbLf & ChrW(&O010).ToString() & "raw_data" & ChrW(&O030).ToString() & vbTab & " " & ChrW(&O001).ToString() & "(" & ChrW(&O014).ToString() & ChrW(&O022).ToString() & ":" & vbLf & vbCr & "extern" & "al_data" & ChrW(&O030).ToString() & vbCr & " " & ChrW(&O003).ToString() & "(" & ChrW(&O013).ToString() & "2#.org.nd4j.ir.StringString" & "EntryProto" & ChrW(&O022).ToString() & "<" & vbLf & vbCr & "data_location" & ChrW(&O030).ToString() & ChrW(&O016).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O016).ToString() & "2%.org." & "nd4j.ir.TensorProto.DataLocation" & ChrW(&O022).ToString() & ChrW(&O027).ToString() & vbLf & ChrW(&O013).ToString() & "doub" & "le_data" & ChrW(&O030).ToString() & vbLf & " " & ChrW(&O003).ToString() & "(" & ChrW(&O001).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O027).ToString() & vbLf & ChrW(&O013).ToString() & "uint64_data" & ChrW(&O030).ToString() & ChrW(&O013).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O004).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O024).ToString() & vbLf & ChrW(&O010).ToString() & "half_val" & ChrW(&O030).ToString() & ChrW(&O017).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O005).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & ChrW(&O024).ToString() & vbLf & ChrW(&O010).ToString() & "bool_val" & ChrW(&O030).ToString() & ChrW(&O020).ToString() & " " & ChrW(&O003).ToString() & "(" & ChrW(&O010).ToString() & "B" & ChrW(&O002).ToString() & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O032).ToString() & "%" & vbLf & ChrW(&O007).ToString() & "Segment" & ChrW(&O022).ToString() & vbCrLf & ChrW(&O005).ToString() & "begin" & ChrW(&O030).ToString() & ChrW(&O001).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O003).ToString() & ChrW(&O022).ToString() & ChrW(&O013).ToString() & vbLf & ChrW(&O003).ToString() & "end" & ChrW(&O030).ToString() & ChrW(&O002).ToString() & " " & ChrW(&O001).ToString() & "(" & ChrW(&O003).ToString() & """)" & vbLf & ChrW(&O014).ToString() & "DataLocation" & ChrW(&O022).ToString() & ChrW(&O013).ToString() & vbLf & ChrW(&O007).ToString() & "DEFAULT" & ChrW(&O020).ToString() & ChrW(&O000).ToString() & ChrW(&O022).ToString() & ChrW(&O014).ToString() & vbLf & ChrW(&O010).ToString() & "EX" & "TERNAL" & ChrW(&O020).ToString() & ChrW(&O001).ToString() & "*" & ChrW(&O332).ToString() & ChrW(&O001).ToString() & vbLf & ChrW(&O010).ToString() & "DataType" & ChrW(&O022).ToString() & vbCrLf & vbTab & "UNDEFINED" & ChrW(&O020).ToString() & ChrW(&O000).ToString() & ChrW(&O022).ToString() & vbTab & vbLf & ChrW(&O005).ToString() & "FLOAT" & ChrW(&O020).ToString() & ChrW(&O001).ToString() & ChrW(&O022).ToString() & vbTab & vbLf & ChrW(&O005).ToString() & "UINT8" & ChrW(&O020).ToString() & ChrW(&O002).ToString() & ChrW(&O022).ToString() & ChrW(&O010).ToString() & vbLf & ChrW(&O004).ToString() & "INT8" & ChrW(&O020).ToString() & ChrW(&O003).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & ChrW(&O006).ToString() & "UINT16" & ChrW(&O020).ToString() & ChrW(&O004).ToString() & ChrW(&O022).ToString() & vbTab & vbLf & ChrW(&O005).ToString() & "INT16" & ChrW(&O020).ToString() & ChrW(&O005).ToString() & ChrW(&O022).ToString() & vbTab & vbLf & ChrW(&O005).ToString() & "INT32" & ChrW(&O020).ToString() & ChrW(&O006).ToString() & ChrW(&O022).ToString() & vbTab & vbLf & ChrW(&O005).ToString() & "INT64" & ChrW(&O020).ToString() & ChrW(&O007).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & ChrW(&O006).ToString() & "STR" & "ING" & ChrW(&O020).ToString() & ChrW(&O010).ToString() & ChrW(&O022).ToString() & ChrW(&O010).ToString() & vbLf & ChrW(&O004).ToString() & "BOOL" & ChrW(&O020).ToString() & vbTab & ChrW(&O022).ToString() & ChrW(&O013).ToString() & vbLf & ChrW(&O007).ToString() & "FLOAT16" & ChrW(&O020).ToString() & vbLf & ChrW(&O022).ToString() & vbLf & vbLf & ChrW(&O006).ToString() & "DOUBLE" & ChrW(&O020).ToString() & ChrW(&O013).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & ChrW(&O006).ToString() & "UINT32" & ChrW(&O020).ToString() & ChrW(&O014).ToString() & ChrW(&O022).ToString() & vbLf & vbLf & ChrW(&O006).ToString() & "UINT64" & ChrW(&O020).ToString() & vbCr & ChrW(&O022).ToString() & vbCrLf & vbTab & "COMPLEX64" & ChrW(&O020).ToString() & ChrW(&O016).ToString() & ChrW(&O022).ToString() & ChrW(&O016).ToString() & vbLf & vbLf & "COMPLEX128" & ChrW(&O020).ToString() & ChrW(&O017).ToString() & ChrW(&O022).ToString() & ChrW(&O014).ToString() & vbLf & ChrW(&O010).ToString() & "BFLOAT16" & ChrW(&O020).ToString() & ChrW(&O020).ToString() & "B" & ChrW(&O021).ToString() & "B" & ChrW(&O017).ToString() & "TensorN" & "amespaceb" & ChrW(&O006).ToString() & "proto3" }
		descriptor = org.nd4j.shade.protobuf.Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(descriptorData, New org.nd4j.shade.protobuf.Descriptors.FileDescriptor() {})
		internal_static_org_nd4j_ir_StringStringEntryProto_descriptor = Descriptor.getMessageTypes().get(0)
		internal_static_org_nd4j_ir_StringStringEntryProto_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_StringStringEntryProto_descriptor, New String() { "Key", "Value"})
		internal_static_org_nd4j_ir_TypeProto_descriptor = Descriptor.getMessageTypes().get(1)
		internal_static_org_nd4j_ir_TypeProto_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TypeProto_descriptor, New String() { "TensorType", "Value"})
		internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor = internal_static_org_nd4j_ir_TypeProto_descriptor.getNestedTypes().get(0)
		internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TypeProto_TensorDescriptor_descriptor, New String() { "ElemType", "Shape"})
		internal_static_org_nd4j_ir_TensorShapeProto_descriptor = Descriptor.getMessageTypes().get(2)
		internal_static_org_nd4j_ir_TensorShapeProto_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TensorShapeProto_descriptor, New String() { "Dim"})
		internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor = internal_static_org_nd4j_ir_TensorShapeProto_descriptor.getNestedTypes().get(0)
		internal_static_org_nd4j_ir_TensorShapeProto_Dimension_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TensorShapeProto_Dimension_descriptor, New String() { "DimValue", "DimParam", "Value"})
		internal_static_org_nd4j_ir_ValueInfoProto_descriptor = Descriptor.getMessageTypes().get(3)
		internal_static_org_nd4j_ir_ValueInfoProto_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_ValueInfoProto_descriptor, New String() { "Name", "Type", "DocString"})
		internal_static_org_nd4j_ir_TensorProto_descriptor = Descriptor.getMessageTypes().get(4)
		internal_static_org_nd4j_ir_TensorProto_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TensorProto_descriptor, New String() { "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "ExternalData", "DataLocation", "DoubleData", "Uint64Data", "HalfVal", "BoolVal"})
		internal_static_org_nd4j_ir_TensorProto_Segment_descriptor = internal_static_org_nd4j_ir_TensorProto_descriptor.getNestedTypes().get(0)
		internal_static_org_nd4j_ir_TensorProto_Segment_fieldAccessorTable = New org.nd4j.shade.protobuf.GeneratedMessageV3.FieldAccessorTable(internal_static_org_nd4j_ir_TensorProto_Segment_descriptor, New String() { "Begin", "End"})
	  End Sub

	  ' @@protoc_insertion_point(outer_class_scope)
	End Class

End Namespace